{
  "sourceUrl": "https://medium.com/feed/airbnb-engineering",
  "title": "The Airbnb Tech Blog - Medium",
  "description": "Creative engineers and data scientists building a world where you can belong anywhere. http://airbnb.io - Medium",
  "link": "https://medium.com/airbnb-engineering?source=rss----53c7c27702d5---4",
  "items": [
    {
      "title": "从静态限流到Airbnb键值存储中的自适应流量管理 (原标题: From Static Rate Limiting to Adaptive Traffic Management in Airbnb’s Key-Value Store)",
      "link": "https://medium.com/airbnb-engineering/from-static-rate-limiting-to-adaptive-traffic-management-in-airbnbs-key-value-store-29362764e5c2?source=rss----53c7c27702d5---4",
      "pubDate": "Thu, 09 Oct 2025 16:01:55 GMT",
      "isoDate": "2025-10-09T16:01:55.000Z",
      "creator": "Shravan Gaonkar",
      "summary": "Airbnb的键值存储Mussel已从简单的静态限流系统演进为多层级的自适应流量管理方案，以确保在流量高峰、批量上传、机器人攻击或DDoS攻击等复杂场景下的快速和可靠性。\n\n# Mussel流量管理演进概述\n\nMussel作为Airbnb核心服务的关键组件，处理所有请求。其早期QoS系统依赖于基于Redis的静态QPS限流，主要目标是防止服务崩溃。然而，随着服务成熟，目标转向了最大化“有效吞吐量”（goodput），即在不降低性能的前提下完成最多有用的工作。这促使Airbnb开发了一个自适应的QoS系统，该系统能够自动施加优先背压。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*kBx_8QLd7El4TZ2nrouYUw.jpeg)\n\n# 新增的QoS层级\n\n为实现自适应流量管理和最大化有效吞吐量，Mussel的QoS系统增加了以下几个新层级：\n\n1.  **资源感知限流 (RARC)**：根据请求的实际资源消耗（如行数、字节和延迟）而非简单的请求计数来计费。\n2.  **分级负载卸载**：在容量不足时，优先保障高优先级流量（如客户支持、信任与安全）的响应性。\n3.  **热键检测与DDoS缓解**：实时检测访问模式倾斜，并通过缓存或合并重复请求来保护后端存储层。\n\n# 静态客户端配额限流的局限性\n\nMussel最初的限流系统简单且易于操作，为每个调用者设置静态的每分钟QPS配额。然而，随着系统采用率的增长，其局限性逐渐显现：\n\n*   **成本差异**：一个单行查询和一个十万行扫描被视为相同的成本，未能反映其对后端负载的巨大差异。\n*   **流量倾斜**：无法识别“热键”问题。当一个键被大量不同调用者同时访问时，即使每个调用者都在其配额内，聚合流量仍可能使底层存储分片过载，导致局部瓶颈并影响整个集群的性能。\n\n这些局限性促使Airbnb从“请求计数”思维转向“资源核算”思维。\n\n![图片 2](https://cdn-images-1.medium.com/max/1024/1*XVDMQb8i2pQEUogiZipFbQ.jpeg)\n\n# 资源感知限流 (RARC)\n\nRARC通过引入“请求单位”（RU）来解决成本差异问题。RU的计算综合了四个可观测因素：\n\n*   固定的每次调用开销\n*   处理的行数\n*   负载字节数\n*   **关键的延迟**：延迟能够反映缓存命中与磁盘访问等不同成本。\n\nRU的计算公式示例：\n*   `RU_read = 1 + w_r × bytes_read + w_l × latency_ms`\n*   `RU_write = 6 + w_b × bytes_written / 4096 bytes + w_l × latency_ms`\n\n每个调度器使用一个本地令牌桶来管理RU配额，并根据请求的RU成本进行扣除。当令牌桶为空时，请求将被拒绝（HTTP 419）。后端延迟会影响负载卸载层，而非RU的周期性补充，这使得限流核算保持简单，同时能快速响应存储层的压力。\n\n![图片 3](https://cdn-images-1.medium.com/max/1024/1*VuIeZSMzyRqXuXpfSzM_yg.jpeg)\n\n# 负载卸载：应对快速变化的容量问题\n\nRARC在秒级尺度上调整，但无法应对更快的负载变化。负载卸载层通过结合三个实时信号来弥补这一不足：\n\n1.  **流量关键性**：根据预定义的优先级，确保高优先级流量在容量紧张时仍能响应。\n2.  **延迟比率**：实时系统压力指标，通过长期p95延迟除以短期p95延迟计算。比率趋近0.3表示延迟急剧上升。当达到阈值时，调度器会暂时增加指定客户端类别的RU成本，加速其令牌桶耗尽，从而降低请求速率。该比率使用P²算法计算。\n3.  **CoDel启发式排队策略**：监控请求在调度器内部队列的等待时间。如果等待时间过长表明系统已饱和，请求将提前失败，释放内存和线程。\n\n这些机制协同工作，使Mussel在后端出现问题时能将恢复时间缩短约一半，并使调度器无需人工干预即可保持稳定。\n\n![图片 4](https://cdn-images-1.medium.com/max/1024/1*GWv-z2hXM6RiW6sRJKzYCg.png)\n\n# 热键检测与DDoS防御\n\nRU限流和负载卸载无法有效阻止针对单个记录的大量相同读取请求（如热门列表、爬虫或DDoS攻击）。Mussel通过三步热键防御层来解决此问题：\n\n1.  **实时检测**：每个调度器使用内存中的top-k计数器（Space-Saving算法变体）实时追踪最热门的键。\n2.  **本地缓存**：当一个键达到“热”阈值时，调度器会从进程本地的LRU缓存中提供服务，条目在大约三秒后过期。\n3.  **请求合并**：对于缓存未命中，调度器会跟踪正在进行的读取请求，新到达的相同请求会附加到待处理的Future上，第一个后端响应会扇出给所有等待者。这确保了通常每个热键每个调度器Pod只有一个请求到达存储层。\n\n在一次模拟DDoS演练中，针对少量键的百万QPS规模突发流量被热键层压缩到极低水平，后端未受到影响。\n\n![图片 5](https://cdn-images-1.medium.com/max/1024/1*DuwP-cqJEnQcbD64RGUTYA.png)\n\n# 回顾与关键启示\n\n*   **早期可见成果的价值**：RARC的早期部署验证了概念，为后续更深层次的改进奠定了基础。\n*   **偏好本地控制循环**：所有关键信号（P²延迟分位数、Space-Saving top-k计数器、CoDel队列延迟）都在每个调度器内部运行，无需跨节点协调，实现了线性扩展，即使控制平面受压也能保护容量。\n*   **分时尺度的有效保护**：RU定价处理微突发，而延迟比率和CoDel队列阈值响应宏观减速。两者结合才能有效应对各种冲击。\n*   **QoS是一个活的系统**：流量模式、后端能力和新工作负载不断演变。未来的计划包括数据库原生资源组和基于历史使用曲线的自动配额调整。指导原则是：衡量真实成本、本地快速响应、分层防御。",
      "shortSummary": "Airbnb的键值存储Mussel已从静态限流演进为自适应流量管理，以应对高峰流量和DDoS攻击。最初的QPS限流因无法区分请求成本和处理热键而受限。新系统引入了资源感知限流（RARC），根据请求的实际资源消耗（包括延迟）计费。此外，它还通过分级负载卸载（基于流量关键性、实时延迟比率和排队策略）和热键检测与防御（实时缓存和请求合并）来确保服务可靠性。这些改进显著提升了系统在压力下的韧性，并减少了恢复时间。",
      "translated_title": "从静态限流到Airbnb键值存储中的自适应流量管理",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*kBx_8QLd7El4TZ2nrouYUw.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*XVDMQb8i2pQEUogiZipFbQ.jpeg",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*VuIeZSMzyRqXuXpfSzM_yg.jpeg",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*GWv-z2hXM6RiW6sRJKzYCg.png",
          "alt": "",
          "title": "",
          "position": 4
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*DuwP-cqJEnQcbD64RGUTYA.png",
          "alt": "",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "RSS",
      "content": "<p>How Airbnb hardened Mussel, our key-value store, with smarter traffic controls to stay fast and reliable during traffic spikes.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*kBx_8QLd7El4TZ2nrouYUw.jpeg\" /></figure><p>By <a href=\"https://www.linkedin.com/in/shravangaonkar/\">Shravan Gaonkar</a>, <a href=\"https://www.linkedin.com/in/caseygetz/\">Casey Getz</a>, <a href=\"https://www.linkedin.com/in/wonheec/\">Wonhee Cho</a></p><h3>Introduction</h3><p>Every request lookup on Airbnb, from stays, experiences, and services search to customer support inquiries ultimately hits <a href=\"https://medium.com/airbnb-engineering/mussel-airbnbs-key-value-store-for-derived-data-406b9fa1b296\">Mussel</a>, our multi-tenant key-value store for derived data. Mussel operates as a proxy service, deployed as a fleet of stateless dispatchers — each a Kubernetes pod. On a typical day, this fleet handles millions of predictable point and range reads. During peak events, however, it must absorb several-fold higher volume, terabyte-scale bulk uploads, and sudden bursts from automated bots or DDoS attacks. Its ability to reliably serve this volatile mix of traffic is therefore critical to both the Airbnb user experience and the stability of the many services that power our platform.</p><p>Given Mussel’s traffic volume and its role in core Airbnb flows, <a href=\"https://en.wikipedia.org/wiki/Quality_of_service\">quality of service</a> (QoS) is one of the product’s defining features. The first-generation QoS system was primarily an isolation tool. It relied on a Redis-backed counter, client quota based rate-limiter, that checked a caller’s requests per second (QPS) against a configurable fixed quota. The goal was to prevent a single misbehaving client from overwhelming the service and causing a complete outage. For this purpose, it was simple and effective.</p><p>However, as the service matured, our goal shifted from merely preventing meltdowns to maximizing goodput — that is, getting the most useful work done without degrading performance. A system of fixed, manually configured quotas can’t achieve this, as it can’t adapt in real time to shifting traffic patterns, new query shapes, or sudden threats like a DDoS attack. A truly effective QoS system needs to be adaptive, automatically exerting prioritized backpressure when it senses the system has reached its useful capacity.</p><p>To better match our QoS system to the realities of online traffic and maximize goodput, over time we evolved it to add several new layers.</p><ul><li><strong>Resource-aware rate control (RARC)</strong>: Charges each request in <em>request units</em> (RU) that reflect rows, bytes, and latency, not just counts.</li><li><strong>Load shedding with criticality tiers</strong>: Guarantees that high-priority traffic (e.g., customer support, trust and safety) stays responsive when capacity evaporates.</li><li><strong>Hot-key detection &amp; DDoS mitigation</strong>: Detects skewed access patterns in real time and then shields the backend — whether the surge is legitimate or a DDoS burst — by caching or coalescing the duplicate requests before they reach the storage layer.</li></ul><p>What follows is an engineer’s view of how these layers were designed, deployed, and battle-tested, and why the same ideas may apply to any multi-tenant system that has outgrown simple QPS limits.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XVDMQb8i2pQEUogiZipFbQ.jpeg\" /><figcaption>Progression Timeline</figcaption></figure><h3>Background: Life with Client Quota Rate Limiter</h3><p>When Mussel launched, rate-limiting was entirely handled via simple QPS rate-limiting using a Redis-based distributed counter service. Each caller received a static, per-minute quota, and the dispatcher incremented a Redis key for every incoming request. If the key’s value exceeded the caller’s quota, the dispatcher returned an HTTP 429. The design was simple, predictable, and easy to operate.</p><p>Two architectural details made this feasible. First, Mussel and its storage engine were tightly coupled; backend effort correlated reasonably well with the number of calls at the front door. Second, the traffic mix was modest in size and variety, so a single global limit per caller rarely caused trouble.</p><p>As adoption grew, two limitations became clear.</p><ol><li><strong>Cost variance:</strong> A one-row lookup and a 100,000-row scan were treated equally, even though their load on the backend differed by orders of magnitude. The system couldn’t distinguish high-value cheap work from low-value expensive work.</li><li><strong>Traffic skew:</strong> Per-caller rate limits provided isolation at the client level, but were blind to the data’s access pattern. When a single key became “hot” — for example, a popular listing accessed by thousands of different callers simultaneously — the aggregate traffic could overwhelm the underlying storage shard, even if each individual caller remained within its quota. This created a localized bottleneck that degraded performance for the entire cluster, impacting clients requesting completely unrelated data. Isolation by <em>caller</em> was insufficient to prevent this kind of resource contention.</li></ol><p>Addressing these gaps meant shifting from a <em>request-counting</em> mindset to a <em>resource-accounting</em> mindset and designing controls that reflect the real cost of each operation.</p><h3>Resource-aware rate control</h3><p>A fair quota system must account for the real work a request imposes on the storage layer. Resource-aware rate control (RARC) meets this need by charging operations in <em>request units</em> (RU) rather than raw requests per second.</p><p>A request unit blends four observable factors: fixed per-call overhead, rows processed, payload bytes, and — crucially — latency. Latency captures effects that rows and bytes alone miss: two one-megabyte reads can differ greatly in cost if one hits cache and the other triggers disk. In practice, we use a linear model. For both reads and writes, the cost is:</p><pre><br>RU_read = 1 + w_r × bytes_read + w_l × latency_ms<br>RU_write = 6 + w_b × bytes_written / 4096 bytes + w_l × latency_ms<br><br>Weight factors w_r, w_b, and w_l come from load-test calibration <br>based on the compute, network and disk I/O. <br>bytes_read, bytes_written and latency is measured per request</pre><p>Although approximate, the formula separates operations whose surface metrics look similar yet load the backend very differently.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VuIeZSMzyRqXuXpfSzM_yg.jpeg\" /><figcaption>Impact of Latency on RU computation</figcaption></figure><p>Each dispatcher continues to rely on rate-limiter for distributed counting, but the counter now represents request-unit tokens instead of raw QPS. At the start of every epoch, the dispatcher adds the caller’s static RU quota to a local token bucket and immediately debits that bucket by the RU cost of each incoming request. When the bucket is empty, the request is rejected with HTTP 419. Because all dispatchers follow the same procedure and epochs are short, their buckets remain closely aligned without additional coordination.</p><p>Adaptive protection is handled in the separate load-shedding layer; backend latency influences which traffic is dropped or delayed, not the size of the periodic RU refill. This keeps rate accounting straightforward — static quotas expressed in request units — while still reacting quickly when the storage layer shows signs of stress.</p><h3>Load shedding: Staying healthy when capacity evaporates or develops hotspots</h3><p>Rate limits based on request units excel at smoothing normal traffic, but they adjust on a scale of seconds. When the workload shifts faster — a bot floods a key, a shard stalls, or a batch job begins a full-table scan — those seconds are enough for queues to balloon and service-level objectives to slip. To bridge this reaction-time gap, Mussel uses a load-shedding safety net that combines three real-time signals: (1) traffic criticality, (2) a latency ratio, and (3) a CoDel-inspired queueing policy.</p><p>The latency ratio is a ratio that serves as a real-time indicator of stress on the system stress. Each dispatcher computes this ratio by dividing the long-term p95 latency by the short-term p95 latency. A stable system has a ratio near 1.0; a value dropping towards 0.3 indicates that latency is rising sharply. When that threshold is crossed, the dispatcher temporarily increases the RU cost applied to a designated client class so that its token bucket drains faster and the request rate naturally backs off. If the ratio keeps falling, the same penalty can be expanded to additional classes until latency returns to a safe range.</p><p>The estimate uses the constant-memory P² algorithm [1], requiring no raw sample storage or cross-node coordination.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GWv-z2hXM6RiW6sRJKzYCg.png\" /><figcaption>Latency response over time and illustration of throttling</figcaption></figure><p>The Control-Delay (CoDel) thread pool tackles the second hazard: queue buildup <em>inside the dispatcher itself</em> [2]. It monitors the time a request <em>waits</em> in the queue. If that sojourn time proves the system is already saturated, the request fails early, freeing up memory and threads for higher-priority work. An optional latency penalty can also be applied to RU accounting, charging more for queries from callers that persistently trigger the latency ratio.</p><p>Together, these layers — criticality, a real-time latency ratio, and adaptive queueing — form a shield that lets guest-facing traffic ride out backend hiccups. In practice, this system has cut recovery times by about half and keeps dispatchers stable without human intervention.</p><h3>Hot-key detection and DDoS defence</h3><p>Request-unit limits and load shedding keep client usage fair, but they cannot stop a stampede of identical reads aimed at one record. Imagine a listing that hits the front page of a major news outlet: tens of thousands of guests refresh their browser, all asking for the same key. A misconfigured crawler — or a deliberate botnet — can generate the same access pattern, only faster. The result is shard overload, a full dispatcher queue, and rising latency for unrelated work.</p><p>Mussel neutralises this amplification with a three-step<strong> </strong>hot-key defence layer<strong>:</strong> real-time detection, local caching, and request coalescing.</p><h3>Real-time detection in constant space</h3><p>Every dispatcher streams incoming keys into an in-memory <em>top-k</em> counter. The counter is a variant of the Space-Saving algorithm [2] popularized in Brian Hayes’s “Britney Spears Problem” essay [4]. In just a few megabytes, it tracks approximate hit counts, maintains a frequency-ordered heap, and surfaces the hottest keys in real time in each individual dispatcher.</p><h3>Local caching and request coalescing</h3><p>When a key crosses the hot threshold, the dispatcher serves it from a process-local LRU cache. Entries expire after roughly three seconds, so they vanish as soon as demand cools; no global cache is required. A cache miss can still arrive multiple times in the same millisecond, so the dispatcher tracks in-flight reads for hot keys. New arrivals attach to the pending future; the first backend response then fans out to all waiters. In most cases only <em>one</em> request per hot key per dispatcher pod ever reaches the storage layer.</p><h3>Impact in production</h3><p>In a controlled DDoS drill that targeted a small set of keys at ≈ million-QPS scale, the hot-key layer collapsed the burst to a trickle — each dispatcher forwarded only an occasional request, well below the capacity of any individual shard — so the backend never felt the surge.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*DuwP-cqJEnQcbD64RGUTYA.png\" /><figcaption>Hotkeys detected and served from dispatcher cache in real time</figcaption></figure><h3>Retrospective and key takeaways</h3><p>The journey from a single QPS counter to a layered, cost-aware QoS stack has reshaped how Mussel handles traffic and, just as importantly, how engineers think about fairness and resilience. A few themes surface when we look back across the stages described above.</p><p>The first is the value of early, visible impact. The initial release of request-unit accounting went live well before load shedding or hot-key defence. Soon after deployment it automatically throttled a caller whose range scans had been quietly inflating cluster latency. That early win validated the concept and built momentum for the deeper changes that followed.</p><p>A second lesson is to prefer to keep control loops local. All the key signals — P² latency quantiles, the Space-Saving top-k counter, and CoDel queue delay — run entirely inside each dispatcher. Because no cross-node coordination is required, the system scales linearly and continues to protect capacity even if the control plane is itself under stress.</p><p>Third, effective protection works on<strong> </strong>two different time-scales<strong>.</strong> Per-call RU pricing catches micro-spikes; the latency ratio and CoDel queue thresholds respond to macro slow-downs. Neither mechanism alone would have kept latency flat during the last controlled DDoS drill, but in concert they absorbed the shock and recovered within seconds.</p><p>Finally, QoS is a living system. Traffic patterns evolve, back-end capabilities improve, and new workloads appear. Planned next steps include database-native resource groups and automatic quota tuning from thirty-day usage curves. The principles that guided this project — measure true cost, react locally and quickly, layer defences — form a durable template, but the implementation will continue to grow with the platform it protects.</p><p>Does this type of work interest you? We’re hiring, check out open roles <a href=\"https://careers.airbnb.com/\">here</a>.</p><h3>📚 References</h3><ol><li>Raj Jain and Imrich Chlamtac. 1985. The P² algorithm for dynamic calculation of quantiles and histograms without storing observations. <em>Communications of the ACM</em>, <strong>28</strong>(10), 1076–1085.<a href=\"https://doi.org/10.1145/4372.4378\"> https://doi.org/10.1145/4372.4378</a></li><li>Erik D. Demaine, Alejandro López-Ortiz, and J. Ian Munro. 2002. Frequency estimation of internet packet streams with limited space. In <em>Algorithms — ESA 2002: 10th Annual European Symposium</em>, Rome, Italy, September 17–21, 2002. Rolf H. Möhring and Rajeev Raman (Eds.). <em>Lecture Notes in Computer Science</em>, Vol. <strong>2461</strong>. Springer, 348–360.</li><li>Kathleen M. Nichols and Van Jacobson. 2012. Controlling queue delay. <em>Communications of the ACM</em>, <strong>55</strong>(7), 42–50.<a href=\"https://doi.org/10.1145/2209249.2209264\"> https://doi.org/10.1145/2209249.2209264</a></li><li>Brian Hayes. 2008. Computing science: The Britney Spears problem. <em>American Scientist</em>, <strong>96</strong>(4), 274–279. <a href=\"https://www.americanscientist.org/article/the-britney-spears-problem\">https://www.americanscientist.org/article/the-britney-spears-problem</a></li></ol><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=29362764e5c2\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/from-static-rate-limiting-to-adaptive-traffic-management-in-airbnbs-key-value-store-29362764e5c2\">From Static Rate Limiting to Adaptive Traffic Management in Airbnb’s Key-Value Store</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "在 Airbnb 构建下一代键值存储 (原标题: Building a Next-Generation Key-Value Store at Airbnb)",
      "link": "https://medium.com/airbnb-engineering/building-a-next-generation-key-value-store-at-airbnb-0de8465ba354?source=rss----53c7c27702d5---4",
      "pubDate": "Wed, 24 Sep 2025 16:02:09 GMT",
      "isoDate": "2025-09-24T16:02:09.000Z",
      "creator": "Shravan Gaonkar",
      "summary": "# Airbnb 下一代键值存储 Mussel 的构建\n\nAirbnb 重新设计了其核心键值存储 Mussel，从 v1 升级到 v2，以满足现代数据需求。Mussel 旨在连接离线和在线工作负载，提供高可扩展的批量加载能力和个位数毫秒级的读取速度。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*sUS0d9nGKa-WQupVS8Wb4g.jpeg)\n\n## 为什么进行重新架构？\n\nMussel v1 曾可靠支持 Airbnb 多年，但新的业务需求（如实时欺诈检查、即时个性化、动态定价和海量数据处理）要求一个能结合实时流处理与批量摄取、且易于管理的平台。\n\n## v1 的主要挑战\n\nMussel v2 旨在解决 v1 的以下问题：\n\n*   **操作复杂性：** v1 扩展或替换节点需手动执行多步 Chef 脚本；v2 采用 Kubernetes manifests 和自动化部署，将数小时工作缩短至数分钟。\n*   **容量与热点：** v1 的静态哈希分区可能导致节点过载和延迟峰值；v2 的动态范围分片和预分片确保了即使对于 100TB+ 的表，读取速度依然快速（p99 < 25ms）。\n*   **一致性灵活性：** v1 提供有限的一致性控制；v2 允许团队根据 SLA 需求选择即时或最终一致性。\n*   **成本与透明度：** v1 的资源使用不透明；v2 增加了命名空间租用、配额强制和仪表板，提供成本可见性和控制。\n\n## 新架构：Mussel v2\n\n![图片 2](https://cdn-images-1.medium.com/max/1024/1*yjXZcYHPpQdl-peEhfEAmA.png)\n\nMussel v2 是一个彻底的重新架构，旨在解决 v1 的操作和可扩展性挑战。它被设计为自动化、可维护和可扩展，同时确保功能对等，并为 100 多个现有用例提供简便的迁移。\n\n### 调度器 (Dispatcher)\n\n*   无状态、可水平扩展的 Kubernetes 服务，取代了 v1 紧耦合、协议特定的设计。\n*   将客户端 API 调用转换为后端查询/修改。\n*   支持双写和影子读模式以进行迁移。\n*   管理重试和速率限制，并与 Airbnb 的服务网格集成以实现安全和服务发现。\n*   **读取：** 每个数据名称映射到一个逻辑表，支持优化的点查找、范围/前缀查询，以及从本地副本进行陈旧读取以降低延迟。动态限流和优先级管理确保了在流量变化下的性能。\n*   **写入：** 首先持久化到 Kafka 以确保持久性，然后由 Replayer 和 Write Dispatcher 按顺序应用到后端。这种事件驱动模型吸收突发流量，确保一致性，并消除了 v1 的操作开销。Kafka 也支持升级、引导和迁移。\n\n### 批量加载 (Bulk Load)\n\n*   保留了 v1 的语义，支持“合并”（添加到现有表）和“替换”（交换数据集）操作。\n*   使用基于 Airflow 的现有接口进行数据导入，将数据仓库数据转换为标准化格式并上传到 S3。\n*   无状态控制器协调作业，分布式有状态工作节点集群（Kubernetes StatefulSets）并行执行摄取，将 S3 中的记录加载到表中。\n*   通过去重、增量合并和插入时重复键忽略等优化，确保了 Airbnb 规模下的高吞吐量和高效写入。\n\n### 数据生命周期管理 (TTL)\n\n*   v2 引入了拓扑感知的过期服务，将数据命名空间分片为基于范围的子任务，由多个工作节点并发处理。\n*   过期记录被并行扫描和删除，最大限度地减少了大型数据集的清理时间。\n*   子任务的调度旨在限制对实时查询的影响。\n*   写入密集型表使用最大版本强制和定向删除来维护性能和数据卫生。\n\n## 迁移过程\n\n### 挑战\n\nMussel 存储海量数据，服务于 Airbnb 数千个表，承载着关键任务的读写流量。迁移目标是：将所有数据和流量从 Mussel v1 迁移到 v2，实现零数据丢失和对客户可用性零影响。\n\n### 过程\n\n采用了蓝/绿迁移策略，但由于 v1 不提供表级快照或 CDC 流，因此增加了复杂性。\n\n*   **自定义迁移管道：** 开发了自定义管道，能够引导表到 v2。\n*   **双写：** 一旦表被引导，就启用双写，使 v2 与 v1 保持同步。\n*   **阶段划分：**\n    1.  **蓝色区域 (Blue Zone)：** 所有流量流向 v1。\n    2.  **影子模式 (Shadowing - Green)：** v2 开始影子 v1，并行处理读写，但仅 v1 响应。用于检查 v2 的正确性和性能。\n    3.  **反向模式 (Reverse)：** v2 接管活跃流量，v1 保持待机。内置自动断路器和回退逻辑。\n    4.  **切换 (Cutover)：** v2 通过所有检查后，按数据名称逐一完成切换，Kafka 作为写入可靠性的中间件。\n*   **风险降低：** 迁移逐表进行，每一步都可逆，并可根据表的风险配置文件进行微调。\n\n### 迁移管道详情\n\n![图片 3](https://cdn-images-1.medium.com/max/1024/1*4Q-yjBQu8jwWSv0pkkNIHQ.jpeg)\n\nv1 架构使用 Kafka 作为复制日志。在数据迁移到 v2 期间，利用相同的 Kafka 流来维护 v1 和 v2 之间的最终一致性。\n\n自定义管道步骤：\n\n1.  **源数据采样：** 从 v1 下载备份数据，提取相关表并采样以了解数据分布。\n2.  **在 v2 上创建预分片表：** 根据采样结果，创建具有预定义分片布局的 v2 表，以最小化迁移期间的数据重排。\n3.  **引导 (Bootstrap)：** 最耗时步骤，使用 Kubernetes StatefulSets 持久化本地状态并定期检查点进度。\n4.  **校验和验证：** 验证 v1 备份中的所有数据是否已正确摄取到 v2。\n5.  **追赶 (Catch-up)：** 应用在引导阶段 Kafka 中累积的任何滞后消息。\n6.  **双写：** v1 和 v2 从相同的 Kafka 主题消费，确保最终一致性。\n7.  **读流量迁移：** 调度器动态配置，逐步将读请求从 v1 切换到 v2，并进行影子请求和回退。\n\n## 经验教训\n\n*   **一致性复杂性：** 从最终一致性 (v1) 到强一致性 (v2) 引入了新的挑战，需要写入去重、热键阻塞和延迟写入修复。\n*   **预分片至关重要：** 从基于哈希 (v1) 到基于范围 (v2) 的分区，需要准确采样 v1 数据并预分片，以确保迁移期间后端节点的均衡摄取流量。\n*   **查询模型调整：** v2 不像 v1 那样有效地向下推送范围过滤器，需要实现客户端分页。\n*   **新鲜度与成本：** 不同用例需要不同的权衡，例如使用主副本获取最新数据或使用辅助副本平衡陈旧度与成本/性能。\n*   **Kafka 的作用：** Kafka 稳定的 p99 毫秒级延迟使其成为迁移过程中不可或缺的一部分。\n*   **构建灵活性：** 客户重试和常规批量作业提供了安全网，迁移设计允许按表分配阶段和即时可逆性，这对于大规模风险管理至关重要。\n\n最终，Airbnb 成功迁移了超过 PB 级的数据，涉及数千个表，实现了零停机和零数据丢失。\n\n## 结论与展望\n\nMussel v2 融合了通常仅限于独立专业系统的功能。它能够同时：\n\n*   批量上传数十 TB 数据。\n*   在同一集群中每秒处理 100k+ 流式写入。\n*   保持 p99 读取延迟低于 25 毫秒。\n*   允许调用者按命名空间切换陈旧读取。\n\n通过将 NewSQL 后端与 Kubernetes 原生控制平面结合，Mussel v2 提供了对象存储的弹性、低延迟缓存的响应能力和现代服务网格的可操作性。工程师无需再拼凑缓存、队列和数据存储来满足 SLA，Mussel 开箱即用，让团队专注于产品创新。\n\n未来，Airbnb 将分享更多关于 Mussel 中 QoS 管理的演进以及大规模批量加载优化的见解。",
      "shortSummary": "Airbnb 重新架构了其核心键值存储 Mussel，从 v1 升级到基于 NewSQL 后端和 Kubernetes 的 v2。此举旨在解决 v1 的操作复杂性、可扩展性、一致性及成本透明度问题。Mussel v2 实现了高可扩展性、低延迟读取和高效批量加载，并支持灵活的一致性模型。通过蓝/绿部署、双写和自定义迁移管道，Airbnb 成功迁移了数 PB 数据，实现了零停机和零数据丢失，极大地简化了数据基础设施管理，使工程师能专注于产品创新。",
      "translated_title": "在 Airbnb 构建下一代键值存储",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*sUS0d9nGKa-WQupVS8Wb4g.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*yjXZcYHPpQdl-peEhfEAmA.png",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*4Q-yjBQu8jwWSv0pkkNIHQ.jpeg",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=0de8465ba354",
          "alt": "",
          "title": "",
          "position": 4
        }
      ],
      "contentSource": "RSS",
      "content": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sUS0d9nGKa-WQupVS8Wb4g.jpeg\" /></figure><p>How we completely rearchitected Mussel, our storage engine for derived data, and lessons learned from the migration from Mussel V1 to V2.</p><p>By <a href=\"https://www.linkedin.com/in/shravangaonkar/\">Shravan Gaonkar</a>, <a href=\"https://www.linkedin.com/in/chandramoulir/\">Chandramouli Rangarajan</a>, <a href=\"https://www.linkedin.com/in/yanhan-zhang/\">Yanhan Zhang</a></p><p>How we completely rearchitected Mussel, our storage engine for derived data, and lessons learned from the migration from Mussel V1 to V2.</p><p>Airbnb’s core key-value store, internally known as Mussel, bridges offline and online workloads, providing highly scalable bulk load capabilities combined with single-digit millisecond reads.</p><p>Since first writing about Mussel in a 2022 <a href=\"https://medium.com/airbnb-engineering/mussel-airbnbs-key-value-store-for-derived-data-406b9fa1b296\">blog post</a>, we have completely deprecated the storage backend of the original system (what we now call Mussel v1) and have replaced it with a NewSQL backend which we are referring to as Mussel v2. Mussel v2 has been running successfully in production for a year, and we wanted to share why we undertook this rearchitecture, what the challenges were, and what benefits we got from it.</p><h3>Why rearchitect</h3><p>Mussel v1 reliably supported Airbnb for years, but new requirements — real-time fraud checks, instant personalization, dynamic pricing, and massive data — demand a platform that combines real-time streaming with bulk ingestion, all while being easy to manage.</p><h3>Key Challenges with v1</h3><p>Mussel v2 solves a number of issues with v1, delivering a scalable, cloud-native key-value store with predictable performance and minimal operational overhead.</p><ul><li><strong>Operational complexity:</strong> Scaling or replacing nodes required multi-step Chef scripts on EC2; v2 uses Kubernetes manifests and automated rollouts, reducing hours of manual work to minutes.</li><li><strong>Capacity &amp; hotspots:</strong> Static hash partitioning sometimes overloaded nodes, leading to latency spikes. V2’s dynamic range sharding and presplitting keep reads fast (p99 &lt; 25ms), even for 100TB+ tables.</li><li><strong>Consistency flexibility:</strong> v1 offered limited consistency control. v2 lets teams choose between immediate or eventual consistency based on their SLA needs.</li><li><strong>Cost &amp; Transparency:</strong> Resource usage in v1 was opaque. v2 adds namespace tenancy, quota enforcement, and dashboards, providing cost visibility and control.</li></ul><h3>New architecture</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yjXZcYHPpQdl-peEhfEAmA.png\" /></figure><p>Mussel v2 is a complete re-architecture addressing v1’s operational and scalability challenges. It’s designed to be automated, maintainable, and scalable, while ensuring feature parity and an easy migration for 100+ existing user cases.</p><h3>Dispatcher</h3><p>In Mussel v2, the Dispatcher is a stateless, horizontally-scalable Kubernetes service that replaces the tightly coupled, protocol-specific design of v1. It translates client API calls into backend queries/mutations, supports dual-write and shadow-read modes for migration, manages retries and rate limits, and integrates with Airbnb’s service mesh for security and service discovery.</p><p><strong>Reads</strong> are simplified: Each dataname maps to a logical table, enabling optimized point lookups, range/prefix queries, and stale reads from local replicas to reduce latency. Dynamic throttling and prioritization maintain performance under changing traffic.</p><p><strong>Writes</strong> are persisted in Kafka for durability first, with the Replayer and Write Dispatcher applying them in order to the backend. This event-driven model absorbs bursts, ensures consistency, and removes v1’s operational overhead. Kafka also underpins upgrades, bootstrapping, and migrations until CDC and snapshotting mature.</p><p>The architecture suits derived data and replay-heavy use cases today, with a long-term goal of shifting ingestion and replication fully to the distributed backend database to bring down latency and simplify operations.</p><p>Bulk load<strong><br></strong>Bulk load remains essential for moving large datasets from offline warehouses into Mussel for low-latency queries. v2 preserves v1 semantics, supporting both “merge” (add to existing tables) and “replace” (swap datasets) semantics.</p><p>To maintain a familiar interface, v2 keeps the existing Airflow-based onboarding and transforms warehouse data into a standardized format, uploading to S3 for ingestion. <a href=\"https://airbnb.io/projects/airflow/\">Airflow</a> is an open-source platform for authoring, scheduling, and monitoring data pipelines. Created at Airbnb, it lets users define workflows in code as directed acyclic graphs (DAGs), enabling quick iteration and easy orchestration of tasks for data engineers and scientists worldwide.</p><p>A stateless controller orchestrates jobs, while a distributed, stateful worker fleet (Kubernetes StatefulSets) performs parallel ingestion, loading records from S3 into tables. Optimizations — like deduplication for replace jobs, delta merges, and insert-on-duplicate-key-ignore — ensure high throughput and efficient writes at Airbnb scale.</p><h3>TTL</h3><p>Automated data expiration (TTL) can help support data governance goals and storage efficiency. In v1, expiration relied on the storage engine’s compaction cycle, which struggled at scale.</p><p>Mussel v2 introduces a topology-aware expiration service that shards data namespaces into range-based subtasks processed concurrently by multiple workers. Expired records are scanned and deleted in parallel, minimizing sweep time for large datasets. Subtasks are scheduled to limit impact on live queries, and write-heavy tables use max-version enforcement with targeted deletes to maintain performance and data hygiene.</p><p>These enhancements provide the same retention functionality as v1 but with far greater efficiency, transparency, and scalability, meeting Airbnb’s modern data platform demands and enabling future use cases.</p><h3>The migration process</h3><h3>Challenge</h3><p>Mussel stores vast amounts of data and serves thousands of tables across a wide array of Airbnb services, sustaining mission-critical read and write traffic at high scale. Given the criticality of Mussel to Airbnb’s online traffic, our migration goal was straightforward but challenging: Move all data and traffic from Mussel v1 to v2 with zero data loss and no impact on availability to our customers.</p><h3>Process</h3><p>We adopted a blue/green migration strategy, but with notable complexities. Mussel v1 didn’t provide table-level snapshots or CDC streams, which are standard in many datastores. To bridge this gap, we developed a custom migration pipeline capable of bootstrapping tables to v2, selected by usage patterns and risk profiles. Once bootstrapped, dual writes were enabled on a per-table basis to keep v2 in sync as the migration progressed.</p><p>The migration itself followed several distinct stages:</p><ul><li><strong>Blue Zone:</strong> All traffic initially flowed to v1 (“Blue”). This provided a stable baseline as we migrated data behind the scenes.</li><li><strong>Shadowing (Green):</strong> Once tables were bootstrapped, v2 (“Green”) began shadowing v1 — handling reads/writes in parallel, but only v1 responded. This allowed us to check v2’s correctness and performance without risk.</li><li><strong>Reverse:</strong> After building confidence, v2 took over active traffic while v1 remained on standby. We built automatic circuit breakers and fallback logic: If v2 showed elevated error rates or lagged behind v1, we could instantly return traffic to v1 or revert to shadowing.</li><li><strong>Cutover:</strong> When v2 passed all checks, we completed the cutover on a dataname-by-dataname basis, with Kafka serving as a robust intermediary for write reliability throughout.</li></ul><p>To further de-risk the process, migration was performed one table at a time. Every step was reversible and could be fine-tuned per table or group of tables based on their risk profile. This granular, staged approach allowed for rapid iteration, safe rollbacks, and continuous progress without impacting the business.</p><h3>Migration pipeline</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4Q-yjBQu8jwWSv0pkkNIHQ.jpeg\" /></figure><p>As described in our previous blog post, the v1 architecture uses Kafka as a replication log — data is first written to Kafka, then consumed by the v1 backend. During the data migration to v2, we leveraged the same Kafka stream to maintain eventual consistency between v1 and v2.</p><p>To migrate any given table from v1 to v2, we built a custom pipeline consisting of the following steps:</p><ol><li><strong>Source data sampling</strong>: We download backup data from v1, extract the relevant tables, and sample the data to understand its distribution.</li><li><strong>Create pre-split table on v2</strong>: Based on the sampling results, we create a corresponding v2 table with a pre-defined shard layout to minimize data reshuffling during migration.</li><li><strong>Bootstrap</strong>: This is the most time-consuming step, taking hours or even days depending on table size. To bootstrap efficiently, we use Kubernetes StatefulSets to persist local state and periodically checkpoint progress.</li><li><strong>Checksum verification</strong>: We verify that all data from the v1 backup has been correctly ingested into v2.</li><li><strong>Catch-up</strong>: We apply any lagging messages that accumulated in Kafka during the bootstrap phase.</li><li><strong>Dual writes</strong>: At this stage, both v1 and v2 consume from the same Kafka topic. We ensure eventual consistency between the two, with replication lag typically within tens of milliseconds.</li></ol><p>Once data migration is complete and we enter dual write mode, we can begin the read traffic migration phase. During this phase, our dispatcher can be dynamically configured to serve read requests for specific tables from v1, while sending shadow requests to v2 for consistency checks. We then gradually shift to serving reads from v2, accompanied by reverse shadow requests to v1 for consistency checks, which also enables quick fallback to v1 responses if v2 becomes unstable. Eventually, we fully transition to serving all read traffic from v2.</p><h3>Lessons learned</h3><p>Several key insights emerged from this migration:</p><ul><li><strong>Consistency complexity:</strong> Migrating from an eventually consistent (v1) to a strongly consistent (v2) backend introduced new challenges, particularly around write conflicts. Addressing these required features like write deduplication, hotkey blocking, and lazy write repair — sometimes trading off storage cost or read performance.</li><li><strong>Presplitting is critical:</strong> As we shifted from hash-based (v1) to range-based partitioning (v2), inserting large consecutive data could cause hotspots and disrupt our v2 backend. To prevent this, we needed to accurately sample the v1 data and presplit it into multiple shards based on v2’s topology, ensuring balanced ingestion traffic across backend nodes during data migration.</li><li><strong>Query model adjustments:</strong> v2 doesn’t push down range filters as effectively, requiring us to implement client-side pagination for prefix and range queries.</li><li><strong>Freshness vs. cost:</strong> Different use cases required different tradeoffs. Some prioritized data freshness and used primary replicas for the latest reads, while others leveraged secondary replicas to balance staleness with cost and performance.</li><li><strong>Kafka’s role:</strong> Kafka’s proven stable p99 millisecond latency made it an invaluable part of our migration process.</li><li><strong>Building in flexibility:</strong> Customer retries and routine bulk jobs provided a safety net for the rare inconsistencies, and our migration design allowed for per-table stage assignments and instant reversibility — key for managing risk at scale.</li></ul><p>As a result, we migrated more than a petabyte of data across thousands of tables with zero downtime or data loss, thanks to a blue/green rollout, dual-write pipeline, and automated fallbacks — so the product teams could keep shipping features while the engine under them evolved.</p><h3>Conclusion and next steps</h3><p>What sets Mussel v2 apart is the way it fuses capabilities that are usually confined to separate, specialized systems. In our deployment of Mussel V2, we observe that this system can simultaneously</p><ol><li>ingest tens of terabytes in bulk data upload,</li><li>sustain 100 k+ streaming writes per second in the same cluster, and</li><li>keep p99 reads under 25 ms</li></ol><p>— all while giving callers a simple dial to toggle stale reads on a per-namespace basis. By pairing a NewSQL backend with a Kubernetes-native control plane, Mussel v2 delivers the elasticity of object storage, the responsiveness of a low-latency cache, and the operability of modern service meshes — rolled into one platform. Engineers no longer need to stitch together a cache, a queue, and a datastore to hit their SLAs; Mussel provides those guarantees out of the box, letting teams focus on product innovation instead of data plumbing.</p><p>Looking ahead, we’ll be sharing deeper insights into how we’re evolving quality of service (QoS) management within Mussel, now orchestrated cleanly from the Dispatcher layer. We’ll also describe our journey in optimizing bulk loading at scale — unlocking new performance and reliability wins for complex data pipelines. If you’re passionate about building large-scale distributed systems and want to help shape the future of data infrastructure at Airbnb, take a look at our <a href=\"https://careers.airbnb.com/\">Careers page</a> — we’re always looking for talented engineers to join us on this mission.</p><h3>References</h3><ol><li><a href=\"https://medium.com/airbnb-engineering/mussel-airbnbs-key-value-store-for-derived-data-406b9fa1b296\">https://medium.com/airbnb-engineering/mussel-airbnbs-key-value-store-for-derived-data-406b9fa1b296</a></li></ol><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=0de8465ba354\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/building-a-next-generation-key-value-store-at-airbnb-0de8465ba354\">Building a Next-Generation Key-Value Store at Airbnb</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "Viaduct，五年回顾：数据导向型服务网格的现代化 (原标题: Viaduct, Five Years On: Modernizing the Data-Oriented Service Mesh)",
      "link": "https://medium.com/airbnb-engineering/viaduct-five-years-on-modernizing-the-data-oriented-service-mesh-e66397c9e9a9?source=rss----53c7c27702d5---4",
      "pubDate": "Wed, 17 Sep 2025 17:01:58 GMT",
      "isoDate": "2025-09-17T17:01:58.000Z",
      "creator": "Adam Miskiewicz",
      "summary": "![图片 1](https://cdn-images-1.medium.com/max/1024/1*q_owFEOLfQlioFXHP7UqBA.avif)\n\n本文回顾了Airbnb数据导向型服务网格Viaduct五年来的发展，并宣布其已开源。Viaduct自2020年以来取得了显著增长，流量增长了八倍，托管代码的团队数量翻倍至130多个，代码库规模扩大了两倍多，同时保持了运营开销不变、事故时间减半，并使成本与QPS线性增长。\n\n## Viaduct 的核心原则（保持不变）\n\nViaduct自成立以来一直遵循三个核心原则：\n\n*   **中心化 Schema：** Viaduct提供一个单一、集成的Schema，连接公司所有领域。尽管Schema由多个团队分散开发，但它是一个高度互联的图。超过75%的Viaduct请求是内部请求，因为它已成为连接开发者与所有数据和能力的“一站式”数据网格。\n*   **托管业务逻辑：** 团队被鼓励直接在Viaduct中托管业务逻辑，这与GraphQL服务器作为微服务薄层的常见做法不同。Viaduct提供了一个无服务器平台，让开发者专注于业务逻辑编写，而非运维问题。\n*   **可重入性（Re-entrancy）：** Viaduct上托管的逻辑可以通过发布GraphQL片段和查询来与其他逻辑组合。这对于维护大型代码库的模块化和避免传统单体架构的风险至关重要。\n\n## Viaduct 的演变：“Viaduct Modern”现代化计划\n\nViaduct在大部分历史中是自下而上、响应开发者需求演进的，这导致了多种实现方式、混乱的开发者体验和架构完整性不足。为解决这些问题，Airbnb启动了“Viaduct Modern”计划，对面向开发者的API和执行引擎进行了彻底改造。\n\n### 租户 API 简化\n\n*   **旧模型：** 编程模型复杂，开发者面临多种实现功能的机制（见下图）。\n    ![图片 2](https://cdn-images-1.medium.com/max/1024/1*0Gujn6vAspuKh3ZuPjlK-g.png)\n    *Viaduct 原始的复杂编程模型*\n*   **新模型：** 显著简化，只提供两种机制：节点解析器（node resolvers）和字段解析器（field resolvers）。选择由Schema本身驱动，而非基于功能行为的随意区分（见下图）。\n    ![图片 3](https://cdn-images-1.medium.com/max/1024/1*xuL1H_ylQR5PU2eh2JuXEA.png)\n    *Viaduct Modern 的简化模型*\n*   API在两种解析器类型之间尽可能统一，提升了开发体验。\n\n### 租户模块化\n\n*   通过模块和可重入性实现强大的抽象边界。\n*   从模糊的代码组织约定演变为正式的“租户模块”概念：一个Schema单元及其实现代码，由单个团队拥有。\n*   模块之间通过GraphQL片段和查询进行组合，而非直接的代码依赖。\n*   **示例：** “核心用户”团队定义`User`类型，而“消息”团队可以通过`extend type User { displayName: String @resolver}`扩展`User`类型，并声明其`displayName`字段的解析器，无需了解`firstName`和`lastName`字段的来源。\n\n### 框架模块化\n\n*   目标是使框架本身更具模块化，以便更快地改进性能和可靠性，同时减少对应用代码的修改。\n*   Viaduct由GraphQL执行引擎、租户API和托管应用代码三层组成。\n*   **新设计：** 在这些层之间创建了强大的抽象边界（见下图）。\n    ![图片 4](https://cdn-images-1.medium.com/max/1024/1*qvOOmI-Hs7-PMa52kSACqQ.png)\n    *Viaduct Modern 的模块化设计*\n*   最显著的变化是引擎与面向开发者的租户API之间的边界。引擎API的核心是GraphQL值的动态类型表示，而租户API是静态类型的（通过生成的Kotlin类）。生成的类型是动态表示的薄封装。这种分离允许引擎和租户API独立演进。\n\n### 平滑迁移\n\n*   为实现渐进式迁移，新的Modern API和现有的Classic API在新引擎之上并行运行。\n*   团队可以立即获得引擎带来的性能/成本优势，并逐步采用Modern API的改进。\n*   同时构建两个API也促使引擎API设计更加通用和清晰。\n\n## 其他改进\n\n自2020年以来，Viaduct还进行了其他改进：\n\n*   **可观测性：** 新架构清晰的边界使得所有权和归因更加精确。\n*   **构建时间：** 采用Schema优先、直接生成字节码等方式优化构建时间，Viaduct Modern的模块化也有助于控制构建时间。\n*   **调度器：** 作为水平扩展的Kubernetes应用运行，使用调度器将操作路由到部署分片，实现混洗分片，并简化离线/在线流量隔离（目前不开源）。\n\n## Viaduct 开源\n\nAirbnb从“Viaduct Modern”项目启动之初就计划将其开源，旨在提升软件质量、回馈开源社区，并希望通过更广泛社区的贡献来改进Viaduct。目前，新引擎已全面投入生产，而新的租户API仍处于Alpha阶段。Airbnb鼓励社区参与，共同塑造API。\n\n## Viaduct 适用性\n\nViaduct已被证明可以扩展到大规模图，同时也适合作为初学者友好的GraphQL服务器。它从一开始就强调开发者体验，并提供了一个优秀的GraphQL解决方案构建环境。",
      "shortSummary": "Airbnb宣布将其数据导向型服务网格Viaduct开源。过去五年，Viaduct在Airbnb内部实现了显著增长，流量增长八倍，团队数量翻倍。为解决早期演进中的复杂性，Viaduct推出了“Viaduct Modern”计划，彻底改造了开发者API和执行引擎，简化了编程模型，增强了模块化，并实现了平滑迁移。Viaduct基于中心化Schema、托管业务逻辑和可重入性三大原则，旨在提供强大的、开发者友好的GraphQL解决方案。开源旨在提升软件质量并吸纳社区贡献。",
      "translated_title": "Viaduct，五年回顾：数据导向型服务网格的现代化",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*q_owFEOLfQlioFXHP7UqBA.avif",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*0Gujn6vAspuKh3ZuPjlK-g.png",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*xuL1H_ylQR5PU2eh2JuXEA.png",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*qvOOmI-Hs7-PMa52kSACqQ.png",
          "alt": "",
          "title": "",
          "position": 4
        },
        {
          "url": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e66397c9e9a9",
          "alt": "",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "RSS",
      "content": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*q_owFEOLfQlioFXHP7UqBA.avif\" /></figure><h4>A more powerful engine and a simpler API for our data-oriented mesh</h4><p>By: Adam Miskiewicz, Raymie Stata</p><p>In November 2020 we <a href=\"https://medium.com/airbnb-engineering/taming-service-oriented-architecture-using-a-data-oriented-service-mesh-da771a841344\">published</a> a post about Viaduct, our data-oriented service mesh. Today, we’re excited to announce Viaduct is available as open-source software (OSS) at <a href=\"https://github.com/airbnb/viaduct\">https://github.com/airbnb/viaduct</a>.</p><p>Before we talk about OSS, here’s a quick update on Viaduct’s adoption and evolution at Airbnb over the last five years. Since 2020, traffic through Viaduct has grown by a factor of eight. The number of teams hosting code in Viaduct has doubled to 130+ (with hundreds of weekly active developers). The codebase hosted by Viaduct has tripled to over <strong>1.5M</strong> lines (plus about the same in test code). We’ve achieved all this while keeping operational overhead constant, halving incident-minutes, and keeping costs growing linearly with QPS.</p><h3>What’s the same?</h3><p>Three principles have guided Viaduct since day one and still anchor the project: a <strong>central schema</strong> served by <strong>hosted business logic</strong> via a <strong>re-entrant</strong> API.</p><p><strong>Central schema <br></strong>Viaduct serves our central schema: a single, integrated schema connecting all of our domains across the company. While that schema is developed in a <em>decentralized</em> manner by many teams, it’s one, highly connected graph. Over 75% of Viaduct requests are internal because Viaduct has become a “one‑stop” data-oriented mesh connecting developers to all of our data and capabilities.</p><p><strong>Hosted business logic <br></strong>From the beginning, we’ve encouraged teams to host their business logic directly in Viaduct. This runs counter to what many consider to be best practices in GraphQL, which is that GraphQL servers should be a thin layer over microservices that host the real business logic. We’ve created a serverless platform for hosting business logic, allowing our developers to focus on writing business logic rather than on operational issues. As noted by Katie, an engineer on our Media team:</p><blockquote>“As we migrate our media APIs into Viaduct, we’re looking forward to retiring a handful of standalone services. Centralizing everything means less overhead, fewer moving parts, and a much smoother developer experience!”</blockquote><p><strong>Re-entrancy</strong></p><p>At the heart of our developer experience is what we call <em>re-entrancy</em>: Logic hosted on Viaduct composes with other logic hosted on Viaduct by issuing GraphQL fragments and queries. Re-entrancy has been crucial for maintaining modularity in a large codebase and avoiding classic monolith hazards.</p><h3>What’s changed?</h3><p>For most of Viaduct’s history, evolution has been bottom-up and reactive to immediate developer needs. We added capabilities incrementally, which helped us move fast, but also produced multiple ways to accomplish similar tasks (some well‑supported, others not) and created a confusing developer experience, especially for new teams. Another side-effect of this reactive approach has been a lack of architectural integrity. The interfaces between the layers of Viaduct, described in more detail below, are loose and often arbitrary, and the abstraction boundary between the Viaduct framework and the code that it hosts is weak. As a result, it has become increasingly difficult to make changes to Viaduct without disrupting our customer base.</p><p>To address these issues, over a year ago we launched a major initiative we call <strong>“Viaduct Modern”</strong>, a ground-up overhaul of both the developer-facing API and the execution engine.</p><h3>Tenant API</h3><p>One driving principle of Viaduct Modern has been to simplify and rationalize the API we provide to developers in Viaduct, which we call the <strong>“Tenant API”</strong>. The following diagram captures the decision tree one faced when deciding how to implement functionality in the old API:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0Gujn6vAspuKh3ZuPjlK-g.png\" /><figcaption>Viaduct’s original complex programming model</figcaption></figure><p>Each oval in this diagram represents a different mechanism for writing code. In contrast, the new API offers just two mechanisms: node resolvers and field resolvers.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xuL1H_ylQR5PU2eh2JuXEA.png\" /><figcaption>Viaduct Modern’s simpler model</figcaption></figure><p>The choice between the two is driven by the schema itself, not ad‑hoc distinctions based on a feature’s behavior. We unified the APIs for both resolver types wherever possible, which simplifies dev experience. After four years evolving the API in a use‑case‑driven manner, we distilled the best ideas into a single simple surface (and left the mistakes behind).</p><h3>Tenant modularity</h3><p>Strong abstraction boundaries are essential in any large codebase. Microservices achieve this via service definitions and RPC API boundaries; Viaduct achieves it via <strong>modules</strong> plus <strong>re‑entrancy</strong>.</p><p>Modularity in the central schema and hosted code has evolved. Initially, all we had was a vague set of conventions for organizing code into team-owned directories. There was no formal concept of a module, and schema and code were kept in separate source directories with unenforced naming conventions to connect the two. Over time, we evolved that into a more formal abstraction we call a “tenant module.” A tenant module is a unit of schema together with the code that implements that schema, and crucially, is owned by a single team. While we encourage rich graph‑level connections across modules, we <strong>discourage direct code dependencies</strong> between modules. Instead, modules compose via GraphQL fragments and queries. Viaduct Modern extends and simplifies these re‑entrancy tools.</p><p>Let’s look at an example. Imagine two teams, a “Core User” team that owns and manages the basic profile data of users, and then a “Messaging” team that operates a messaging platform for users to interact with each other. In our example, the Messaging team would like to define a <em>displayName</em> field on a <em>User</em>, which is used in their user interface. This would look something like this:</p><p><strong>Core User team</strong></p><pre>type User implements Node {<br>  id: ID!<br>  firstName: String<br>  lastName: String<br>  … <br>}</pre><pre>class UserResolver : Nodes.User() {<br>    @Inject<br>    val userClient: UserServiceClient<br><br>    @Inject<br>    val userResponseMapper: UserResponseMapper<br><br>    override suspend fun resolve(ctx.Context): User {<br>        val r = userClient.fetch(ctx.id)<br>        return userResponseMapper(r)<br>    } <br>}</pre><p>This is the base definition of the <em>User</em> type that lives in the Core User team’s module. This base definition defines the first- and last-name fields (among many others), and it’s the Core User team’s responsibility to materialize those fields.</p><p><strong>Messaging team</strong></p><pre>extend type User {<br>  displayName: String @resolver<br>}</pre><pre>@Resolver(&quot;firstName lastName&quot;)<br>class DisplayNameResolver : UserResolvers.DisplayName() {<br>    override suspend fun resolve(ctx: Context): String {<br>        val f = ctx.objectValue.getFirstName()<br>        val l = ctx.objectValue.getLastName()<br>        return &quot;$f ${l.first()}.&quot;<br>    }<br>}</pre><p>The Messaging team can then extend the <em>User </em>type with the display name field, and also indicates that they intend to provide a resolver for it. The code has an <em>@Resolver </em>annotation that indicates which fields of the <em>User</em> object it needs to implement the <em>displayName</em> field. The Messaging team doesn’t need to understand which module these fields come from, and their code doesn’t depend on code from the Core User team. Instead, the Messaging team states their data needs in a declarative fashion.</p><h3>Framework modularity</h3><p>A major goal of Viaduct Modern has been to make the framework itself more modular. We want to enable faster improvements to Viaduct — especially regarding performance and reliability — without extensive changes to application code. Viaduct is composed of three main layers: the GraphQL execution engine, the tenant API, and the hosted application code. While these layers made sense, the interfaces between them were weak, making Viaduct difficult to update. The new design is focused on creating strong abstraction boundaries between these layers to improve flexibility and maintainability:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qvOOmI-Hs7-PMa52kSACqQ.png\" /><figcaption>Viaduct Modern’s modular design</figcaption></figure><p>The most significant change is the boundary between the <strong>engine</strong> and the developer-facing <strong>tenant API</strong>. In the previous system, that boundary hardly existed. Viaduct Modern defines a strong <strong>engine API</strong> whose core is a <strong>dynamically‑typed</strong> representation of GraphQL values (input and output objects as simple maps from field name → value). The tenant API, by contrast, is <strong>statically typed</strong>: we generate Kotlin classes for every GraphQL type in the central schema. In the new architecture, generated types are thin wrappers over the dynamic representation. The tenant API forms the bridge between the engine’s untyped world and tenants’ typed world.</p><p>This separation lets us evolve the engine in relative isolation (to improve latency, throughput, and reliability) and evolve the tenant API in relative isolation (to improve dev experience). Large changes will still cross the boundary, but as Viaduct Modern stabilizes, that should be rare.</p><h3>Migration without a “big bang”</h3><p>Viaduct Modern would be a non‑starter if it required a step‑function migration of a million+ lines of code. To enable gradual migration, we’re shipping <strong>two tenant APIs</strong> side‑by‑side — the new <strong>Modern</strong> API and the existing <strong>Classic</strong> API — both on top of the new engine. This lets teams realize performance/cost wins from the engine immediately, while adopting the ergonomic wins of the Modern API over time.</p><p>Shipping two APIs has also improved the engine API design: building two tenant runtimes simultaneously forced us to keep the engine’s concerns clean and general. Over time, we expect to build additional tenant APIs on the engine (e.g., <strong>TypeScript</strong>).</p><h3>Other improvements</h3><p>Viaduct has seen a lot of other improvements since 2020. The story is too long to be told in this post, but to list some of the highlights:</p><ul><li><strong>Observability.</strong> Hosting software from 100+ teams means our framework has to make ownership and attribution crystal clear. In the old system, there is no clear dividing line between tenant code and framework code, so our instrumentation includes a bit of guesswork in its attribution to parties. The new architecture draws a crisp boundary, which enables deeper, more accurate attribution.</li><li><strong>Build time.</strong> We’re schema‑first: Developers write schema as source, and Viaduct generates code to provide a strongly typed, ergonomic surface. At our scale, build time is a constant battle. Over the years we’ve made numerous investments to improve build time, including direct-to-bytecode code generation that bypasses lengthy compilation of generated code. We anticipate that the improved modularity in Viaduct Modern will keep build times in check as the codebase grows.</li><li><strong>Dispatcher.</strong> We run Viaduct as a horizontally-scaled Kubernetes app. To mitigate blast radius, we use a dispatcher that routes operations to deployment shards, applying <a href=\"https://aws.amazon.com/blogs/architecture/shuffle-sharding-massive-and-magical-fault-isolation/\">shuffle sharding</a>. It also simplifies isolating offline vs. online traffic and hosting experimental framework builds. (We don’t currently plan to open‑source the dispatcher as it’s tightly tied to Airbnb’s serving framework, but we may talk more about our strategies here in the future!)</li></ul><h3>Open-sourcing Viaduct</h3><p>Our intent from the start of Viaduct Modern was to open‑source it. We believe that setting out to build software for the world will result in higher quality software for ourselves. Also, as a significant consumer of open-source software, we feel an obligation to give back. Last but not least, while we’ve learned a lot by working with Airbnb developers, we think Viaduct can be massively improved by incorporating ideas and contributions from the wider community.</p><p>We’re open‑sourcing at an interesting moment. Viaduct is <strong>mature and battle‑tested</strong> <em>and also</em> <strong>new and evolving</strong>. The new engine is now in full production, while the new tenant API is still in alpha. We’ve implemented a small but robust kernel of the new API and are using it in a few (demanding) use cases. We’re investing heavily in the Modern API and migrating our own workloads to it, but it’s early days. By open‑sourcing early, we hope to grow a community who will shape the API with us together.</p><h3>Is Viaduct for you?</h3><p>Although our use case proves Viaduct can scale to massive graphs, we think it’s also a great GraphQL server when you’re just starting. We’ve emphasized developer ergonomics from day one, and we believe Viaduct provides one of the best environments for building GraphQL solutions. Whether you’re operating a super-graph today or just kicking the tires, we’d love for you to try Viaduct Modern and tell us what works — and what doesn’t.</p><p>—</p><p>Thanks to the entire Viaduct team, and especially Aileen Chen and Raymie Stata, for the tireless work on Viaduct Modern.</p><p><em>All product names, logos, and brands are property of their respective owners. All company, product and service names used in this website are for identification purposes only. Use of these names, logos, and brands does not imply endorsement.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e66397c9e9a9\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/viaduct-five-years-on-modernizing-the-data-oriented-service-mesh-e66397c9e9a9\">Viaduct, Five Years On: Modernizing the Data-Oriented Service Mesh</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "使用数据导向的服务网格驯服面向服务的架构 (原标题: Taming Service-Oriented Architecture Using A Data-Oriented Service Mesh)",
      "link": "https://medium.com/airbnb-engineering/taming-service-oriented-architecture-using-a-data-oriented-service-mesh-da771a841344?source=rss----53c7c27702d5---4",
      "pubDate": "Tue, 16 Sep 2025 18:37:58 GMT",
      "isoDate": "2025-09-16T18:37:58.000Z",
      "creator": "Adam Miskiewicz",
      "summary": "# 使用数据导向的服务网格驯服面向服务的架构：Airbnb 的 Viaduct\n\nAirbnb 推出了一款名为 Viaduct 的数据导向服务网格，旨在显著提升其基于微服务的面向服务架构（SOA）的模块化水平。本文阐述了 Viaduct 的设计理念和工作原理。\n\n## 大规模 SOA 依赖图的挑战\n现代应用程序通常包含数千甚至数万个微服务，它们以不受约束的方式相互连接，导致复杂的依赖图。这种“意大利面条式 SOA”使得系统修改日益困难。为了管理庞大的微服务数量，需要新的组织原则和技术措施。Airbnb 的研究发现，数据导向的服务网格能够为 SOA 带来新的模块化水平。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*KUevf-1aGcLQyit3wzmh8w.jpeg)\n\n*图示：Airbnb 工程师 Raymie Stata, Arun Vijayvergiya, Adam Miskiewicz 介绍 Viaduct*\n\n![图片 2](https://cdn-images-1.medium.com/max/896/1*y2E1EmsS3paNhoChYGnJIw.png)\n\n*图示：一个典型的微服务依赖图，展示了复杂的服务间关系*\n\n## 过程导向与数据导向设计\n软件工程中模块化组织程序并非新问题：\n*   **过程导向设计（1970年代前）**：以过程和模块为中心，模块通过公共 API 暴露功能，隐藏内部实现（如 Pascal 和 C）。\n*   **数据导向设计（1980年代后）**：以数据为中心，模块定义对象类，通过公共方法 API 访问封装的内部数据（如 Simula 和 Clu）。\n\n当前的 SOA 及其微服务本质上是过程导向的，类似于1970年代的模块。Airbnb 认为 SOA 需要向数据导向设计演进，而服务网格从过程导向转向数据导向是实现这一目标的关键。\n\n## Viaduct：数据导向的服务网格\n现代可扩展 SOA 应用的核心是服务网格（如 Istio, Linkerd），负责将服务调用路由到相应的微服务实例。然而，行业标准的服务网格通常只关注远程过程调用，对构成应用架构的数据一无所知。Viaduct 的愿景是用数据导向的服务网格取代这些过程导向的服务网格。\n\nAirbnb 使用 GraphQL 构建了 Viaduct，一个数据导向的服务网格。Viaduct 服务网格通过 GraphQL schema 定义，包含：\n*   **类型（Types）和接口（Interfaces）**：描述服务网格内管理的数据。\n*   **查询（Queries）和订阅（Subscriptions）**：提供访问数据的方式，这些方式从提供数据的服务入口点中抽象出来。\n*   **变更（Mutations）**：提供更新数据的方式，同样从服务入口点中抽象出来。\n\nSchema 中的类型和接口定义了服务网格中所有数据的一个统一图。例如，一个电商公司的 schema 可能定义 `productById(id: ID)` 字段返回 `Product` 类型结果，数据消费者可以通过一个查询从产品导航到制造商、评论甚至评论作者，而无需了解底层数据来自哪些微服务。Viaduct 负责管理服务依赖，将其从数据消费者中抽象出来。\n\n## 以 Schema 为中心\nViaduct 将 schema 视为一个单一的工件，并实现了多项原语，允许团队在保持统一 schema 的同时高效协作。随着 Viaduct 逐渐取代底层的过程导向服务网格，其 schema 将更完整地捕捉应用管理的数据。Airbnb 利用这个“中心 schema”来定义部分微服务的 API，这些微服务的 GraphQL schema 是中心 schema 的子集。未来，计划进一步利用中心 schema 来定义数据库中存储的数据的 schema。\n\n这种以中心 schema 定义 API 和数据库 schema 的方法，将解决大规模 SOA 应用面临的一大挑战：**数据敏捷性**。目前，数据库 schema 的变更往往需要手动反映在两层、三层甚至更多层微服务的 API 中，才能暴露给客户端代码，这可能需要数周的多团队协调。通过从单一的中心 schema 派生服务 API 和数据库 schema，数据库 schema 的变更可以通过一次更新传播到客户端代码。\n\n## 无服务器化（Serverless）\n在大型 SOA 应用中，存在许多无状态的“派生数据服务”和“前端后端服务”，它们从底层服务获取原始数据并转换为适合客户端展示的数据。这种无状态逻辑非常适合无服务器计算模型，它消除了微服务的操作开销，将逻辑托管在“云函数”平台中。\n\nViaduct 拥有一种机制，可以使用无服务器云函数计算“派生字段”，这些函数在图之上运行，无需了解底层服务。这使得转换逻辑可以从服务网格中移出，放入无状态容器，从而保持图的整洁，并减少所需服务的数量和复杂性。\n\n## 结论\nViaduct 基于 `graphql-java` 构建，支持通过 GraphQL 选择集进行细粒度字段选择。它采用现代数据加载技术，实现短路和软依赖等可靠性技术，并包含请求内缓存。Viaduct 提供数据可观察性，允许在字段级别理解哪些服务消费了哪些数据。作为一个 GraphQL 接口，Viaduct 利用了庞大的开源工具生态系统，包括实时 IDE、模拟服务器和 schema 可视化工具。\n\nViaduct 已在 Airbnb 生产环境中运行一年多，从少量核心实体开始，现已发展到包含80个核心实体，能够支持 Airbnb 75% 的现代 API 流量。",
      "shortSummary": "Airbnb 推出了 Viaduct，一个基于 GraphQL 的数据导向服务网格，旨在解决大规模面向服务架构（SOA）中微服务依赖图复杂性问题。Viaduct 将服务网格从传统的过程导向转变为数据导向，通过统一的 GraphQL schema 抽象数据访问和底层服务依赖。这显著提升了模块化，简化了数据敏捷性，并支持无服务器函数处理派生数据。Viaduct 已在 Airbnb 生产环境中运行一年多，有效管理了75%的现代 API 流量。",
      "translated_title": "使用数据导向的服务网格驯服面向服务的架构",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*KUevf-1aGcLQyit3wzmh8w.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/896/1*y2E1EmsS3paNhoChYGnJIw.png",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=da771a841344",
          "alt": "",
          "title": "",
          "position": 3
        }
      ],
      "contentSource": "RSS",
      "content": "<p>Introducing Viaduct, Airbnb’s data-oriented service mesh</p><p>By: Raymie Stata, Arun Vijayvergiya, Adam Miskiewicz</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*KUevf-1aGcLQyit3wzmh8w.jpeg\" /></figure><p>At Hasura’s <a href=\"https://hasura.io/enterprisegraphql/\">Enterprise GraphQL Conf</a> on October 22, we presented Viaduct, what we’re calling a <em>data-oriented service mesh </em>that we believe will bring a step function improvement in the modularity of our microservices-based Service-Oriented Architecture (SOA). In this blog post, we describe the philosophy behind Viaduct and provide a rough sketch of how it works. Please <a href=\"https://www.youtube.com/watch?v=xxk9MWCk7cM\">watch the presentation</a> for a more detailed look.</p><h3>Massive SOA Dependency Graphs</h3><p>For a while, <strong>S</strong>ervice-<strong>O</strong>riented <strong>A</strong>rchitectures have been moving towards ever larger numbers of small microservices. Modern applications can consist of thousands to tens of thousands of microservices connected in unconstrained ways. As a result, it’s not uncommon to see dependency graphs like the following:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/1*y2E1EmsS3paNhoChYGnJIw.png\" /></figure><p>This particular dependency graph happens to be from Airbnb, but it’s not uncommon. <a href=\"https://twitter.com/werner/status/741673514567143424\">Amazon</a>, <a href=\"https://medium.com/refraction-tech-everything/how-netflix-works-the-hugely-simplified-complex-stuff-that-happens-every-time-you-hit-play-3a40c9be254b\">Netflix</a>, and <a href=\"https://eng.uber.com/microservice-architecture/\">Uber</a> are examples of those that shared similarly tangled dependency graphs.</p><p>These dependency graphs are reminiscent of <a href=\"https://en.wikipedia.org/wiki/Spaghetti_code\">spaghetti code</a>, just at the microservices level. Similar to how spaghetti code becomes harder and harder to modify over time, so does spaghetti SOA. To help manage the larger number of services inherent in a microservices-based architecture, we need organizing principles as well as technical measures to implement those principles. At Airbnb, we undertook an effort to find such principles and measures. Our investigations led us to the concept of a <em>data-oriented service mesh</em>,<em> </em>which we believe brings a new level of modularity to SOA.</p><h3>Procedure- vs Data-Oriented Design</h3><p>Organizing large programs into modular units is not a new problem in software engineering. Up until the 1970s, the main paradigm of software organization focused on grouping code into procedures and procedures into modules. In this approach, modules publish a public API to be used by code outside of the module; behind this public API, modules hide their internal, helper procedures and other implementation details. Languages such as Pascal and C are based on this paradigm.</p><p>Starting in the ’80s, the paradigm shifted to organizing software primarily around data, not procedures. In this approach, modules define classes of objects that encapsulate an internal representation of an object accessed via a public API of methods<em> </em>on the object. Languages such as Simula and Clu pioneered this form of organization.</p><p>SOA is a step back to more procedure-oriented designs. Today’s microservice is a collection of procedural endpoints — a classic, 1970s-style module. We believe that SOA needs to evolve to support data-oriented design, and that this evolution can be enabled by transitioning our service mesh from a procedural orientation to a data orientation.</p><h3>Viaduct: A Data-Oriented Service Mesh</h3><p>Central to modern, scalable SOA applications is a <em>service mesh</em> (e.g., <a href=\"https://istio.io/\">Istio</a>, <a href=\"https://linkerd.io/\">Linkerd</a>), which routes service invocations to instances of microservices that can handle them. The current industry standard for service meshes is to organize exclusively around remote procedure invocations without knowing anything about the data that makes up the application architecture. Our vision is to replace these procedure-oriented service meshes with service meshes organized around <em>data.</em></p><p>At Airbnb, we are using <a href=\"https://graphql.org/\">GraphQL</a>™️ to build a data-oriented service mesh called <em>Viaduct.</em> A Viaduct service mesh is defined in terms of a GraphQL schema consisting of:</p><ul><li><em>Types</em> (and <em>interfaces</em>) describing data managed within your service mesh</li><li><em>Queries</em> (and <em>subscriptions</em>) providing means to access that data, which is abstracted from the service entry points that provide the data</li><li><em>Mutations </em>providing ways to update data, again abstracted from service entry points</li></ul><p>The types (and interfaces) in the schema define a single graph across all of the data managed within the service mesh. For example, at an eCommerce company, a service mesh’s schema may define a field productById(id: ID) that returns results of type Product. From this starting point, a single query allows a data consumer to navigate to information about the product’s manufacturer, e.g., productById { manufacturer }; reviews of the product, e.g. productById { reviews }; and even the authors of those reviews, e.g., productById { reviews { author } }.</p><p>The data elements requested by such a query may come from many different microservices. In a procedure-oriented service mesh, the data consumer would need to take these services as explicit dependencies. In our data-oriented service mesh, it is the service mesh, i.e., Viaduct, not the data consumer, that knows which services provide which data element. Viaduct abstracts away the service dependencies from any single consumer.</p><h3>Putting Schema at the Center</h3><p>In our talk we discuss how, unlike other distributed GraphQL systems like <a href=\"https://graphql-modules.com/\">GraphQL Modules</a> or <a href=\"https://www.apollographql.com/docs/federation/\">Apollo Federation</a>, Viaduct deals with the schema as a single artifact and has implemented several primitives that allow us to keep a unified schema while still allowing for many teams to collaborate on that schema productively. As Viaduct replaces more and more of our underlying procedure-oriented service mesh, its schema captures the data managed by our application more and more completely. We have taken advantage of this “central schema,” as we call it, as a place to define the APIs of some of our microservices. In particular, we have started using GraphQL for the API of some microservices. For these microservices, their GraphQL schemas are defined as a subset of the central schema. In the future, we want to take this idea further, using the central schema to define the schema of data stored in our database.</p><p>Among other things, using the central schema to define our APIs and database schemas will solve one of the bigger challenges of large-scale SOA applications: data agility. In today’s SOA applications, a change to a database schema often needs to be manually reflected in the APIs of two, three, and sometimes even more layers of microservices before it can be exposed to client code. Such changes can require weeks of coordinating among multiple teams. By deriving service APIs and database schemas from a single, central schema, a database schema change like this can be propagated to client code with a single update.</p><h3>Going Serverless</h3><p>Often in large SOA applications, there are many stateless “derived-data” services and “backend-for-frontend” services that take raw data from lower-level services and transform it into data that’s more appropriate for presentation in clients. Stateless logic like this is a good fit for the serverless computing model, which eliminates the operational overhead of microservices altogether and instead hosts logic in a “cloud functions” fabric.</p><p>Viaduct has a mechanism for computing what we call “derived fields” using serverless cloud functions that operate on top of<em> </em>the graph without knowledge of the underlying services. These functions allow us to move transformational logic out of the service mesh and into stateless containers, keeping our graph clean and reducing the number and complexity of services we need.</p><h3>Conclusion</h3><p>Viaduct is built on <a href=\"https://www.graphql-java.com/\">graphql-java</a> and supports fine-grained field selection via GraphQL selection sets. It uses modern data-loading techniques, employs reliability techniques such as short-circuiting and soft dependencies, and implements an intra-request cache. Viaduct provides <em>data observability, </em>allowing us to understand, down to the field level, what services consume what data. As a GraphQL interface, Viaduct allows us to take advantage of a large ecosystem of open source tooling, including live IDEs, mock servers, and schema visualizers.</p><p>Viaduct started powering production workflows at Airbnb over a year ago. We started from scratch with a clean schema consisting of a handful of entities and have grown it to include 80 core entities that are able to power 75% of our modern API traffic.</p><p>As mentioned in the introduction, more details on the motivation and technology behind Viaduct can be found in our <a href=\"https://www.youtube.com/watch?v=xxk9MWCk7cM\">presentation</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=da771a841344\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/taming-service-oriented-architecture-using-a-data-oriented-service-mesh-da771a841344\">Taming Service-Oriented Architecture Using A Data-Oriented Service Mesh</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "将Airbnb的JVM单体仓库迁移到Bazel (原标题: Migrating Airbnb’s JVM Monorepo to Bazel)",
      "link": "https://medium.com/airbnb-engineering/migrating-airbnbs-jvm-monorepo-to-bazel-33f90eda51ec?source=rss----53c7c27702d5---4",
      "pubDate": "Wed, 13 Aug 2025 17:01:58 GMT",
      "isoDate": "2025-08-13T17:01:58.000Z",
      "creator": "Thomas Bao",
      "summary": "# 将Airbnb的JVM单体仓库迁移到Bazel\n\nAirbnb近期成功将其最大的代码仓库——JVM单体仓库迁移到了Bazel构建系统。该仓库包含数千万行Java、Kotlin和Scala代码，为airbnb.com背后的众多后端服务和数据管道提供支持。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*rSkIrKYhc8Bwcv2xLE1mxA.jpeg)\n\n**迁移成果概览（历时4.5年）：**\n*   构建CSAT（客户满意度）：从38%提升至68%\n*   本地构建和测试时间：提速3-5倍\n*   IntelliJ同步时间：提速2-3倍\n*   部署到开发环境时间：提速2-3倍\n\n本文将探讨迁移的原因、分享关键的实施亮点，并总结主要经验教训。\n\n## 为什么选择Bazel？\n\n在迁移之前，JVM单体仓库使用Gradle作为构建系统。选择迁移到Bazel是因为它提供了三大核心优势：速度、可靠性和统一的构建基础设施层。\n\n### 1. 速度\n\nBazel的可缓存、可移植操作允许通过远程执行扩展性能。\n*   **Gradle的局限性：** 2021年，大型服务的本地构建通常需要20多分钟，预合并CI的p90时间为35分钟。Gradle构建已接近极限，即使在CI上垂直扩展到高端AWS机器并使用启发式方法拆分项目构建和测试，效率依然低下，存在机器利用率不足和共享任务重复的问题。\n*   **Bazel的优势：**\n    *   **远程执行（RBE）：** 允许扩展到数千个并行操作，比Gradle的分片启发式方法效率更高。RBE工作节点是短生命周期的，提高了机器利用率和成本效益。\n    *   **“无字节构建”（Build without the Bytes）：** 只下载文件子集，大幅减少下载量（Gradle中每个缓存的工件都需要下载）。\n    *   **本地构建加速：** RBE显著加快了本地构建速度。\n    ![图片 2](https://cdn-images-1.medium.com/max/1024/0*y__bh8jYeKCNGmCW)\n    ![图片 3](https://cdn-images-1.medium.com/max/1024/0*qEJJw_dqvH--5nS1)\n    *   **并行分析：** Gradle大型项目的配置通常需要数分钟，因为它单线程运行。Bazel的分析阶段并行运行，部分原因是其配置语言Starlark被限制为无副作用。\n\n### 2. 可靠性\n\nBazel的密封性确保了可靠、可重复的构建。\n*   **Gradle的问题：** Gradle任务可以访问完整的文件系统，这在大规模应用中可能导致严重的意外后果。例如，开发者更新任务清理`/tmp/`目录中的文件，可能与其他使用该目录的Gradle任务产生竞态条件，导致CI失败。\n*   **Bazel的解决方案：**\n    *   **沙箱机制：** Bazel通过沙箱解决此问题，确保构建操作只能访问指定的输入。未声明为输入的任何文件在沙箱环境中均不存在。\n    *   **资源隔离：** Gradle任务隐式依赖于机器资源，在不同大小的机器上运行可能导致资源争用。RBE通过在具有严格资源限制的相同容器中运行操作来解决此问题。本地和CI构建都配置为使用RBE，大大减少了环境差异。\n\n### 3. 共享基础设施\n\nAirbnb目前拥有多个特定语言和平台的代码仓库（如web、iOS、Python、Go），所有这些现在都已迁移到Bazel。统一使用Bazel可以在所有仓库之间实现统一的构建基础设施层，包括：\n*   远程缓存\n*   远程构建执行\n*   受影响目标计算\n*   通过构建事件协议进行检测和日志记录\n\n## 我们如何迁移？\n\n### 1. 概念验证\n\n首个里程碑是证明可以在Bazel中构建服务并运行其单元测试。为了最大程度地减少对工程师的干扰，Bazel构建与Gradle并行存在，开发者可以选择使用Gradle或Bazel。\n*   **选择Viaduct服务：** 选择了Airbnb的GraphQL单体平台Viaduct进行概念验证，因为它：\n    *   是Airbnb最大、最复杂的服务之一，其成功迁移预示着整个单体仓库的迁移可行性。\n    *   构建速度慢是主要痛点，Bazel能产生巨大影响。\n    *   每月有300名产品工程师修改其代码，提高构建速度能显著提升生产力。\n    *   Viaduct的核心基础设施团队渴望合作。\n*   **实现方式：**\n    *   将Viaduct的大部分构建逻辑从Gradle移植到Bazel。\n    *   构建了一个自动化构建文件生成器，以应对Gradle构建图的持续变化和共存需求。\n    ![图片 4](https://cdn-images-1.medium.com/max/1024/0*sleFOnx1XS43xzAI)\n*   **初期挑战与解决：** 尽管Bazel本地构建速度提升了2-4倍，但许多开发者最初不愿切换。经过与服务所有者沟通，发现了许多缺失的集成和错误。又花了几个月时间解决这些痛点后，Viaduct开发者才自愿切换到Bazel。\n\n### 2. 使用Bazel扩展构建和测试\n\n概念验证成功后，团队开始将Bazel扩展到JVM单体仓库的其余部分。\n*   **广度优先策略：** 首先让所有仓库在Bazel中编译和测试。\n*   **共存的好处：**\n    *   开发者仍可使用Bazel进行本地开发，即使部署仍使用Gradle构建。\n    *   在Bazel基础设施出现问题时，可以禁用Bazel，让用户回退到Gradle。\n*   **共存的缺点：** 必须维护Gradle和Bazel两个构建图。手动维护Bazel构建图会降低开发体验，因此团队进一步投入自动化构建文件生成。\n\n### 3. 自动化构建文件生成\n\n团队受到Gazelle的启发，Gazelle通过解析源文件生成Bazel构建文件。\n*   **自研生成器：** 考虑到严格的性能要求和处理依赖循环的需求，团队决定构建自己的自动化构建文件生成器。\n*   **性能优化：** 为了不显著降低开发者体验，生成器必须在每次提交合并到主线前快速运行。通过实现外部缓存来加速生成过程。\n*   **工作原理：** 类似Gazelle，生成器解析Java、Kotlin和Scala源文件中的包、导入语句和符号声明，构建文件级依赖图。\n*   **CI集成：** 在CI中，每个主线提交都会发布一个仓库的缓存索引。用户运行`sync-configs`时，会下载此缓存，并仅重新扫描自合并基础以来更改的目录，大大提高了常见情况下的性能。\n*   **更细粒度的构建图：** 生成器支持更细粒度的构建图，Bazel目标数量是Gradle项目的10倍以上，通过更多并行构建和更少缓存失效实现更快的构建。它还能自动检测编译循环并在必要时合并编译单元。\n![图片 5](https://cdn-images-1.medium.com/max/1024/0*zmnMMjLRC2a-XCO0)\n*   **持续价值：** 即使在迁移后，构建文件生成器仍在使用，通过自动修复构建文件配置和移除未使用的依赖项来改善开发者体验。相比之下，Gradle时代用户手动维护约4500个Gradle文件，导致未使用的依赖项、臃肿的依赖图和更慢的构建。\n\n### 4. 移植构建逻辑\n\n除了JVM源文件，仓库还有大量由多个团队拥有的构建逻辑（如代码生成），通常以Gradle插件的形式存在。\n*   **与生成器集成：** 移植构建逻辑时，必须将其与构建文件生成器集成。由于目标更细粒度，Gradle中的一行配置可能需要应用于10多个Bazel构建文件。\n*   **插件和指令：** 构建文件生成器架构支持类似于Gazelle扩展的插件，这些插件由特定文件（如Thrift或GraphQL文件）的存在触发，并能生成新的构建目标（如代码生成操作）。对于手动添加或不易从文件结构推断的Gradle逻辑，支持类似于Gazelle的生成器指令（如添加依赖项或设置属性）。\n*   **团队协作：** 最初由核心团队移植大部分构建逻辑。随着Bazel的普及，复杂构建逻辑的所有者被激励迁移到Bazel，因为其更快、更可靠，他们也常编写自己的构建文件生成器插件，体现了生成器的可扩展性。\n\n### 5. 第三方库多版本支持\n\n迁移过程中遇到的一个主要问题是同一第三方库的多个版本。\n*   **问题：** 最初只指定每个库的单一版本，但Gradle中每个子项目可以使用不同版本的第三方库。这导致在针对单一版本编译时，可能因缺少符号而编译或测试失败。\n*   **解决方案：** 构建了工具来生成多个`maven_install`规则，并添加了自定义方面来在目标级别解决冲突。\n![图片 6](https://cdn-images-1.medium.com/max/1024/0*_U1LAeex52squvmt)\n*   **后续改进：** 将冲突解决移至分析时以获得更好的IDE支持，并添加了更友好的库更新工具。\n\n### 6. 迁移部署\n\n在绝大多数项目在CI中通过Bazel构建并单元测试通过后，团队开始专注于迁移部署。Bazel构建的`.jar`与Gradle构建的`.jar`不完全相同，因此需要策略确保部署安全。\n\n#### 服务\n*   **验证：** 使用启动和集成测试验证服务的部署正确性。约700个服务中，约100个遇到启动或集成测试失败。\n*   **主要问题及解决：**\n    *   **缺失依赖：** 大多数失败是由于Java反射加载的缺失依赖（通常来自配置文件或其他文件）。通过解析文件以查找将通过反射加载的类，然后添加所需依赖来解决。\n    *   **库版本差异：** 另一个主要错误源是库版本不同，可能导致运行时缺少符号错误。Gradle中用户手动指定依赖和版本，而Bazel中构建文件从源生成，依赖从导入语句推断（不指定版本）。通过强制第三方库版本与Gradle项目匹配来解决。\n*   **结果：** 考虑到反射类和版本同步后，只有个位数百分比的服务在生产环境中遇到运行时问题，需要更深入的手动修复。\n\n#### 数据管道和其他项目\n*   **规模：** 除了服务，还有450个数据管道和约50个其他项目部署到Spark集群或Flink运行时。\n*   **验证：** 类似服务，通过测试捕获了许多问题。Airbnb数据工程的“铺路”数据管道有CI测试，可在本地运行小版本Spark管道。\n*   **结果：** 对于约400个“铺路”管道，通过CI测试后，只有约3%在生产环境中出现运行时问题，因此可以非常快速地迁移。\n*   **剩余挑战：** 少数更定制化的可部署项目需要单独部署和监控以验证正确性。\n\n## 我们学到了什么？\n\n### 1. 客户合作\n\n在迁移早期，团队确定了具有巨大影响潜力和愿意投资新构建系统的关键试点服务。例如，Viaduct具有复杂的构建逻辑，导致构建缓慢和可靠性问题，且许多开发者贡献该服务，改进其构建对Airbnb的开发者体验影响巨大。\n*   与试点团队的合作非常有价值。他们是早期采用者，在报告和调试问题、分析性能瓶颈和提出功能方面做出了重大贡献。试点团队也成为了倡导者，提供内部支持，帮助激励Airbnb其他开发者社区。\n\n### 2. 过早优化的危险\n\n这次迁移历时4.5年。事后看来，如果团队先迁移再优化，可以大幅缩短迁移时间。\n*   虽然增加构建粒度缩短了构建时间，但却增加了迁移时间。具体来说，增加构建粒度大大增加了配置文件数量，使得手动管理配置变得更加困难。这迫使更多功能集成到自动化构建中。",
      "shortSummary": "Airbnb历时4.5年成功将其庞大的JVM单体仓库从Gradle迁移到Bazel。此次迁移显著提升了构建CSAT、本地构建和测试速度（3-5倍）、IntelliJ同步速度（2-3倍）及部署速度（2-3倍）。选择Bazel是因其卓越的速度、可靠性和统一的构建基础设施。迁移过程涉及概念验证、自动化构建文件生成、构建逻辑移植及第三方库多版本支持，最终成功迁移了服务和数据管道的部署。关键经验是客户合作的重要性，以及避免过早优化可能带来的迁移时间延长。",
      "translated_title": "将Airbnb的JVM单体仓库迁移到Bazel",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*rSkIrKYhc8Bwcv2xLE1mxA.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*y__bh8jYeKCNGmCW",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*qEJJw_dqvH--5nS1",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*sleFOnx1XS43xzAI",
          "alt": "",
          "title": "",
          "position": 4
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*zmnMMjLRC2a-XCO0",
          "alt": "",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "RSS",
      "content": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rSkIrKYhc8Bwcv2xLE1mxA.jpeg\" /></figure><p><strong>By: </strong>Jack Dai, Howard Ho, Loc Dinh, Stepan Goncharov, Ted Tenedorio, and Thomas Bao</p><p>At Airbnb, we recently completed migrating our largest repo, the JVM monorepo, to Bazel. This repo contains <strong>tens of millions of lines</strong> of Java, Kotlin, and Scala code that power the vast array of backend services and data pipelines behind airbnb.com.</p><p><strong>Migration in numbers (4.5 years of work):</strong></p><ul><li>Build CSAT: 38% → 68%</li><li><strong>3–5x </strong>faster local build and test times</li><li><strong>2–3x </strong>faster IntelliJ syncs</li><li><strong>2–3x</strong> faster deploys to the development environment</li></ul><p>In this blog post, we’ll discuss the <strong>why</strong>, share some highlights on the <strong>how</strong>, and finish off with <strong>key learnings</strong>.</p><h3>Why Bazel?</h3><p>Before the migration, our JVM monorepo used Gradle as its build system. We decided to migrate to<strong> </strong>Bazel because it offered three key advantages: speed, reliability, and a uniform build infrastructure layer.</p><h4>Speed</h4><p><em>Bazel’s cacheable, portable actions allow us to scale performance with remote execution</em></p><p>In 2021, builds of large services often took &gt;20 minutes locally and pre-merge CI p90 was 35 minutes.</p><p>Building with Gradle was near its limit. We had already vertically scaled to high-end AWS machines on CI and remote development machines for developers of large services. In CI, we also used heuristics to split project builds and tests across multiple machines. However, this was inefficient, because of machine underutilization and duplication of shared tasks.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*y__bh8jYeKCNGmCW\" /></figure><p>Bazel remote execution allowed us to scale to thousands of parallel actions. This was far more efficient than our sharding heuristics. Remote build execution (RBE) workers are also short-lived, which results in better machine utilization and cost efficiency. In addition, <a href=\"https://blog.bazel.build/2021/04/07/build-without-the-bytes.html\">Build without the Bytes</a> allows downloading only a subset of files, greatly reducing download volume (in Gradle, every cached artifact needs to be downloaded). Finally and most importantly, local builds are significantly faster thanks to RBE.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*qEJJw_dqvH--5nS1\" /></figure><p>In addition, <a href=\"https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:configuration\">Gradle configuration</a> of some large projects often took minutes due to it being single-threaded. Bazel analysis, in contrast, runs in parallel, in part because its configuration language, Starlark, is constrained to be side-effect-free.</p><h4>Reliability</h4><p><em>Bazel’s hermeticity ensures reliable, repeatable builds</em></p><p>Gradle tasks have access to the full file system, which can lead to serious unintended consequences at scale. One example we ran into was when a developer updated a task to clean up recent files in the /tmp/ directory. This created a race condition with other Gradle tasks that used the /tmp/ directory and caused CI to fail when thousands of Gradle tasks had to be rerun.</p><p>Bazel solves this issue with sandboxing, which ensures that only specified inputs are available to a build action. If a file isn’t declared as an input, it simply doesn’t exist in the sandboxed environment.</p><p>Gradle tasks also implicitly depend on the machine’s resources. Gradle builds run on local machines and CI machines of different sizes. This can lead to resource contention when a task is run on a smaller machine or when the cache is cold and thousands of tasks are run on the same machine.</p><p>Remote build execution (RBE) solves this by running actions in identical containers with strict resource limits. We also configured both local and CI builds to use RBE, which greatly reduces environment differences.</p><h4>Shared infrastructure</h4><p>Airbnb currently has a collection of language- and platform-specific repos, such as <a href=\"https://medium.com/airbnb-engineering/adopting-bazel-for-web-at-scale-a784b2dbe325\">web</a>, <a href=\"https://medium.com/airbnb-engineering/migrating-our-ios-build-system-from-buck-to-bazel-ddd6f3f25aa3\">iOS</a>, Python, and Go, all of which are now on Bazel. Unifying on Bazel enables a uniform build infrastructure layer across repos, which includes:</p><ul><li>Remote caching</li><li>Remote build execution</li><li>Affected targets calculation</li><li>Instrumentation &amp; logging from the <a href=\"https://bazel.build/docs/build-event-protocol\">Build Event Protocol</a></li></ul><h3>How did we migrate?</h3><h4>Proof of concept</h4><p>As a first milestone, we wanted to show that we could build a service and run its unit tests in Bazel. Because this was a proof of concept, we wanted to <strong>minimize disruption to engineers</strong>. Therefore, the Bazel build <em>co-existed </em>with Gradle<strong>. </strong>As a result, developers could choose between using Gradle or Bazel locally<em>.</em></p><p>We needed to prove that developers would <em>choose</em> to opt in to using Bazel over Gradle. It wasn’t enough for Bazel to be faster, developers had to willingly opt in to using Bazel.</p><p>For this proof of concept, we chose Airbnb’s GraphQL monolith platform, <a href=\"https://medium.com/airbnb-engineering/taming-service-oriented-architecture-using-a-data-oriented-service-mesh-da771a841344\">Viaduct</a>, which had the following important properties:</p><ol><li>It was one of Airbnb’s largest and most complex services. If we could migrate Viaduct to Bazel, then we could likely migrate the rest of the monorepo.</li><li>Slow builds were a major pain point, so Bazel could have a large impact.</li><li>Viaduct has 300 product engineers modifying its code every month, so improving Viaduct’s build speed would be a substantial productivity win.</li><li>Because of (2) and (3) above, Viaduct’s core infrastructure team was eager to partner with us.</li></ol><p>To achieve a working Viaduct build with Bazel, we did two things. First, we had to port much of Viaduct’s build logic from Gradle to Bazel. Second, because we decided to maintain co-existing builds and the Gradle build graph was still changing, we decided to build an automated build file generator (which we’ll cover in detail in a separate section).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*8d_f127RDGo6fHBHcqmN3g.png\" /></figure><p>Importantly, even though we were able to locally build the service 2–4x faster with Bazel, many developers did not yet want to switch.</p><p>In talking with the service’s owners, we discovered a number of missing integrations and bugs. It took us an additional few months to address these pain points, after which Viaduct developers willingly switched from Gradle to Bazel.</p><h4>Scaling builds and tests with Bazel</h4><p>The proof of concept showed that Bazel was superior to Gradle for one of Airbnb’s largest services and a large audience of developers. Now we wanted to scale it to the rest of Airbnb’s JVM monorepo.</p><p>We decided to scale breadth-first, getting all of the repo compiling and testing in Bazel. Again, to minimize disruption, Bazel builds co-existed with Gradle, which had two important benefits.</p><p>First, developers could still use Bazel for local development and get most of its benefits even though their code was still built with Gradle for deployment. Second, we could always disable Bazel if it was negatively impacting developers. For example, when Bazel infrastructure like the remote cache or remote execution cluster experienced an incident, we could and did disable Bazel, letting users fall back to Gradle.</p><p>However, a major downside was that both Gradle and Bazel build graphs had to be maintained. Manually maintaining a Bazel build graph would have degraded the developer experience. As a result, we invested further in automated build file generation, so that developers didn’t need to manually maintain Bazel build files.</p><h4>Automated build file generation</h4><p>For our build file generator, we were heavily inspired by <a href=\"https://github.com/bazel-contrib/bazel-gazelle\">Gazelle</a>, which generates Bazel build files by parsing source files to build a dependency graph.</p><p>Although we considered extending Gazelle to support JVM languages, we had very strict performance requirements and needed to handle dependency cycles. This ultimately led us to build our own automated build file generator.</p><p>Because we had to maintain <em>co-existing build graphs</em>, we needed to run the build file generator on every commit before merging into mainline. This meant it had to run as fast as possible to not significantly degrade the developer experience. To achieve this, we implemented external caching to speed up the automated build file generation.</p><p>Similar to Gazelle, the build file generator parses Java, Kotlin, and Scala source files for package and import statements and symbol declarations to build a file-level dependency graph.</p><p>In CI, we publish a cached index of the repository at each mainline commit. When a user runs sync-configs, it downloads this cache and only re-scans directories which have changed since the merge base. This greatly improves performance for the common case where users only modify a small set of files.</p><p>In addition, with this build file generator, we were able to support a more fine-grained build graph, which resulted in &gt;10x more Bazel targets than Gradle projects. This enabled faster builds through more parallel builds and less cache invalidation. However, one challenge of moving to a more fine-grained build graph is the possibility of introducing compilation cycles; sync-configs is able to detect this automatically and merge compilation units when necessary.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UnuZOwRc8X-lT3onIEYHiA.png\" /></figure><p>Even after the migration, the build file generator remains in use. It improves the developer experience by automatically fixing build file configurations and removing unused dependencies. In contrast, when we were on Gradle, users manually maintained ~4,500 Gradle files, which led to unused dependencies, a bloated dependency graph, and slower builds with fewer cache hits.</p><h4>Porting build logic</h4><p>In addition to JVM source files, our repo has a large amount of build logic such as code generation owned by multiple teams. These often took the form of Gradle plugins.</p><p>Because we now had automated build file generation, when porting the build logic, we also had to integrate it with the build file generator. Also, because we had more granular targets, a single line of Gradle config now might need to apply to 10+ Bazel build files.</p><p>As a result, our build file generator architecture supported plugins similar to Gazelle extensions. These plugins were triggered by the presence of specific files such as Thrift or GraphQL files. These plugins could also generate new build targets such as codegen actions.</p><p>In some cases, the Gradle logic was manually added as a one-off or not easily inferred from the file structure. As a result, we also supported generator <em>directives</em> similar to Gazelle, such as adding dependencies or setting attributes.</p><p>Initially, our team ported much of this build logic ourselves with minimal help from service owners. As Bazel adoption grew, owners of complex build logic were incentivized to migrate to Bazel, because it was faster and more reliable than Gradle. In the process, they often wrote their own build file generator plugins, highlighting the extensibility of our generator.</p><h4>Third-party library multi-version support</h4><p>Another major issue we hit on the road to 100% compilation and testing with Bazel was multiple versions of the same third-party library.</p><p>Initially, we specified a single version of each library. The build file generator would add dependencies from this universe.</p><p>However, in Gradle, each sub-project within the monorepo could use different versions of third-party libraries. As a result, when compiling against a single version, compilation or testing could fail with a missing symbol.</p><p>To bring multi-version support to our Bazel system, we built tooling to generate multiple maven_install rules and added a custom <a href=\"https://bazel.build/extending/aspects\">aspect</a> to resolve conflicts at the target level.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*_U1LAeex52squvmt\" /></figure><p><em>Multiple versions of Guava in Bazel before we added conflict resolution</em></p><p>Once we had this capability, we systematically synced library versions from Gradle so that each build target’s classpath more closely matched its Gradle counterpart.</p><p>To learn more about our approach, see our <a href=\"https://www.youtube.com/watch?v=Ui4YtqWhqYU\">BazelCon 2022 talk</a>. Since giving this talk, we have made improvements like moving the resolution to analysis-time for better IDE support and adding more user-friendly tooling for updating libraries.</p><h4>Migrating the deploys</h4><p>As we got the vast majority of projects building and passing unit tests with Bazel in CI, we began to focus on migrating deployments. The Bazel-built jars were not identical to the Gradle-built jars. As a result, we needed a strategy to ensure the deployments were safe. We started with services.</p><h4>Services</h4><p>To verify the correctness of deploying services with Bazel, we used startup and integration tests. Of ~700 services, ~100 encountered startup or integration test failures. The majority of failures were missing dependencies that were loaded via Java reflection, usually from config files or other files. As a result, we were able to fix a number of these issues by parsing files for classes that would be loaded via reflection, and then adding the required dependency.</p><p>Another major source of errors was differing library versions, which could lead to missing symbol errors at runtime. In Gradle, users manually specified dependencies and their versions. However, in Bazel, build files were generated from source and dependencies were inferred from import statements, which didn’t specify the version. We solved many of these errors forcing third-party library versions to match those of the Gradle project.</p><p>After taking into account reflected classes and syncing versions, only a single-digit percentage of services hit production runtime issues that required more in-depth manual work to fix.</p><h4>Data pipelines and other projects</h4><p>In addition to services, we had 450 data pipelines and ~50 other projects that were deployed to either a Spark cluster or a Flink runtime.</p><p>Similar to services, we were able to catch a number of issues using tests. In particular, data pipelines on Airbnb’s data engineering paved path have CI tests that run a small version of the Spark pipeline locally. For these ~400 paved-path pipelines, after passing CI tests, only about 3% had production issues at runtime. As a result, we were able to very quickly migrate the paved-path pipelines.</p><p>As with services, we had a few remaining deployables that were a bit more bespoke and had to be individually deployed and monitored to verify correctness.</p><h3>What did we learn?</h3><h4>Customer partnership</h4><p>Early in the migration, we identified key pilot services that had large opportunities for impact and an appetite to invest in migrating to a new build system. For example, Viaduct had complex build logic leading to slow builds and reliability issues. In addition, many developers contributed to the service, so improving their builds had a large impact on Airbnb’s developer experience.</p><p>Partnering with pilot teams was incredibly valuable. They were early adopters and made significant contributions in the form of reporting and debugging issues, profiling performance bottlenecks, and suggesting features. The pilot teams also became advocates and provided internal support, helping motivate the rest of the Airbnb developer community.</p><h4>Dangers of premature optimization</h4><p>This migration took 4.5 years. With the benefit of hindsight we think we could have drastically improved the migration timeline if we had <strong>migrated first, before improving</strong><em>.</em></p><p>Although increasing build granularity improved build times, it increased the time to migrate. Specifically, increased build granularity greatly increased the number of configuration files, making it much harder to manage configurations manually. This forced more functionality into automated build file generation, which increased its complexity.</p><p>If we had migrated first and <em>then</em> optimized the build granularity, we believe we could have migrated sooner, enabling users to get benefits from Bazel sooner and reducing the time spent maintaining two co-existing builds.</p><p>Similarly, build granularity also made it harder to match deploy jars between Gradle and Bazel. This led to spending more time testing deployments and fixing runtime issues.</p><p>On a more positive note, we accelerated the migration by deciding to support multiple third-party library versions and implementing version resolution. This enabled us to sync versions from Gradle to Bazel, which fixed a large number of build and runtime issues.</p><p>Towards the end, one major takeaway in the migration was, <strong>by default, we should try to imitate what was there before</strong><em>. </em>In our case, deviating from Gradle usually added technical risk, and should be carefully considered, especially its downstream consequences.</p><p>As engineers, we often want to improve things. However, during migrations, improvements can have non-obvious consequences and potentially significantly slow down the migration.</p><h3>🏁 Conclusion</h3><p>After 4.5 years, we fully migrated Airbnb’s biggest repo from Gradle to Bazel, achieving:</p><ul><li>Build CSAT: 38% → 68%</li><li><strong>3–5x </strong>faster local build and test times</li><li><strong>2–3x</strong> faster IntelliJ syncs</li><li><strong>2–3x</strong> faster deploys to the development environment</li></ul><p>Finally, now that several Airbnb repos are on Bazel, we’re able to share <a href=\"https://www.youtube.com/watch?v=RpSVBtyoYCY\">common infrastructure</a> such as remote build caching, remote build execution, affected targets calculation, and more.</p><p>Interested in helping us solve problems like these at Airbnb? Learn more about our open engineering roles <a href=\"https://careers.airbnb.com/\">here</a>.</p><h3>Acknowledgments</h3><p>Additionally, thank you Janusz Kudelka, Kumail Hussain, Meghan Dow, Pawel Lipski, Peimin Liu, Tomasz Pacuszka, and various other internal and external partners.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33f90eda51ec\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/migrating-airbnbs-jvm-monorepo-to-bazel-33f90eda51ec\">Migrating Airbnb’s JVM Monorepo to Bazel</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "大规模 Istio 无缝升级 (原标题: Seamless Istio Upgrades at Scale)",
      "link": "https://medium.com/airbnb-engineering/seamless-istio-upgrades-at-scale-bcb0e49c5cf8?source=rss----53c7c27702d5---4",
      "pubDate": "Thu, 07 Aug 2025 17:01:42 GMT",
      "isoDate": "2025-08-07T17:01:42.000Z",
      "creator": "Rushy R. Panchal",
      "summary": "# 大规模 Istio 无缝升级\n\n## 引言\n\nAirbnb 自2019年起大规模运行 Istio®，支持数万个 Pod、数十个 Kubernetes 集群和数千个虚拟机 (VM)，峰值期间通过 Istio 处理数千万 QPS。Istio 是 Airbnb 架构的基础组成部分，这使得其持续维护和升级成为一项挑战。尽管如此，Airbnb 已成功升级 Istio 14 次。本文将探讨 Airbnb 服务网格团队如何在保持高可用性的同时安全地升级 Istio。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*44AVFDg8R66nWj4cAU8vCA.jpeg)\n\n## 面临的挑战与升级目标\n\nAirbnb 工程师运行着数千种不同的工作负载，无法合理协调每个团队。因此，升级过程必须独立于单个团队运行，且由于无法同时监控所有工作负载，必须通过渐进式发布将风险降至最低。\n\n基于此，Airbnb 设计的升级流程旨在实现以下目标：\n\n*   **工作负载和用户零停机**：这是无缝升级的关键，工作负载所有者无需参与 Istio 升级。\n*   **渐进式发布**：能够控制哪些工作负载被升级或回滚。\n*   **全面回滚能力**：无需协调每个工作负载团队，即可在所有工作负载上回滚升级。\n*   **规定时间内完成升级**：所有工作负载应在定义的时间内完成升级。\n\n## 架构概览\n\nAirbnb 的 Istio 部署包含一个**管理集群**，运行 Istiod 并包含所有网格的工作负载配置（如 VirtualServices、DestinationRules），以及多个**工作负载集群**，运行用户工作负载。VM 独立运行，但其 Istio Manifests 仍部署到管理集群的独立命名空间中。Airbnb 独占使用 **Sidecar 模式**，即每个工作负载都运行 istio-proxy，尚未运行 Ambient 模式。\n\n![Istio 部署架构图](https://cdn-images-1.medium.com/max/1024/0*-qAuZZZxdsi-oJSO)\n\n## 升级流程\n\nAirbnb 遵循 Istio 的 **Canary 升级模型**，即同时运行两个版本的 Istiod（当前版本和新版本）。这两个版本共同构成一个逻辑服务网格，允许连接到不同 Istiod 的工作负载相互通信。Istiod 版本通过不同的修订标签进行管理（例如，1-24-5 用于 Istio 1.24.5，1-25-2 用于 Istio 1.25.2）。\n\n升级涉及控制平面 Istiod 和数据平面 Sidecar istio-proxy。尽管 Istio 支持旧版 istio-proxy 连接新版 Istiod，但 Airbnb 不采用此方式。相反，他们原子性地将新版 istio-proxy 及其连接的 Istiod 配置一同发布到工作负载。例如，为 1.24 版本构建的 istio-proxy 只会连接到 1.24 的 Istiod，这降低了升级期间的复杂性（跨版本数据平面-控制平面兼容性）。\n\n升级过程的第一步是在管理集群上部署带有新修订标签的新版 Istiod。由于所有工作负载都明确绑定到某个修订版，因此没有工作负载会连接到这个新的 Istiod，这一步没有影响。升级的其余部分（也是主要工作和风险所在）是逐步将工作负载切换到运行新版 istio-proxy 并连接到新版 Istiod。\n\n![多修订版 Istio 示意图](https://cdn-images-1.medium.com/max/1024/0*k7_eTtEPqBiDKM3t)\n\n## 发布规范 (`rollouts.yml`)\n\nAirbnb 通过一个名为 `rollouts.yml` 的文件控制工作负载运行的 istio-proxy 版本。该文件指定了工作负载命名空间（作为模式）和 Istio 版本的百分比分布，例如：\n\n```yaml\n# \"production\" 是默认值；任何不匹配其他模式的都将匹配此项。\nproduction: 1-24-5: 100\n\n\".*-staging\": 1-24-5: 75 1-25-2: 25\n\n# 一个固定的命名空间；我们的端到端验证工作负载。\nistio-e2e: 1-25-2: 100\n```\n\n此规范规定了所有命名空间的期望状态。给定命名空间首先映射到一个桶（基于最长匹配模式），然后根据该桶的分布选择一个版本。这种分布应用于命名空间级别，而非 Pod 或 VM 级别，且通过一致性哈希实现确定性分配。大部分升级过程仅涉及更新 `rollouts.yml` 并进行监控。这种方式允许选择性升级工作负载，并能独立升级环境，确保只有一定比例的环境运行新版本，从而有时间进行“烘焙”并发现潜在的回归问题。\n\n## Kubernetes 工作负载升级机制\n\n每个 Istio 修订版在每个工作负载集群上都有一个对应的 `MutatingAdmissionWebhook` 用于 Sidecar 注入。此 Webhook 选择带有 `istio.io/rev=<revision>` 标签的 Pod，并向其注入 istio-proxy 和 istio-init 容器。值得注意的是，istio-proxy 容器包含 `PROXY_CONFIG` 环境变量，该变量将 `discoveryAddress` 设置为特定的 Istiod 修订版。这确保了 istio-proxy 版本和其连接的 Istiod 配置的原子性部署，完全由 Sidecar 注入器完成。\n\n每个工作负载的 Deployment 都带有此修订标签。然而，传统方法要求每个团队手动更新此标签并部署其工作负载，这使得在所有工作负载上执行回滚或确保 100% 完成升级变得不切实际。\n\n### Krispr：内部突变框架\n\n为避免单独更新工作负载，Airbnb 使用内部构建的突变框架 **Krispr** 来注入修订标签，从而将基础设施组件升级与工作负载部署解耦。Airbnb 在 Kubernetes 上运行的工作负载使用内部 API 定义，而非直接指定 Kubernetes Manifests。此抽象在 CI 期间编译为 Kubernetes Manifests，Krispr 作为编译过程的一部分运行，并突变这些 Manifests。其中一项突变就是根据 `rollouts.yml` 决定并注入 Istio 修订标签到每个 Deployment 的 Pod 规范中。如果团队在部署时发现任何问题，他们可以回滚，从而也回滚 Istio 升级，而无需服务网格团队的介入。\n\n此外，Krispr 还在 Pod 准入阶段运行。如果一个 Pod 来自超过两周的 Deployment，Krispr 将重新突变该 Pod，并在需要时更新其修订标签。结合 Kubernetes 节点最长两周的生命周期（从而确保任何给定 Pod 的最长生命周期也是两周），Airbnb 可以保证 Istio 升级最终完成。大多数工作负载将在部署时（CI 中的 Krispr 运行期间）升级，对于不定期部署的工作负载，自然的 Pod 循环和重新突变将确保它们在最长四周内完成升级。\n\n**总结 Kubernetes 工作负载升级流程：**\n\n1.  **CI 阶段**：Krispr 根据 `rollouts.yml` 突变工作负载的 Kubernetes Manifests，添加 Istio 修订标签。\n2.  **Pod 准入阶段**：如果 Pod 的 Deployment 超过两周，Krispr 会重新突变 Pod，并在需要时更新 Istio 修订标签。\n3.  **Webhook 注入**：特定修订版的 Istio `MutatingAdmissionWebhook` 会注入 Sidecar 和关联的 `discoveryAddress`。\n\n## 虚拟机 (VM) 工作负载升级机制\n\n在 VM 上，Airbnb 部署一个包含 istio-proxy、运行 istio-iptables 的脚本（类似于 istio-init 容器）和 Istiod `discoveryAddress` 的工件。通过将 istio-proxy 和 `discoveryAddress` 打包在同一工件中，可以原子性地升级两者。此工件的安装由主机守护进程 **mxagent** 负责。它通过轮询 VM 上的键值标签（如 AWS 上的 EC2 标签或 GCP 上的资源标签，这些标签模仿 Kubernetes 工作负载的 `istio.io/rev` 标签）来确定要安装的版本。每当这些标签改变时，mxagent 就会下载并安装对应版本的工件。因此，升级 VM 上的 istio-proxy 只需更新该 VM 上的这些标签，mxagent 将处理其余部分。\n\nAirbnb 的 VM 工作负载主要是基础设施平台，通常不定期部署代码。因此，VM 不支持部署时升级（不像 Kubernetes 工作负载）。同样，团队无法自行回滚这些工作负载，但考虑到此类基础设施平台数量有限，这是可以接受的。\n\n标签更新由中央控制器 **mxrc** 管理，它扫描过时的 VM。如果 `rollouts.yml` 会导致 VM 的资源标签集发生变化，控制器将相应地更新标签。这大致对应于 Krispr 的 Pod 准入时突变，但需要注意的是，VM 是可变的且生命周期长，因此是原地升级。\n\n为了安全起见，mxrc 会考虑 VM 的健康状况，特别是 WorkloadEntry 上的就绪探针状态。类似于 Kubernetes 的 `maxUnavailable` 语义，mxrc 旨在将不可用 VM 的数量（即不健康的 VM 加上正在升级的 VM）保持在定义的百分比以下。它逐步执行这些升级，目标是在两周内完成一个工作负载所有 VM 的升级。\n\n## 结论\n\n跟上开源软件的更新步伐是一项挑战，尤其是在大规模环境下。升级和其他 Day-2 操作常常被忽视，这在最终需要升级时（为了引入安全补丁、保持在支持窗口内、利用新功能等）增加了负担。对于 Istio 而言尤其如此，其版本很快就会达到生命周期结束。\n\n尽管服务网格的复杂性和规模巨大，Airbnb 已成功升级 Istio 14 次。这得益于：\n\n*   **可维护性设计**\n*   **确保零停机的流程**\n*   **通过渐进式发布降低风险**\n\n类似流程也应用于 Airbnb 的其他多个基础架构系统。\n\n## 未来工作\n\n随着 Airbnb 基础设施的不断发展和壮大，服务网格团队正在关注几个关键项目：\n\n*   **利用 Ambient 模式**：作为一种更具成本效益且更易于管理的 Istio 部署模型。特别是，它通过完全无需触及工作负载部署来简化升级。\n*   **将单一生产网格拆分为多个网格**：以分离故障域、提供更好的安全隔离边界并进一步扩展 Istio。对于升级而言，这将进一步缩小影响范围，因为一些只运行低风险工作负载（如 staging）的网格可以首先升级。",
      "shortSummary": "Airbnb 详细介绍了其大规模 Istio 无缝升级实践。面对数万个 Pod 和 VM 的复杂环境，他们通过 Istio 的 Canary 升级模型，结合内部工具 Krispr（用于 Kubernetes）和 mxagent/mxrc（用于 VM），实现了控制平面和数据平面的原子性升级。这套系统确保了零停机、渐进式发布和无需人工协调的全面回滚能力，使所有工作负载能在数周内完成升级。未来计划包括采用 Ambient 模式和拆分服务网格以提升效率和安全性。",
      "translated_title": "大规模 Istio 无缝升级",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*44AVFDg8R66nWj4cAU8vCA.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*-qAuZZZxdsi-oJSO",
          "alt": "A diagram of Istio deployment architecture at Airbnb. There is a single configuration cluster containing Istio custom resources like VirtualServices, Istiod, and Istiod’s ConfigMaps. There are two workload clusters, each running user workloads, and alongside those a number of VMs. Workloads and VMs communicate with each other.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*k7_eTtEPqBiDKM3t",
          "alt": "Istio with multiple revisions. There is a config cluster with Istio custom resources like VirtualServices, multiple Istiod deployments, and the Istiod ConfigMaps for each of those. Workloads can connect to either Istiod.",
          "title": "",
          "position": 3
        },
        {
          "url": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bcb0e49c5cf8",
          "alt": "",
          "title": "",
          "position": 4
        }
      ],
      "contentSource": "RSS",
      "content": "<h4><strong>How Airbnb upgrades tens of thousands of pods on dozens of Kubernetes clusters to new Istio versions</strong></h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*44AVFDg8R66nWj4cAU8vCA.jpeg\" /></figure><p>Airbnb has been running Istio® at scale since 2019. We support workloads running on both Kubernetes and virtual machines (using <a href=\"https://istio.io/latest/docs/ops/deployment/vm-architecture/\">Istio’s mesh expansion</a>). Across these two environments, we run tens of thousands of pods, dozens of Kubernetes clusters, and thousands of VMs. These workloads send tens of millions of QPS at peak through Istio. Our <a href=\"https://www.youtube.com/watch?v=6kDiDQW5YXQ\">IstioCon 2021 talk</a> describes our journey onto Istio and our <a href=\"https://www.youtube.com/watch?v=1D8lg36ZNHs\">KubeCon 2021 talk</a> goes into further detail on our architecture.</p><p>Istio is a foundational piece of our architecture, which makes ongoing maintenance and upgrades a challenge. Despite that, we have upgraded Istio a total of 14 times. This blog post will explore how the Service Mesh team at Airbnb safely upgrades Istio while maintaining high availability.</p><h4>Challenges</h4><p>Airbnb engineers collectively run thousands of different workloads. We cannot reasonably coordinate the teams that own these, so our upgrades must function independently of individual teams. We also cannot monitor all of these at once, and so we must minimize risk through gradual rollouts.</p><p>With that in mind, we designed our upgrade process with the following goals:</p><ol><li>Zero downtime for workloads and users. This is the <em>seamless</em> part of the upgrade — a workload owner doesn’t need to be in the loop for Istio upgrades.</li><li>Gradual rollouts with the ability to control which workloads are upgraded or reverted.</li><li>We must be able to roll back an upgrade across all workloads, without coordinating every workload team.</li><li>All workloads should be upgraded within some defined time.</li></ol><h4>Architecture</h4><p>Our deployment consists of one management cluster, which runs Istiod and contains all workload configuration for the mesh (VirtualServices, DestinationRules, and so forth), and multiple workload clusters, which run user workloads. VMs run separately, but their Istio manifests are still deployed to the management cluster in their own namespaces. We use Sidecar mode exclusively, meaning that every workload runs istio-proxy — we do not yet run <a href=\"https://istio.io/latest/docs/ambient/overview/\">Ambient</a>.</p><figure><img alt=\"A diagram of Istio deployment architecture at Airbnb. There is a single configuration cluster containing Istio custom resources like VirtualServices, Istiod, and Istiod’s ConfigMaps. There are two workload clusters, each running user workloads, and alongside those a number of VMs. Workloads and VMs communicate with each other.\" src=\"https://cdn-images-1.medium.com/max/1024/0*-qAuZZZxdsi-oJSO\" /></figure><h4>Upgrade Process</h4><p>At a high level, we follow <a href=\"https://istio.io/latest/docs/setup/upgrade/canary/\">Istio’s canary upgrade model</a>. This involves running two versions (or Istio revisions) of Istiod simultaneously: the current version and the new version that we are upgrading to. Both form one logical service mesh, so workloads connected to one Istiod can communicate with workloads connected to another Istiod and vice versa. Istiod versions are managed using different revision labels — for example, 1–24–5 for Istio 1.24.5 and 1–25–2 for Istio 1.25.2.</p><p>An upgrade involves both Istiod, the control plane, and istio-proxy, the data plane sidecar, running on all pods and VMs. While Istio supports connecting an <a href=\"https://istio.io/latest/docs/releases/supported-releases/#control-planedata-plane-skew\">older istio-proxy to a newer Istiod</a>, we do not use this. Instead, we atomically roll out the new istio-proxy version to a workload along with the configuration of which Istiod to connect to. For example, the istio-proxy built for version 1.24 will only connect to 1.24’s Istiod and the istio-proxy built for 1.25 will only connect to 1.25’s Istiod. This reduces a dimension of complexity during upgrades (cross-version data plane — control plane compatibility).</p><p>The first step of our upgrade process is to deploy the new Istiod, with a new revision label, onto the management cluster. Because all workloads are explicitly pinned to a revision, no workload will connect to this new Istiod, so this first step has no impact.</p><p>The rest of the upgrade comprises all of the effort and risk — workloads are gradually shifted to run the new istio-proxy version and connect to the new Istiod.</p><figure><img alt=\"Istio with multiple revisions. There is a config cluster with Istio custom resources like VirtualServices, multiple Istiod deployments, and the Istiod ConfigMaps for each of those. Workloads can connect to either Istiod.\" src=\"https://cdn-images-1.medium.com/max/1024/0*k7_eTtEPqBiDKM3t\" /><figcaption><em>Multiple Istio revisions, with some workloads connected to different revisions.</em></figcaption></figure><h3>Rollout specification</h3><p>We control what version of istio-proxy workloads run through a file called rollouts.yml. This file specifies workload namespaces (as patterns) and the percentage distribution of Istio versions:</p><pre># &quot;production&quot; is the default; anything not matching a different pattern will match this.<br>production:<br>  1-24-5: 100<br><br>&quot;.*-staging&quot;:<br>  1-24-5: 75<br>  1-25-2: 25<br><br># A pinned namespace; our end-to-end verification workload.<br>istio-e2e:<br>  1-25-2: 100</pre><p>This spec dictates the desired state of all namespaces. A given namespace is first mapped to a bucket (based on the longest pattern that matches) and then a version is chosen based on the distribution for that bucket. The distribution applies at the namespace level, not the pod (or VM) level. For example,</p><pre>&quot;.*-staging&quot;:<br>  1-24-5: 75<br>  1-25-2: 25</pre><p>means that 75% of the namespaces with the suffix -stagingwill be assigned to 1–24–5 and the remaining 25% will be assigned to 1–25–2. This assignment is deterministic, using consistent hashing. The majority of our upgrade process involves updating rollouts.yml and then monitoring.</p><p>This process allows us to selectively upgrade workloads. We can also upgrade environments separately and ensure that only a certain percentage of those environments are on the new version. This gives us time to bake an upgrade and learn of potential regressions.</p><p>The rest of this post will describe the mechanism through which a change to rollouts.yml is applied to thousands of workloads, for both Kubernetes and VMs.</p><h3>Kubernetes</h3><p>Each Istio revision has a corresponding <a href=\"https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection\">MutatingAdmissionWebhook for sidecar injection</a> on every workload cluster. This webhook selects pods specifying the label istio.io/rev=&lt;revision&gt; and injects the istio-proxy and istio-init containers into those pods. Notably, the istio-proxy container contains the PROXY_CONFIG environment variable, which sets the discoveryAddress to the Istiod revision. This is how the istio-proxyversion and the configuration for which Istiod to connect to are deployed atomically — entirely by the sidecar injector.</p><p>Every workload’s Deployment has this revision label. For example, a workload configured to use Istio 1.24.5 will have the label istio.io/rev=1–24–5in its pod template; thus pods for that Deployment will be mutated by the MutatingAdmissionWebhook for Istio 1.24.5.</p><p>This setup is the standard method of upgrading Istio, but requires that every Deployment specifies a revision label. To perform an upgrade across thousands of workloads, every team would have to update this label and deploy their workload. We could neither perform a rollback across all workloads nor reasonably expect an upgrade to complete to 100%, both for the same reason — relying on every workload to deploy.</p><h4>Krispr</h4><p>To avoid having to update workloads individually, a workload’s configuration never directly specifies the revision label in source code. Instead, we use <a href=\"https://medium.com/airbnb-engineering/a-krispr-approach-to-kubernetes-infrastructure-a0741cff4e0c\">Krispr, a mutation framework built in-house</a>, to inject the revision label. Krispr gives us the ability to decouple infrastructure component upgrades from workload deployments.</p><p>Airbnb workloads that run on Kubernetes use an internal API to define their workload, instead of specifying Kubernetes manifests. This abstraction is then compiled into Kubernetes manifests during CI. Krispr runs as part of this compilation and mutates those Kubernetes manifests. One of those mutations injects the Istio revision label into the pod specification of each Deployment, reading rollouts.ymlto decide which label to inject. If a team sees any issue with their workload when they deploy, they can roll back and thus also roll back the Istio upgrade — all without involving the Service Mesh team.</p><p>In addition, Krispr runs during pod admission. If a pod is being admitted from a Deployment that is more than two weeks old, Krispr will re-mutate the pod and accordingly update the pod’s revision label if needed. Combined with the fact that our Kubernetes nodes have a maximum lifetime of two weeks, thus ensuring that any given pod’s maximum lifetime is also two weeks, we can guarantee that an Istio upgrade completes. A majority of workloads will be upgraded when they deploy (during the Krispr run in CI) and for those that don’t deploy regularly, the natural pod cycling and re-mutation will ensure they are upgraded in at most four weeks.</p><p>In summary, per workload:</p><ol><li>During CI, Krispr mutates the Kubernetes manifests of a workload to add the Istio revision label, based on rollouts.yml.</li><li>When a pod is admitted to a cluster, Krispr will re-mutate the pod if its Deployment is more than two weeks old and update the Istio revision label if needed.</li><li>The revision-specific Istio MutatingAdmissionWebhook will mutate the pod by injecting the sidecar and associated discoveryAddress.</li></ol><h3>Virtual machines</h3><p>On VMs, we deploy an artifact that contains istio-proxy, a script to run istio-iptables (similar to the istio-init container), and the Istiod discoveryAddress. By packaging istio-proxy and the discoveryAddress in the same artifact, we can atomically upgrade both.</p><p>Installation of this artifact is the responsibility of an on-host daemon called mxagent. It determines what version to install by polling a set of key-value tags on the VM (such as <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html\">EC2 tags on AWS</a> or <a href=\"https://cloud.google.com/compute/docs/tag-resources\">resource tags on GCP</a>). These tags mimic the istio.io/rev label for Kubernetes-based workloads. Whenever they change, mxagent will download and install the artifact corresponding to that version. Thus, upgrading istio-proxy on a VM just involves updating these tags on that VM; mxagent will take care of the rest.</p><p>Our VM workloads are largely infrastructure platforms that don’t typically have code deployed at regular intervals. As such, VMs don’t support a deploy-time upgrade (in the way that Kubernetes workloads can be upgraded when they deploy). Similarly, teams cannot roll back these workloads themselves, but this has been acceptable, given that there are just a handful of such infrastructure platforms.</p><p>The tag updates are managed by a central controller, mxrc, which scans for outdated VMs. If rollouts.yml would result in a different set of resource tags for a VM, the controller will update the tags accordingly. This roughly corresponds to Krispr’s pod admission-time mutation — however, with the caveat that VMs are mutable and long-lived, and thus are upgraded in-place.</p><p>For safety, mxrc takes into account the health of the VM, namely in the form of the <a href=\"https://istio.io/latest/docs/reference/config/networking/workload-group/#ReadinessProbe\">readiness probe status on the WorkloadEntry</a>. Similar to Kubernetes’ maxUnavailable semantics, mxrc aims to keep the number of unavailable VMs (that is, unhealthy VMs plus those with in-progress upgrades) below a defined percentage. It gradually performs these upgrades, aiming to upgrade all the VMs for a workload in two weeks.</p><p>At the end of two weeks, all VMs will match the desired state in rollouts.yml.</p><h3>Conclusion</h3><p>Keeping up-to-date with open-source software is a challenge, especially at scale. Upgrades and other Day-2 operations often become an afterthought, which furthers the burden when upgrades are eventually necessary (to bring in security patches, remain within support windows, utilize new features, and so forth). This is particularly true with Istio, where a version reaches end-of-life support rapidly.</p><p>Even with the complexity and scale of our service mesh, we have successfully upgraded Istio 14 times. This was made possible due to designing for maintainability, building a process that ensures zero downtime, and derisking through the use of gradual rollouts. Similar processes are in use for a number of other foundational infrastructure systems at Airbnb.</p><h3>Future work</h3><p>As Airbnb’s infrastructure continues to evolve and grow, we’re looking at a few key projects to evolve our service mesh:</p><ul><li>Utilizing <a href=\"https://istio.io/latest/docs/ambient/overview/\">Ambient mode</a> as a more cost-effective and easier-to-manage deployment model of Istio. In particular, this simplifies upgrades by not needing to touch workload deployments at all.</li><li>Splitting our singular production mesh into multiple meshes in order to separate fault domains, provide better security isolation boundaries, and scale Istio further. For upgrades, this would further reduce the blast radius, as some meshes that only run low-risk workloads (such as staging) could be upgraded first.</li></ul><p>If this type of work interests you, we encourage you to apply for an <a href=\"https://careers.airbnb.com/\">open position</a> today.</p><h3>Acknowledgements</h3><p>All of our work with Istio is thanks to many different people, including: Jungho Ahn, Stephen Chan, Weibo He, Douglas Jordan, Brian Wolfe, Edie Yang, Dasol Yoon, and Ying Zhu.</p><p><em>All product names, logos, and brands are property of their respective owners. All company, product and service names used in this website are for identification purposes only. Use of these names, logos, and brands does not imply endorsement.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bcb0e49c5cf8\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/seamless-istio-upgrades-at-scale-bcb0e49c5cf8\">Seamless Istio Upgrades at Scale</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "Airbnb 在 Kubernetes 上通过分布式数据库实现高可用性 (原标题: Achieving High Availability with distributed database on Kubernetes at Airbnb)",
      "link": "https://medium.com/airbnb-engineering/achieving-high-availability-with-distributed-database-on-kubernetes-at-airbnb-58cc2e9856f4?source=rss----53c7c27702d5---4",
      "pubDate": "Mon, 28 Jul 2025 17:57:46 GMT",
      "isoDate": "2025-07-28T17:57:46.000Z",
      "creator": "Artem Danilov",
      "summary": "## Airbnb 在 Kubernetes 上实现分布式数据库高可用性\n\n### 引言\n\n传统上，组织通过分片策略在高成本的独立服务器上部署数据库以实现扩展。然而，随着数据需求的增长，这种策略的局限性日益明显，维护项目变得越来越长和复杂。分布式横向可扩展数据库已不罕见，其中许多是开源的。但在云环境中以高可用性、低延迟、可扩展性且成本合理的方式可靠运行这些数据库，是许多公司面临的挑战。\n\nAirbnb 采取了一种创新策略：在云环境中跨多个 Kubernetes 集群部署分布式数据库集群。尽管这种设计模式因其复杂性目前尚不常见，但它使 Airbnb 实现了目标系统可靠性和可操作性。本文分享了 Airbnb 如何克服挑战并开发出适用于任何强一致性分布式存储系统的最佳实践。\n\n### 在 Kubernetes 上管理数据库\n\nAirbnb 将一个开源的横向可扩展分布式 SQL 数据库集成到其基础设施中。虽然 Kubernetes 是运行无状态服务的优秀工具，但将其用于数据库等有状态服务具有挑战性，尤其是在节点替换和升级方面。\n\n*   **数据处理挑战**：Kubernetes 缺乏对节点间数据分布的了解，因此每次节点替换都需要仔细的数据处理，以防止数据仲裁丢失和服务中断，包括在替换节点前复制数据。\n*   **存储解决方案**：Airbnb 选择使用 AWS EBS 将存储卷附加到节点，这使得在节点替换时可以快速将卷重新附加到新的虚拟机。得益于 Kubernetes 的持久卷声明（PVC），这种重新附加是自动发生的。\n*   **自定义操作符**：为了确保新的存储节点有足够时间赶上集群的当前状态，Airbnb 依赖于自定义的 Kubernetes 操作符（k8s operator），该操作符允许根据应用程序的特定需求定制各种 Kubernetes 操作。\n\n### 协调节点替换\n\n节点替换的原因多种多样，包括 AWS 实例退役、Kubernetes 升级或配置更改。Airbnb 将节点替换事件分为三类：\n\n1.  **数据库发起的事件**：如配置更改或版本升级。\n2.  **主动基础设施事件**：如实例退役或节点升级。\n3.  **计划外基础设施故障**：如节点无响应。\n\n*   **安全管理**：\n    *   对于数据库发起的事件，k8s-operator 中实现了自定义检查，以在删除任何 Pod 之前验证所有节点是否正常运行。\n    *   为了与基础设施发起的事件串行化，在 Kubernetes 中实现了一个准入钩子（admission hook），用于拦截 Pod 驱逐。该钩子拒绝任何驱逐 Pod 的尝试，但会在 Pod 上分配一个自定义注解，自定义数据库 k8s-operator 会监听并根据该注解安全地删除 Pod，从而与任何数据库发起的节点替换串行化。\n    *   对于计划外基础设施故障（如硬件故障），无法协调。但可以通过确保在故障硬件被替换之前，阻止前两类事件的任何节点替换来提高可用性。\n*   **k8s 操作符的作用**：在 Airbnb 的基础设施中，k8s 操作符处理主动和基础设施触发的节点替换，在节点替换时保持数据一致性，并确保计划外事件不会影响正在进行的维护。\n\n### Kubernetes 升级\n\n定期的 Kubernetes 升级至关重要，但可能是高风险操作，特别是对于数据库而言。云托管的 Kubernetes 在控制平面升级后可能不提供回滚功能，如果出现问题，会带来潜在的灾难恢复挑战。Airbnb 采用自管理 Kubernetes 集群，允许回滚控制平面，但糟糕的 Kubernetes 升级仍可能导致服务中断，直到回滚完成。\n\n### 通过多 Kubernetes 集群确保容错性\n\nAirbnb 认为实现高区域可用性的最佳方式是将每个数据库部署在三个独立的 Kubernetes 集群中，每个集群位于不同的 AWS 可用区（AZ）。\n\n*   **隔离性**：AWS 可用区不仅提供独立的电源、网络和连接，还进行逐区域的发布。Kubernetes 集群与 AWS AZ 的对齐意味着任何底层基础设施问题或错误部署的爆炸半径都有限，因为它们仅限于单个 AZ。\n*   **分阶段部署**：在内部，Airbnb 还会将新配置或新数据库版本首先部署到位于单个 Kubernetes 集群中一个 AZ 内的逻辑集群的一部分。\n*   **可用性提升**：尽管这种设置增加了复杂性，但它通过限制来自每一层（无论是数据库、Kubernetes 还是 AWS 基础设施）的故障部署所引起问题的爆炸半径，显著提高了可用性。\n*   **弹性示例**：最近，基础设施中一次错误的配置部署突然终止了暂存 Kubernetes 集群中特定类型的所有虚拟机，删除了大部分查询层 Pod。然而，由于中断被隔离到单个 Kubernetes 集群，三分之二的查询层节点保持运行，从而避免了任何影响。\n*   **容量冗余**：Airbnb 还对数据库集群进行过量配置，以确保即使整个 AZ、Kubernetes 集群或区域内的所有存储节点发生故障，仍有足够的容量来处理流量。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/0*X2h18kiTtfcbRXQo)\n\n![图片 2](https://cdn-images-1.medium.com/max/1024/0*1hSoKkktPABPkTj)\n\n### 利用 AWS EBS 实现可靠性和延迟处理\n\nEBS 为 Airbnb 的部署提供了两个关键优势：\n\n1.  **快速重新附加**：在节点替换期间能够快速重新附加。\n2.  **卓越的持久性**：与本地磁盘相比具有更强的持久性。\n\n*   **副本数量**：借助 EBS，Airbnb 仅使用三个副本即可自信地运行高可用集群，无需额外冗余即可保持可靠性。\n*   **延迟缓解**：EBS 偶尔会出现尾部延迟峰值，p99 延迟可能达到 1 秒。为缓解此问题，Airbnb 实施了存储读取超时会话变量，允许查询在 EBS 延迟峰值期间透明地重试其他存储节点。\n    *   **读策略优化**：默认情况下，所使用的数据库将所有请求和重试发送给领导者。为了在 EBS 健康的存储节点上启用重试，必须允许从领导者和副本进行读取，但原始请求优先选择最近的副本。这带来了降低延迟和避免跨 AZ 网络成本的额外好处，因为每个 AZ 都有一个副本。\n    *   **陈旧读取**：对于允许的用例，利用陈旧读取功能，使副本能够独立提供读取服务，而无需对领导者进行同步调用（领导者可能在读取时遇到 EBS 延迟峰值）。\n\n### 结论：探索 Kubernetes 上的开源数据库\n\nAirbnb 在 Kubernetes 上运行分布式数据库的实践使其实现了高可用性、低延迟、可扩展性和更低的维护成本。通过利用操作符模式、多集群部署、AWS EBS 和陈旧读取，Airbnb 证明了即使是开源分布式存储系统也能在云环境中蓬勃发展。\n\nAirbnb 已在生产环境中运行多个数据库集群，其中最大的一个集群在 150 个存储节点上处理 300 万 QPS，存储超过 300TB 数据，分布在 400 万个内部分片中。得益于本文描述的技术，所有这些都实现了 99.95% 的可用性。\n\n对于其他考虑在 Kubernetes 上运行开源数据库的公司来说，机遇是巨大的。拥抱挑战，运行开源数据库以塑造这些工具以供企业使用。云中可扩展、可靠数据管理的未来在于协作和开源创新。",
      "shortSummary": "Airbnb 通过在多个 AWS 可用区内的 Kubernetes 集群上部署分布式数据库，实现了高可用性。他们利用自定义 Kubernetes 操作符、AWS EBS 进行存储和可靠性，并协调节点替换，以确保数据一致性和故障容错。这种策略使 Airbnb 的生产数据库实现了 99.95% 的可用性、低延迟、高可扩展性及更低的维护成本，证明了开源分布式存储系统在云环境中的可行性。",
      "translated_title": "Airbnb 在 Kubernetes 上通过分布式数据库实现高可用性",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*X2h18kiTtfcbRXQo",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*1hSoKkktmPABPkTj",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=58cc2e9856f4",
          "alt": "",
          "title": "",
          "position": 3
        }
      ],
      "contentSource": "RSS",
      "content": "<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*X2h18kiTtfcbRXQo\" /></figure><h3>Introduction</h3><p>Traditionally, organizations have deployed databases on costly, high-end standalone servers using sharding for scaling as a strategy. As data demands grew, the limitations of this strategy became increasingly evident with increasingly longer and more complex maintenance projects.</p><p>Increasingly distributed horizontally scalable databases are not uncommon and many of them are open source. However, running these databases reliably in the cloud with high availability, low latency and scalability, all at a reasonable cost is a problem many companies are trying to solve.</p><p>We chose an innovative strategy of deploying<strong> a distributed database cluster across multiple Kubernetes clusters in a cloud environment</strong>. Although currently an uncommon design pattern due to its complexity, this strategy allowed us to achieve target system reliability and operability.</p><p>In this post, we’ll share how we overcame challenges and the best practices we’ve developed for this strategy and we believe these best practices should be applicable to any other strongly consistent, distributed storage systems.</p><h3>Managing Databases on Kubernetes</h3><p>Earlier this year, we integrated an open source horizontally scalable, distributed SQL database into our infrastructure.</p><p>While Kubernetes is a great tool for running stateless services, the use of Kubernetes for stateful services — like databases — is challenging, particularly around node replacement and upgrades.</p><p>Since Kubernetes lacks knowledge of data distribution across nodes, each node replacement requires careful data handling to prevent data quorum loss and service disruption, this includes copying the data before replacing a node.</p><p>At Airbnb, we opted to attach storage volumes to nodes using AWS EBS, this allows quick volume reattachment to new virtual machines upon node replacement. Thanks to Kubernetes’ Persistent Volume Claims (<a href=\"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#binding\">PVC</a>), this reattachment happens automatically. In addition we need to allow time for a new storage node to catch up with the cluster’s current state before moving to the next node replacement. For this, we rely on the custom <a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/operator/\">k8s operator</a><a href=\"https://github.com/pingcap/tidb-operator\">,</a> which allows us to customize various Kubernetes operations according to specifics of the application.</p><h3>Coordinating Node Replacement</h3><p>Node replacements occur for various reasons, from <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-retirement.html\">AWS instance retirement</a> to Kubernetes upgrades or configuration changes. To address these cases, we categorize node replacement events into three groups:</p><ol><li><strong>Database-initiated events:</strong> Such as config changes or version upgrades.</li><li><strong>Proactive infrastructure events:</strong> Like instance retirements or node upgrades.</li><li><strong>Unplanned infrastructure failures:</strong> Such as a node becoming unresponsive.</li></ol><p>To safely manage node replacements for database-initiated events, we implemented a a custom check in the k8s-operator that verifies that all nodes are up and running before deleting any pod.</p><p>In order to serialize it with the second group initiated by infrastructure, we implemented <a href=\"https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/\">an admission hook</a> in k8s to intercept pod eviction. This admission hook rejects any attempt to evict the pod, but assigns a custom annotation on the pod which our customer database k8s-operator watches and acts on to safely delete the pod serializing it with any database-initiated node replacements described above.</p><p>Node replacements due to unplanned infrastructure failure events like hardware failure, can’t be coordinated. But we can still improve availability by ensuring that any node replacement event from the first two groups will be blocked until the failed hardware is replaced.</p><p>In our infrastructure the k8s operator handles both proactive and infrastructure-triggered node replacements, maintaining data consistency in the presence of node replacements and ensuring that unplanned events don’t impact ongoing maintenance.</p><h3>Kubernetes Upgrades</h3><p>Regular Kubernetes upgrades are essential but can be high-risk operations, especially for databases. Cloud managed Kubernetes might not offer rollbacks once the control plane is upgraded, posing a potential disaster recovery challenge if something goes wrong. While our approach involves using self-managed Kubernetes clusters, which does allow rolling back the control plane, a bad Kubernetes upgrade could still cause service disruption till rollback is completed.</p><h3>Ensuring Fault Tolerance with Multiple Kubernetes clusters</h3><p>At Airbnb, we think the best way to achieve high regional availability is to deploy each database across three independent Kubernetes clusters, each within a different AWS availability zone (<a href=\"https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/availability-zones.htm\">AZ</a>). AWS uses availability zones not just for independent power, networking, and connectivity, but they also do rollouts zone by zone. Our Kubernetes cluster alignment with AWS AZ also means that any underlying infrastructure issues or bad deployments have a limited blast radius as they are restricted to a single AZ. Internally, we also deploy a new configuration or a new database version to a part of the logical cluster running in a single Kubernetes cluster in one AZ first.</p><p>While this setup adds complexity, it significantly boosts availability by limiting the blast radius of any issues stemming from faulty deployments at every layer — whether database, Kubernetes, or AWS infrastructure.</p><p>For instance, recently, a faulty config deployment in our infrastructure abruptly terminated all VMs of a specific type in our staging Kubernetes cluster, deleting most of the query layer pods. However, since the disruption was isolated to a single Kubernetes cluster, two-thirds of our query layer nodes remained operational, preventing any impact.</p><p>We also overprovision our database clusters to ensure that, even if an entire AZ, Kubernetes cluster, or all storage nodes within a zone goes down, we still have sufficient capacity to handle traffic.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*1hSoKkktmPABPkTj\" /></figure><h3>Leveraging AWS EBS for Reliability and Latency Handling</h3><p>EBS offers two key benefits for our deployment: rapid reattachment during node replacements and superior durability compared to local disks. With EBS, we confidently run a highly available cluster using only three replicas, maintaining reliability without needing additional redundancy.</p><p>However, EBS can occasionally experience tail latency spikes, with p99 latency reaching up to 1 second. To mitigate this, we implemented a storage read timeout session variable, allowing queries to transparently retry against other storage nodes during EBS latency spikes. By default the database we use sends all requests and retries to the leader. To enable retries on storage nodes with healthy EBS, we have to allow reads from both leader and replica reads, but prefer the closest one for the original request. This brings the added benefit of reduced latency and no cross-AZ network costs, as we have a replica in each AZ. Finally, for use cases that permit it, we leverage stale reads feature, enabling reads to be served independently by the replica without requiring synchronous calls to the leader, which may be experiencing an EBS latency spike at the time of the read.</p><h3>Conclusion: Exploring Open Source Databases on Kubernetes</h3><p>Our journey running a distributed database on Kubernetes has empowered us to achieve high availability, low latency, scalability, and lower maintenance costs. By leveraging the operator pattern, multi-cluster deployments, AWS EBS, and stale reads, we’ve demonstrated that even open source distributed storage systems can thrive in cloud environments.</p><p>We already operate several database clusters in production in the described setup, with the largest one handling 3M QPS across 150 storage nodes, storing over 300+ TB of data spread across 4M internal shards. All this with 99.95% availability thanks to techniques described in this post.</p><p>For other companies considering to run open-source databases on Kubernetes, the opportunities are immense. Embrace the challenge, run open-source databases to shape these tools for enterprise use. The future of scalable, reliable data management in the cloud lies in collaboration and open-source innovation — now is the time to lead and participate.</p><h3>Acknowledgments</h3><p>Thanks to Abhishek Parmar, Brian Wolfe, Chen Ding, Daniel Low, Hao Luo, Xiaomou Wang for collaboration and Shylaja Ramachandra for editing.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=58cc2e9856f4\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/achieving-high-availability-with-distributed-database-on-kubernetes-at-airbnb-58cc2e9856f4\">Achieving High Availability with distributed database on Kubernetes at Airbnb</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "理解和改进 SwiftUI 性能 (原标题: Understanding and Improving SwiftUI Performance)",
      "link": "https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896?source=rss----53c7c27702d5---4",
      "pubDate": "Tue, 24 Jun 2025 16:43:07 GMT",
      "isoDate": "2025-06-24T16:43:07.000Z",
      "creator": "Cal Stephens",
      "summary": "## 理解和改进 SwiftUI 性能\n\n### 引言\n\nAirbnb 自2022年起采用 SwiftUI，显著提升了工程师的生产力。然而，大规模应用 SwiftUI 也带来了性能挑战，例如常见的低效代码模式和累积的性能损耗。为解决这些问题，Airbnb 开发了新的工具，用于主动识别和静态验证代码的正确性。\n\n### Airbnb 的 SwiftUI 功能架构\n\nAirbnb 多年来一直使用基于 UIKit 的 Epoxy 库和单向数据流系统。在 SwiftUI 屏幕层中，他们选择继续沿用现有的单向数据流库，这简化了在大型代码库中逐步采用 SwiftUI 的过程，并提高了功能质量和可维护性。然而，他们发现使用该库的 SwiftUI 功能性能未达预期，且问题原因并不明显。\n\n### 理解 SwiftUI 视图差异化（Diffing）\n\n在 SwiftUI 等声明式 UI 系统中，确保框架知道何时需要重新评估和重新渲染视图至关重要。当父视图更新时，SwiftUI 通过比较视图的存储属性来检测变化。理想情况下，视图的 `body` 仅在其属性实际改变时才会被重新评估。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*qBYJ9abMpZyuODmbHkYD5Q.jpeg)\n\n![图片 2: 理想的视图重新评估流程](https://cdn-images-1.medium.com/max/1024/1*LvNBJSor0RDThlW3Oq7mWw.png)\n\n然而，实际情况并非总是如此，不必要的视图 `body` 评估会因执行不必要的工作而损害性能。为了可视化视图 `body` 在实际应用中被重新评估的频率，Airbnb 使用了一个修饰符，每次渲染时给视图应用一个随机颜色。测试发现，许多视图被不必要地重新评估和重新渲染。\n\n![图片 3: 不必要的视图重新评估示例](https://cdn-images-1.medium.com/max/1024/1*yNrr8e8yI9RcKg6Z-VUhEA.gif)\n\n### SwiftUI 视图差异化算法\n\nSwiftUI 内置的差异化算法虽然未正式文档化，但对性能影响巨大。它使用基于反射的算法来比较视图的每个存储属性：\n\n*   **`Equatable` 类型：** SwiftUI 使用其 `Equatable` 一致性比较新旧值。\n*   **值类型（如结构体）：** 递归比较每个实例属性。\n*   **引用类型（如类）：** 使用引用标识进行比较。\n*   **闭包：** 尝试按标识比较，但大多数非简单闭包无法可靠比较。\n\n如果视图的所有属性与前一个值比较后都相等，则 `body` 不会被重新评估，内容也不会重新渲染。使用 `@State` 和 `@Environment` 等 SwiftUI 属性包装器修饰的值不参与此差异化算法，而是通过其他机制触发视图更新。\n\nAirbnb 在其代码库中发现了几种常见的模式会混淆 SwiftUI 的差异化算法：\n\n*   **闭包：** 某些类型（如闭包）本质上不受支持，几乎总是比较为不相等，导致不必要的 `body` 评估。\n*   **简单数据类型：** 存储在视图上的简单数据类型可能意外地按引用而非值进行比较，例如包装了内部引用类型的写时复制（copy-on-write）结构体。\n\n如果视图包含任何不可差异化的值，整个视图将变得不可差异化。这揭示了 Airbnb 单向数据流库的性能问题：其动作处理是基于闭包的，而 SwiftUI 无法差异化闭包。在许多情况下，使值可差异化需要大量侵入性且可能不理想的架构更改，且难以防止后续回归。\n\n### 控制 SwiftUI 视图差异化\n\n幸运的是，有另一种选择：如果视图遵循 `Equatable` 协议，SwiftUI 将使用其 `Equatable` 一致性进行差异化，而非默认的基于反射的算法。这允许开发者选择性地决定哪些属性应参与比较。例如，对于动作处理程序，如果它不影响视图内容或标识，则可以将其排除在 `Equatable` 比较之外。\n\n然而，手动编写和维护 `Equatable` 一致性会带来大量样板代码，且容易出错（例如，添加新属性时忘记更新 `Equatable`）。\n\n为此，Airbnb 创建了一个新的 **`@Equatable` 宏**，自动生成 `Equatable` 一致性。该宏会比较视图的所有存储实例属性（排除 `@State` 和 `@Environment` 等属性包装器）。不影响视图 `body` 输出且不可 `Equatable` 的属性可以使用 `@SkipEquatable` 标记，将其排除在生成的实现之外。这使得 Airbnb 可以继续使用基于闭包的动作处理程序，而不会影响 SwiftUI 的差异化过程。\n\n采用 `@Equatable` 宏后，视图保证可差异化。如果工程师后续添加了不可 `Equatable` 的属性，构建将失败，从而突出潜在的差异化行为回归。这使得 `@Equatable` 宏成为一个复杂的代码检查工具（linter），对于在大规模代码库中扩展性能改进非常有价值。\n\n### 管理视图体（View Body）大小\n\nSwiftUI 差异化的另一个重要方面是理解 SwiftUI 只能差异化真正的 `View` 结构体。任何其他代码，例如计算属性或生成 SwiftUI 视图的辅助函数，都无法被差异化。\n\n例如，将复杂的视图 `body` 拆分为单独的计算属性（如 `headerSection` 和 `actionCardSection`）是常见的组织方式，但运行时 SwiftUI 会将这些视图内联到主视图 `body` 中。这意味着，当屏幕的任何部分状态改变时，整个视图 `body` 都会被重新评估，随着视图变得更大更复杂，这将导致大量的非必要工作，损害性能。\n\n为提高性能，应将布局代码实现为独立的 SwiftUI 视图。这允许 SwiftUI 正确差异化每个子视图，仅在必要时重新评估其 `body`。例如，将 `MyScreen` 拆分为独立的 `HeaderSection` 和 `CardSection` 视图，并为它们应用 `@Equatable`，可以确保 `HeaderSection` 仅在 `title` 改变时重新评估，而 `CardSection` 仅在 `isCardSelected` 改变时重新评估。通过将视图分解为更小、可差异化的部分，SwiftUI 可以高效地仅更新实际改变的部分。\n\n### 视图体复杂度 Lint 规则\n\n大型、复杂的视图在开发过程中并不总是显而易见的。为了帮助工程师了解何时需要将视图重构为更小、可差异化的部分，Airbnb 创建了一个自定义的 SwiftLint 规则。该规则使用 SwiftSyntax 解析视图 `body` 并测量其复杂度。复杂度指标定义为每次使用计算属性、函数或闭包组合视图时增加的值。当视图复杂度超过可配置的限制（目前为10）时，该规则会在 Xcode 中自动触发警告。\n\n![图片 4: SwiftLint 视图复杂度警告示例](https://cdn-images-1.medium.com/max/1024/1*Tdo1L8qZf81FWFeJaNY6yQ.png)\n\n### 结论\n\n通过理解 SwiftUI 视图差异化机制，Airbnb 运用了三项关键技术：\n\n1.  **`@Equatable` 宏：** 确保视图 `body` 仅在视图内部的值实际改变时才被重新评估。\n2.  **拆分视图：** 将视图分解为更小的部分，以实现更快的重新评估。\n3.  **复杂度 Lint 规则：** 鼓励开发者在视图变得过大和复杂之前进行重构。\n\n将这些技术应用于 Airbnb 应用中的 SwiftUI 视图，显著减少了不必要的视图重新评估和重新渲染。例如，在搜索栏和筛选面板中，重新渲染的次数明显减少。\n\n![图片 5: 应用技术后减少重新渲染的示例](https://cdn-images-1.medium.com/max/1024/1*tWhEXK5kyFP5KYPCUSvp6Q.gif)\n\n根据页面性能评分系统的数据，在最复杂的 SwiftUI 屏幕中采用这些技术确实改善了用户体验。例如，通过在主要搜索屏幕上最重要的视图中采用 `@Equatable` 并将大型视图体拆分为更小的可差异化部分，滚动卡顿减少了15%。这些技术还提供了灵活性，允许 Airbnb 采用最适合其需求的功能架构，而不会牺牲性能或施加繁重的限制（例如，完全避免在 SwiftUI 视图中使用闭包）。\n\n当然，这些技术并非万能药，并非所有 SwiftUI 功能都必须使用它们，它们本身也不足以保证出色的性能。然而，理解它们的工作原理和原因，为构建高性能 SwiftUI 功能奠定了宝贵的基础，并使得在代码中发现和避免问题模式变得更容易。",
      "shortSummary": "Airbnb 团队为解决 SwiftUI 性能问题，主要聚焦于优化视图差异化（diffing）和管理视图体大小。他们开发了 `@Equatable` 宏，自动生成 `Equatable` 一致性，确保视图仅在关键属性变化时更新，并允许跳过不可差异化的属性（如闭包）。同时，他们提倡将大型视图拆分为更小的独立组件，并创建了 SwiftLint 规则来检测并限制视图复杂度，鼓励及时重构。这些措施显著减少了不必要的视图重新渲染，提升了应用性能，例如搜索页面滚动卡顿减少15%。",
      "translated_title": "理解和改进 SwiftUI 性能",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*qBYJ9abMpZyuODmbHkYD5Q.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*LvNBJSor0RDThlW3Oq7mWw.png",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*yNrr8e8yI9RcKg6Z-VUhEA.gif",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*Tdo1L8qZf81FWFeJaNY6yQ.png",
          "alt": "",
          "title": "",
          "position": 4
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*tWhEXK5kyFP5KYPCUSvp6Q.gif",
          "alt": "",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "RSS",
      "content": "<p>New techniques we’re using at Airbnb to improve and maintain performance of SwiftUI features at scale</p><p>By <a href=\"https://www.linkedin.com/in/calstephens/\">Cal Stephens</a>, <a href=\"https://www.linkedin.com/in/miguel-jimenez-b98216112\">Miguel Jimenez</a></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qBYJ9abMpZyuODmbHkYD5Q.jpeg\" /></figure><p>Airbnb <a href=\"https://medium.com/airbnb-engineering/unlocking-swiftui-at-airbnb-ea58f50cde49\">first adopted SwiftUI in 2022</a>, starting with individual components and later expanding to entire screens and features. We’ve seen major improvements to engineers’ productivity thanks to its declarative, flexible, and composable architecture. However, adopting SwiftUI has brought new challenges related to performance. For example, there are many common code patterns in SwiftUI that can be inefficient, and many small papercuts can add up to a large cumulative performance hit. To begin addressing some of these issues at scale, we’ve created new tooling for proactively identifying these cases and statically validating correctness.</p><h3>SwiftUI feature architecture at Airbnb</h3><p>We’ve been leveraging declarative UI patterns at Airbnb for many years, using our UIKit-based <a href=\"https://medium.com/airbnb-engineering/introducing-epoxy-for-ios-6bf062be1670\">Epoxy library</a> and <a href=\"https://medium.com/airbnb-engineering/introducing-epoxy-for-ios-6bf062be1670#fbe0\">unidirectional data flow</a> systems. When adopting SwiftUI in our screen layer, we decided to continue using our existing unidirectional data flow library. This simplified the process of incrementally adopting SwiftUI within our large codebase, and we find it improves the quality and maintainability of features.</p><p>However, we noticed that SwiftUI features using our unidirectional data flow library didn’t perform as well as we expected, and it wasn’t immediately obvious to us what the problem was. Understanding SwiftUI’s performance characteristics is an important requirement for building performant features, especially when venturing outside of the “standard” SwiftUI toolbox.</p><h3>Understanding SwiftUI view diffing</h3><p>When working with declarative UI systems like SwiftUI, it’s important to ensure the framework knows which views need to be re-evaluated and re-rendered when the state of the screen changes. Changes are detected by diffing the view’s stored properties any time its parent is updated. Ideally the view’s body will only be re-evaluated when its properties actually change:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*LvNBJSor0RDThlW3Oq7mWw.png\" /></figure><p>However, this behavior is not always the reality (more on why in a moment). Unnecessary view body evaluations hurt performance by performing unnecessary work.</p><p>How do you know how often a view’s body is re-evaluated in a real app? An easy way to visualize this is with a modifier that applies a random color to the view every time it’s rendered. When testing this on various views in our app’s most performance-sensitive screens, we quickly found that many views were re-evaluated and re-rendered more often than necessary:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*yNrr8e8yI9RcKg6Z-VUhEA.gif\" /></figure><h4>The SwiftUI view diffing algorithm</h4><p>SwiftUI’s built-in diffing algorithm is often overlooked and not officially documented, but it has a huge impact on performance. To determine if a view’s body needs to be re-evaluated, SwiftUI uses a reflection-based diffing algorithm to compare each of the view’s stored properties:</p><ol><li>If a type is <em>Equatable</em>, SwiftUI compares the old and new values using the type’s <em>Equatable</em> conformance. Otherwise:</li><li>SwiftUI compares value types (e.g., structs) by recursively comparing each instance property.</li><li>SwiftUI compares reference types (e.g., classes) using reference identity.</li><li>SwiftUI attempts to compare closures by identity. However, most closures cannot be compared reliably.</li></ol><p>If all of the view’s properties compare as equal to the previous value, then the body isn’t re-evalulated and the content isn’t re-rendered. Values using SwiftUI property wrappers like<em> @State </em>and <em>@Environment</em> don’t participate in this diffing algorithm, and instead trigger view updates through different mechanisms.</p><p>When reviewing different views in our codebase, we found several common patterns that confounded SwiftUI’s diffing algorithm:</p><ol><li>Some types are inherently not supported, like closures.</li><li>Simple data types stored on the view may be unexpectedly compared by reference instead of by value.</li></ol><p>Here’s an example SwiftUI view with properties that interact poorly with the diffing algorithm:</p><pre>struct MyView: View {<br>  /// A generated data model that is a struct with value semantics,<br>  /// but is copy-on-write and wraps an internal reference type.<br>  /// Compared by reference, not by value, which could cause unwanted body evaluations.<br>  let dataModel: CopyOnWriteDataModel<br><br>  /// Other miscellaneous properties used by the view. Typically structs, but sometimes a class.<br>  /// Unexpected comparisons by reference could cause unwanted body evaluations.<br>  let requestState: MyFeatureRequestState<br><br>  /// An action handler for this view, part of our unidirectional data flow library. <br>  /// Wraps a closure that routes the action to the screen&#39;s action handler.<br>  /// Closures almost always compare as not-equal, and typically cause unwanted body evaluations. <br>  let handler: Handler&lt;MyViewAction&gt;<br><br>  var body: some View { ... }<br>}</pre><p>If a view contains any value that isn’t diffable, the entire view becomes non-diffable. Preventing this in a scalable way is almost impossible with existing tools. This finding also reveals the performance issue caused by our unidirectional data flow library: action handling is closure-based, but SwiftUI can’t diff closures!</p><p>In some cases, like with the action handlers from our unidirectional data flow library, making the value diffable would require large, invasive, and potentially undesirable architecture changes. Even in simpler cases, this process is still time consuming, and there’s no easy way to prevent a regression from creeping in later on. This is a big obstacle when trying to improve and maintain performance at scale in large codebases with many different contributors.</p><h3>Controlling SwiftUI view diffing</h3><p>Fortunately, we have another option: If a view conforms to Equatable, SwiftUI will diff it using its Equatable conformance <em>instead</em> of using the default reflection-based diffing algorithm.</p><p>The advantage of this approach is that it lets us selectively decide which properties should be compared when diffing our view. In our case, we know that the handler object doesn’t affect the content or identity of our view. We only want our view to be re-evalulated and re-rendered when the <em>dataModel</em> and <em>requestState</em> values are updated. We can express that with a custom <em>Equatable</em> implementation:</p><pre>// An Equatable conformance that makes the above SwiftUI view diffable.<br>extension MyView: Equatable {<br>  static func ==(lhs: MyView, rhs: MyView) -&gt; Bool {<br>    lhs.dataModel == rhs.dataModel<br>      &amp;&amp; lhs.requestState == rhs.requestState<br>      // Intentionally not comparing handler, which isn&#39;t Equatable.<br>  }<br>}</pre><p>However:</p><ol><li>This is a lot of additional boilerplate for engineers to write, especially for views with lots of properties.</li><li>Writing and maintaining a custom conformance is error-prone. You can easily forget to update the <em>Equatable</em> conformance when adding new properties later, which would cause bugs.</li></ol><p>So, instead of manually writing and maintaining <em>Equatable</em> conformances, we created a new<em> @Equatable </em>macro that generates conformances for us.</p><pre>// A sample SwiftUI view that has adopted @Equatable<br>// and is now guaranteed to be diffable.<br>@Equatable<br>struct MyView: View {<br>  // Simple data types must be Equatable, or the build will fail.<br>  let dataModel: CopyOnWriteDataModel<br>  let requestState: MyFeatureRequestState<br><br>  // Types that aren&#39;t Equatable can be excluded from the<br>  // generated Equatable conformance using @SkipEquatable,<br>  // as long as they don’t affect the output of the view body.<br>  @SkipEquatable let handler: Handler&lt;MyViewAction&gt;<br><br>  var body: some View { ... }<br>}</pre><p>The <em>@Equatable</em> macro generates an <em>Equatable</em> implementation that compares all of the view’s stored instance properties, excluding properties with SwiftUI property wrappers like<em>@State </em>and <em>@Environment</em> that trigger view updates through other mechanisms. Properties that aren’t <em>Equatable</em> and don’t affect the output of the view body can be marked with <em>@SkipEquatable</em> to exclude them from the generated implementation. This allows us to continue using the closure-based action handlers from our unidirectional data flow library without impacting the SwiftUI diffing process!</p><p>After adopting the <em>@Equatable</em> macro on a view, that view is guaranteed to be diffable. If an engineer adds a non-<em>Equatable</em> property later, the build will fail, highlighting a potential regression in the diffing behavior. This effectively makes the <em>@Equatable</em> macro a sophisticated linter — which is really valuable for scaling these performance improvements in a codebase with many components and many contributors, since it makes it less likely for regressions to slip in later.</p><h3>Managing the size of view bodies</h3><p>Another essential aspect of SwiftUI diffing is understanding that SwiftUI can only diff proper View structs. Any other code, such as computed properties or helper functions that generate a SwiftUI view, cannot be diffed.</p><p>Consider the following example:</p><pre>// Complex SwiftUI views are often simplified by<br>// splitting the view body into separate computed properties.<br>struct MyScreen: View {<br>  /// The unidirectional data flow state store for this feature.<br>  @ObservedObject var store: StateStore&lt;MyState, MyAction&gt;<br><br>  var body: some View {<br>    VStack {<br>      headerSection<br>      actionCardSection<br>    }<br>  }<br><br>  private var headerSection: some View {<br>    Text(store.state.titleString)<br>      .textStyle(.title)<br>  }<br><br>  private var actionCardSection: some View {<br>    VStack {<br>      Image(store.state.cardSelected ? &quot;enabled&quot; : &quot;disabled&quot;)<br>      Text(&quot;This is a selectable card&quot;)<br>    }<br>    .strokedCard(.roundedRect_mediumCornerRadius_12)<br>    .scaleEffectButton(action: {<br>      store.handle(.cardTapped) <br>    })<br>  }<br>}</pre><p>This is a common way to organize complex view bodies, since it makes the code easier to read and maintain. However, at runtime, SwiftUI effectively inlines the views returned from the properties into the main view body, as if we instead wrote:</p><pre>// At runtime, computed properties are no different<br>// from just having a single, large view body!<br>struct MyScreen: View {<br>  @ObservedObject var store: StateStore&lt;MyState, MyAction&gt;<br><br>  // Re-evaluated every time the state of the screen is updated.<br>  var body: some View {<br>    VStack {<br>      Text(store.state.titleString)<br>        .textStyle(.title)<br><br>      VStack {<br>        Image(store.state.cardSelected ? &quot;enabled&quot; : &quot;disabled&quot;)<br>        Text(&quot;This is a selectable card&quot;)<br>      }<br>      .strokedCard(.roundedRect_mediumCornerRadius_12)<br>      .scaleEffectButton(action: {<br>        store.handle(.cardTapped) <br>      })<br>    }<br>  }<br>}</pre><p>Since all of this code is part of the same view body, all of it will be re-evaluated when any part of the screen’s state changes. While this specific example is simple, as the view grows larger and more complicated, re-evaluating it will become more expensive. Eventually there would be a large amount of unnecessary work happening on every screen update, hurting performance.</p><p>To improve performance, we can implement the layout code in separate SwiftUI views. This allows SwiftUI to properly diff each child view, only re-evaluating their bodies when necessary:</p><pre>struct MyScreen: View {<br>  @ObservedObject var store: StateStore&lt;MyState, MyAction&gt;<br><br>  var body: some View {<br>    VStack {<br>      HeaderSection(title: store.state.titleString)<br>      CardSection(<br>       isCardSelected: store.state.isCardSelected,<br>       handler: store.handler,<br>      )<br>    }<br>  }<br>}<br><br>/// Only re-evaluated and re-rendered when the title property changes.<br>@Equatable<br>struct HeaderSection: View {<br>  let title: String<br><br>  var body: some View {<br>    Text(title)<br>      .textStyle(.title)<br>  }<br>}<br><br>/// Only re-evaluated and re-rendered when the isCardSelected property changes.<br>@Equatable<br>struct CardSection: View {<br>  let isCardSelected: Bool<br>  @SkipEquatable let handler: Handler&lt;MyAction&gt;<br><br>  var body: some View {<br>    VStack {<br>      Image(store.state.isCardSelected ? &quot;enabled&quot; : &quot;disabled&quot;)<br>      Text(&quot;This is a selectable card&quot;)<br>    }<br>    .strokedCard(.roundedRect_mediumCornerRadius_12)<br>    .scaleEffectButton(action: {<br>      handler.handle(.cardTapped) <br>    })<br>  }<br>}</pre><p>By breaking the view into smaller, diffable pieces, SwiftUI can efficiently update only the parts of the view that actually changed. This approach helps maintain performance as a feature grows more complex.</p><h4>View body complexity lint rule</h4><p>Large, complex views aren’t always obvious during development. Easily available metrics like total line count aren’t a good proxy for complexity. To help engineers know when it’s time to refactor a view into smaller, diffable pieces, we created a custom <a href=\"https://github.com/realm/SwiftLint\">SwiftLint</a> rule that parses the view body using <a href=\"https://github.com/swiftlang/swift-syntax\">SwiftSyntax</a> and measures its complexity. We defined the view complexity metric as a value that increases every time you compose views using computed properties, functions, or closures. With this rule we automatically trigger an alert in Xcode when a view is getting too complex. (The complexity limit is configurable, and we currently allow a maximum complexity level of 10.)</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Tdo1L8qZf81FWFeJaNY6yQ.png\" /><figcaption>The rule shows as a warning during local Xcode builds alerting engineers as early as possible. In this screenshot, the complexity limit is set to 3, and this specific view has a complexity of 5.</figcaption></figure><h3>Conclusion</h3><p>With an understanding of how SwiftUI view diffing works, we can use an <em>@Equatable</em> macro to ensure view bodies are only re-evaluated when the values inside views actually change, break views into smaller parts for faster re-evaluation, and encourage developers to refactor views before they get too large and complex.</p><p>Applying these three techniques to SwiftUI views in our app has led to a large reduction in unnecessary view re-evaluation and re-renders. Revisiting the examples from earlier, you see far fewer re-renders in the search bar and filter panel:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*tWhEXK5kyFP5KYPCUSvp6Q.gif\" /></figure><p>Using results from our <a href=\"https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-ios-36d5f200bc73\">page performance score</a> system, we’ve found that adopting these techniques in our most complicated SwiftUI screens really does improve performance for our users. For example, we reduced <a href=\"https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-ios-36d5f200bc73#4c63\">scroll hitches</a> by<strong> </strong>15% on our main Search screen by adopting <em>@Equatable</em> on its most important views, and breaking apart large view bodies into smaller diffable pieces. These techniques also give us the flexibility to use a feature architecture that best suits our needs without compromising performance or imposing burdensome limitations (e.g., completely avoiding closures in SwiftUI views).</p><p>Of course, these techniques aren’t a silver bullet. It’s not necessary for all SwiftUI features to use them, and these techniques by themselves aren’t enough to guarantee great performance. However, understanding how and why they work serves as a valuable foundation for building performant SwiftUI features, and makes it easier to spot and avoid problematic patterns in your own code.</p><p>If you’re interested in joining us on our quest to make the best iOS app in the App Store, please see our <a href=\"https://careers.airbnb.com/\">careers</a> page for open iOS roles.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=37b77ac61896\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/understanding-and-improving-swiftui-performance-37b77ac61896\">Understanding and Improving SwiftUI Performance</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "在 Airbnb 使用 Impulse 进行负载测试 (原标题: Load Testing with Impulse at Airbnb)",
      "link": "https://medium.com/airbnb-engineering/load-testing-with-impulse-at-airbnb-f466874d03d2?source=rss----53c7c27702d5---4",
      "pubDate": "Mon, 09 Jun 2025 17:45:39 GMT",
      "isoDate": "2025-06-09T17:45:39.000Z",
      "creator": "Chenhao Yang",
      "summary": "# Airbnb 的 Impulse 负载测试实践\n\n## 引言\n系统级负载测试对于确保系统可靠性和效率至关重要，它能帮助识别瓶颈、评估峰值流量下的容量、建立性能基线并检测错误。在 Airbnb 这样规模和复杂度的公司，负载测试需要具备健壮性、灵活性和去中心化特性，以支持工程团队进行与 CI 无缝集成的自助式负载测试。\n\nImpulse 是 Airbnb 内部的“负载测试即服务”框架之一。它提供工具来生成合成负载、模拟依赖项以及从生产环境中收集流量数据。本文介绍了 Impulse 的架构，以及它如何最大限度地减少手动工作、无缝集成到可观测性堆栈中，并赋能团队主动解决潜在问题。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*3LijjQrJDLVA_ptfeRe83g.jpeg)\n\n## 架构\nImpulse 是一个全面的负载测试框架，允许服务所有者进行上下文感知的负载测试、模拟依赖项并收集流量数据，以确保系统在各种条件下的性能。它包含以下核心组件：\n\n![图片 2](https://cdn-images-1.medium.com/max/1024/1*SFDblGijyiLQfI7C5RpPXw.png)\n*图 1: Impulse 框架及其四个主要组件*\n\n1.  **负载生成器 (Load Generator)**：\n    *   用于根据合成或收集的流量，动态生成上下文感知的请求，以测试不同场景。\n    *   **上下文感知**：允许用户使用 Java 或 Kotlin 编写任意测试逻辑，并大规模启动容器来运行这些测试。选择代码而非 DSL/配置的原因在于：\n        *   **灵活性**：编程语言比 DSL 更具表达力，能更好地支持复杂的上下文场景。\n        *   **可重用性**：相同的测试代码可用于其他测试（如集成测试）。\n        *   **开发者熟练度**：学习曲线低，无需学习新的测试逻辑编写方式。\n        *   **开发者体验**：支持 IDE、测试、调试等。\n    *   **去中心化与容器化**：每次触发负载测试时，都会创建一组新的容器来运行测试，这带来了：\n        *   **隔离性**：不同服务间的负载测试相互隔离，消除干扰。\n        *   **可伸缩性**：容器数量可根据流量需求进行伸缩。\n        *   **成本效益**：容器生命周期短，仅在负载测试运行期间存在。\n    *   Impulse 的负载生成器能将工作负载均匀分布到所有数据中心，并确保总的每秒触发次数 (TPS) 符合配置，从而更好地模拟生产环境中的真实流量分布。\n    *   **执行**：设计用于在 CI/CD 流水线中自动触发。开发者可以配置多个测试阶段（如预热、稳定、峰值），每个阶段可配置测试用例、TPS 和持续时间。\n\n    ![图片 3](https://cdn-images-1.medium.com/max/977/1*WD4EWyWHDQMf_7nDIGkAuA.png)\n    *图 2: 容器化负载生成器*\n\n2.  **依赖模拟器 (Dependency Mocker)**：\n    *   用于模拟下游服务的响应，包括延迟，从而使被测服务 (SUT) 的负载测试无需涉及某些依赖服务。这对于不支持负载测试的供应商服务或在日常部署中不影响下游服务进行回归测试尤为重要。\n    *   Impulse 是一个去中心化框架，每个服务都有自己的依赖模拟器，以消除服务间的干扰并降低通信成本。\n    *   模拟器是进程外服务，独立运行，避免影响 SUT 性能。它们是短生命周期的，仅在测试运行前启动，测试结束后关闭，以节省成本和维护工作。\n    *   响应延迟和异常可配置，模拟器实例数量可按需调整以支持大量流量。\n    *   **其他值得注意的特性**：\n        *   可选择性地模拟部分依赖项，目前支持 HTTP JSON、Airbnb Thrift 和 Airbnb GraphQL 依赖。\n        *   支持负载测试之外的用例，如集成测试。\n    *   **两种模拟响应生成选项**：\n        *   **合成响应 (Synthetic response)**：由用户逻辑生成，类似于集成测试，但响应来自远程（进程外）服务器，并模拟延迟。\n        *   **重放响应 (Replay response)**：从生产下游记录中重放响应，由流量收集器组件支持。\n\n    ![图片 4](https://cdn-images-1.medium.com/max/1024/1*QXMa3Nj3-aSUE_EOvlv1xw.png)\n    *图 3: 依赖模拟器*\n\n3.  **流量收集器 (Traffic Collector)**：\n    *   旨在捕获生产环境中的上游和下游流量及其之间的关系。\n    *   通过复制下游响应（包括生产环境般的延迟和错误），Impulse 能够准确地重放生产流量进行负载测试，避免下游数据或行为的不一致。\n    *   确保测试环境中的服务行为与生产环境中的服务行为一致，从而实现更真实、更可靠的性能评估。\n\n    ![图片 5](https://cdn-images-1.medium.com/max/1024/1*EImg3JUEGzbos5r3_6U-FQ.png)\n    *图 4: 流量收集器*\n\n4.  **测试 API 生成器 (Testing API Generator)**：\n    *   解决事件驱动、异步工作流（如消息队列事件、延迟作业）的测试难题。\n    *   在 CI 阶段根据事件或作业模式创建 HTTP API。这些 API 作为底层异步流的包装器，并专门注册在测试环境中。\n    *   使负载测试工具（如负载生成器）能够向这些合成 API 发送流量，从而使异步流像同步流一样被执行。\n    *   目标是帮助开发者识别异步流实现中的性能瓶颈和潜在问题，以及在高流量条件下的表现，通过绕过消息队列等中间件组件，简化负载测试过程。\n\n    ![图片 6](https://cdn-images-1.medium.com/max/660/1*F3qllm7qqMu4N2k0bBFbdQ.png)\n    *图 5: 异步流的测试 API 生成器*\n\n## 与其他测试框架的集成\nImpulse 的模块化设计促进了其与其他内部测试框架（如集成测试和 API 测试）的集成，为系统服务测试提供了系统化的方法。\n\n![图片 7](https://cdn-images-1.medium.com/max/1024/1*649CFxbpASxHotVVbqdQkQ.png)\n*图 6: Impulse 如何与 Airbnb 其他内部测试框架交互*\n\n## 结论\nImpulse 及其四个核心组件帮助 Airbnb 的开发者进行自助式负载测试。它已在多个客户支持后端服务中实施，并获得了积极反馈，例如：它帮助识别并解决了线程池压力导致的 `ApiClientThreadToolExhaustionException`、客户端 API 调用中的偶发超时错误以及主服务容器中的高内存使用问题，从而优化了资源分配。Impulse 被高度推荐作为开发和测试流程不可或缺的一部分。",
      "shortSummary": "Airbnb 开发了 Impulse，一个内部的“负载测试即服务”框架，旨在实现健壮、灵活和去中心化的自助式负载测试。它包含负载生成器、依赖模拟器、流量收集器和测试 API 生成器四个核心组件。Impulse 能够生成上下文感知负载、模拟依赖、重放生产流量并测试异步工作流。通过与 CI/CD 无缝集成，Impulse 帮助团队主动识别并解决性能瓶颈、评估系统容量，从而提高服务可靠性和效率，并最大限度地减少手动工作。",
      "translated_title": "在 Airbnb 使用 Impulse 进行负载测试",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*3LijjQrJDLVA_ptfeRe83g.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*SFDblGijyiLQfI7C5RpPXw.png",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/977/1*WD4EWyWHDQMf_7nDIGkAuA.png",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*QXMa3Nj3-aSUE_EOvlv1xw.png",
          "alt": "",
          "title": "",
          "position": 4
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*EImg3JUEGzbos5r3_6U-FQ.png",
          "alt": "",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "RSS",
      "content": "<p>Comprehensive Load Testing with Load Generator, Dependency Mocker, Traffic Collector, and More</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3LijjQrJDLVA_ptfeRe83g.jpeg\" /></figure><p>Authors: <a href=\"https://www.linkedin.com/in/chenhao-yang-9799b022/\">Chenhao Yang</a>, <a href=\"https://www.linkedin.com/in/haoyue-wang-a722509a/\">Haoyue Wang</a>, <a href=\"https://www.linkedin.com/in/xiaoyawei/\">Xiaoya Wei</a>, <a href=\"https://www.linkedin.com/in/zhijie-guan/\">Zay Guan</a>, <a href=\"https://www.linkedin.com/in/yaolin-chen-591a31339/\">Yaolin Chen</a> and <a href=\"https://www.linkedin.com/in/fei-yuan/\">Fei Yuan</a></p><p>System-level load testing is crucial for reliability and efficiency. It identifies bottlenecks, evaluates capacity for peak traffic, establishes performance baselines, and detects errors. At a company of Airbnb’s size and complexity, we’ve learned that load testing needs to be robust, flexible, and decentralized. This requires the right set of tools to enable engineering teams to do self-service load tests that integrate seamlessly with CI.</p><p>Impulse is one of our internal load-testing-as-a-service frameworks. It provides tools that can generate synthetic loads, mock dependencies, and collect traffic data from production environments. In this blog post, we’ll share how Impulse is architected to minimize manual effort, seamlessly integrate with our observability stack, and empower teams to proactively address potential issues.</p><h3>Architecture</h3><p>Impulse is a comprehensive load testing framework that allows service owners to conduct context-aware load tests, mock dependencies, and collect traffic data to ensure the system’s performance under various conditions. It includes the following components:</p><ol><li><strong>Load generator</strong> to generate context-aware requests on the fly, for testing different scenarios with synthetic or collected traffic.</li><li><strong>Dependency mocker</strong> to mock the downstream responses with latency, so that the load testing on the service under test (SUT) doesn’t need to involve certain dependent services. This is especially crucial when the dependencies are vendor services that don’t support load testing, or if the team wants to regression load test their service during day-to-day deployment without affecting downstreams.</li><li><strong>Traffic collector</strong> to collect both the upstream and downstream traffic from the production environment, and then apply the resulting data to the test environment.</li><li><strong>Testing API generator</strong> to wrap asynchronous workflows into synchronous API calls for load testing.</li></ol><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*SFDblGijyiLQfI7C5RpPXw.png\" /><figcaption>Figure 1: The Impulse framework and its four main components</figcaption></figure><p>Each of these four tools are independent, allowing service owners the flexibility to select one or more components for their load testing needs.</p><h4>Load generator</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/977/1*WD4EWyWHDQMf_7nDIGkAuA.png\" /><figcaption>Figure 2: Containerized load generator</figcaption></figure><p><em>Context aware</em></p><p>When load testing, requests made to the SUT often require some information from the previous response or need to be sent in a specific order. For example, if an update API needs to provide an <em>entity_id</em> to update, we must ensure the entity already exists in the testing environment context.</p><p>Our load generator tool allows users to write arbitrary testing logic in Java or Kotlin and launch containers to run these tests at scale against the SUT. Why write code instead of DSL/configuration logic?</p><ul><li>Flexibility: Programming languages are more expressive than DSL and can better support complex contextual scenarios.</li><li>Reusability: The same testing code can be used in other tests, e.g., integration tests.</li><li>Developer proficiency: Low/no learning curve to onboard, don’t need to learn how to write testing logic.</li><li>Developer experience: IDE support, testing, debugging, etc.</li></ul><p>Here is an example of synthetic context-aware test case:</p><pre>class HelloWorldLoadGenerator : LoadGenerator {<br>   override suspend fun run() {<br>       val createdEntity = sutApiClient.create(CreateRequest(name=&quot;foo&quot;, ...)).data<br><br>       // request with id from previous response (context)<br>       val updateResponse = sutApiClient.update(UpdateRequest(id=createdEntity.id, name=&quot;bar&quot;))<br>       <br>       // ... other operations<br>       <br>       // clean up<br>       sutApiClient.delete(DeleteRequest(id=createdEntity.id))<br>   }<br>}</pre><p><em>Decentralized</em></p><p>The load generator is decentralized and containerized, which means each time a load test is triggered, a set of new containers will be created to run the test. This design has several benefits:</p><ul><li>Isolation: Load testing runs between different services are isolated from each other, eliminating any interference.</li><li>Scalability: The number of containers can be scaled up or down according to the traffic requirements.</li><li>Cost efficiency: The containers are short-lived, as they only exist during the load testing run.</li></ul><p>What’s more, as our services are cloud based, a subtle point is that the Impulse framework will evenly distribute the workers among all our data centers, and the load will be emitted evenly from all the workers. Impulse’s load generator ensures the overall trigger per second (TPS) is as configured. Based on this, we can better leverage the locality settings in load balancers, which can better mimic the real traffic distribution in production.</p><p><em>Execution</em></p><p>The load generator is designed to be executed in the CI/CD pipeline, which means we can trigger load testing automatically. Developers can configure the testing spec in multiple phases, e.g., a warm up phase, a steady state phase, a peak phase, etc. Each phase can be configured with:</p><ul><li>Test cases to run</li><li>TPS (trigger per second) of each test case</li><li>Test duration</li></ul><h4>Dependency mocker</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QXMa3Nj3-aSUE_EOvlv1xw.png\" /><figcaption>Figure 3: Dependency mocker</figcaption></figure><p>Impulse is a decentralized framework where each service has its own dependency mocker. This can eliminate interference between services and reduce communication costs. Each dependency mocker is an out-of-process service, which means the SUT behaves just as it does in production. We run the mockers in separate instances to avoid any impact on the performance of the SUT. The mock servers are all short lived — they only start before tests run and shut down afterwards to save costs and maintenance effort. The response latency and exceptions are configurable and the number of mocker instances can be adjusted on demand to support large amounts of traffic.</p><p>Other noteworthy features:</p><ul><li>You can selectively stub some of the dependencies. Currently, stubbing is supported for HTTP JSON, Airbnb Thrift, and Airbnb GraphQL dependencies.</li><li>The dependency mockers support use cases beyond load testing. For instance, integration tests often rely on other services or third-party API calls, which may not guarantee a stable testing environment or might only support ideal scenarios. Dependency mockers can address this by offering predefined responses or exceptions to fully test those flows.</li></ul><p>Impulse supports two options for generating mock responses:</p><ol><li>Synthetic response: The response is generated by user logic, as in integration testing; the difference is that the response comes from a remote (out-of-process) server with simulated latency.<br>- Similar to the load generator, the logic is written in Java/Kotlin code and contains request matching and response generation.<br>- Latency can be simulated using p95/p99 metrics.</li><li>Replay response: The response is replayed from the production downstream recording, supported by the traffic collector component.</li></ol><p>Here is an example of a synthetic response with latency in Kotlin:</p><pre>downstreamsMocking.every(<br>      thriftRequest&lt;FooRequest&gt;().having { it.message == &quot;hello&quot; }<br>    ).returns { request -&gt;<br>      ThriftDownstream.Response.thriftEncoded(<br>        HttpStatus.OK,<br>        FooResponse.builder.reply(&quot;${request.message} world&quot;).build()<br>      )<br>    }.with {<br>      delay = latencyFromP95(p95=500.miliseconds, min=200.miliseconds, max=2000.miliseconds)<br>    }</pre><h4>Traffic collector</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*EImg3JUEGzbos5r3_6U-FQ.png\" /><figcaption>Figure 4: Traffic collector</figcaption></figure><p>The traffic collector component is designed to capture both upstream and downstream traffic, along with the relationships between them. This approach allows Impulse to accurately replay production traffic during load testing, avoiding inconsistencies in downstream data or behavior. By replicating downstream responses — including production-like latency and errors — via the dependency mocker, the system ensures high-fidelity load testing. As a result, services in the testing environment behave identically to those in production, enabling more realistic and reliable performance evaluations.</p><h4>Testing API generator</h4><p>We rely heavily on event-driven, asynchronous workflows that are critical to our business operations. These include processing events from a message queue (MQ) and executing delayed jobs. Most of the MQ events/jobs are emitted from synchronous flows (e.g., API calls), so theoretically they can be covered by API load testing. However, the real world is more complex. These asynchronous flows often involve long chains of event and job emissions originating from various sources, making it difficult to replicate and test them accurately using only API-based methods.</p><p>To address this, the testing API generator component creates HTTP APIs during the CI stage according to the event or job schema. These APIs act as wrappers around the underlying asynchronous flows and are registered exclusively in the testing environment. This setup enables load testing tools — such as load generators — to send traffic to these synthetic APIs, allowing asynchronous flows to be exercised as if they were synchronous. As a result, it’s possible to perform targeted, realistic load testing on asynchronous logic that would otherwise be hard to simulate.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/660/1*F3qllm7qqMu4N2k0bBFbdQ.png\" /><figcaption>Figure 5: Testing API generator for async flows</figcaption></figure><p>The goal of the testing API generator is to help developers identify performance bottlenecks and potential issues in their async flow implementations and under high traffic conditions. It does this by enabling direct load testing of async flows without involving middleware components like MQs. The rationale is that developers typically aim to evaluate the behavior of their own logic, not the middleware, which is usually already well-tested. By bypassing these components, this approach simplifies the load testing process and empowers developers to independently manage and execute their own tests.</p><h4>Integration with other testing frameworks</h4><p>Airbnb emphasizes product quality, utilizing versatile testing frameworks that cover integration and API tests across development, staging, and production environments, and integrate smoothly into CI/CD pipelines. The modular design of Impulse facilitates its integration with these frameworks, offering systematic service testing.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*649CFxbpASxHotVVbqdQkQ.png\" /><figcaption>Figure 6: How Impulse interfaces with other internal testing frameworks</figcaption></figure><h3>Conclusion</h3><p>In this blog post, we shared how Impulse and its four core components help developers perform self-service load testing at Airbnb. As of this writing, Impulse has been implemented in several customer support backend services and is currently under review with different teams across the company who are planning to leverage Impulse to conduct load testing.</p><p>We’ve received a lot of good feedback in the process. For example: “<em>Impulse helps us to identify and address potential issues in our service. During testing, it detected an ApiClientThreadToolExhaustionException caused by thread pool pressure. Additionally, it alerted us about occasional timeout errors in client API calls during service deployments. Impulse helped us identify high memory usage in the main service container, enabling us to fine-tune the memory allocation and optimize our service’s resource usage. Highly recommend utilizing Impulse as an integral part of the development and testing processes.</em>”</p><h3>Acknowledgments</h3><p>Thanks to Jeremy Werner, Yashar Mehdad, Raj Rajagopal, Claire Cheng, Tim L., Wei Ji, Jay Wu, Brian Wallace for support on the Impulse project.</p><p>Does this type of work interest you? Check out our open roles <a href=\"https://careers.airbnb.com/\">here</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f466874d03d2\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/load-testing-with-impulse-at-airbnb-f466874d03d2\">Load Testing with Impulse at Airbnb</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    },
    {
      "title": "大规模倾听、学习与帮助：机器学习如何改变爱彼迎的语音支持体验 (原标题: Listening, Learning, and Helping at Scale: How Machine Learning Transforms Airbnb’s Voice Support…)",
      "link": "https://medium.com/airbnb-engineering/listening-learning-and-helping-at-scale-how-machine-learning-transforms-airbnbs-voice-support-b71f912d4760?source=rss----53c7c27702d5---4",
      "pubDate": "Thu, 29 May 2025 17:29:46 GMT",
      "isoDate": "2025-05-29T17:29:46.000Z",
      "creator": "Yuanpei Cao",
      "summary": "# 大规模倾听、学习与帮助：机器学习如何改变爱彼迎的语音支持体验\n\n爱彼迎致力于提供流畅、直观且有帮助的社区支持体验，无论是协助房客处理预订变更，还是帮助房东解决房源问题。尽管帮助中心和客服聊天机器人能高效解决许多咨询，但部分用户更倾向于与支持代表进行即时语音对话。为了使这些互动更快、更有效，爱彼迎通过机器学习显著改进了其交互式语音应答（IVR）系统。\n\n## 重新构想语音支持旅程\n\n传统的IVR系统通常依赖于僵硬的菜单树，要求呼叫者按键并导航预设路径。爱彼迎设计了一个自适应、会话式的IVR系统，能够实时倾听、理解和响应。当呼叫者联系爱彼迎支持时，通常会发生以下流程：\n\n1.  **呼叫与问候**：IVR接听并提示：“请用几句话告诉我您今天致电的原因。”\n2.  **自动语音识别（ASR）**：呼叫者的回答通过爱彼迎专用的ASR系统转录成文本，保留关键的领域特定术语。\n3.  **理解意图**：一个“联系原因检测”模型将问题分类为取消、退款、账户问题等类别。\n4.  **决策制定**：\n    *   如果可以自助服务，系统会通过短信或应用通知发送相关的帮助文章或智能工作流程。\n    *   如果呼叫者明确请求代理支持或问题需要人工干预，呼叫将路由到客户支持代理，并附带相关详细信息。\n5.  **澄清响应**：一个“释义模型”生成用户意图的摘要，IVR在提供解决方案之前与用户分享。这确保用户理解他们收到的资源的上下文。\n6.  **解决或升级**：呼叫者收到包含相关爱彼迎帮助中心文章链接的短信或应用通知。如果需要进一步帮助，他们可以按0连接客户服务代表。\n\n通过从僵硬的菜单转向自然语言理解，爱彼迎允许房客和房东用自己的话表达问题，从而提高满意度和解决效率。\n\n![爱彼迎IVR核心服务与机器学习组件交互的高级架构](https://cdn-images-1.medium.com/max/1024/1*4MMPeZJDlFDELNNSZ8dGPA.png)\n*图1：爱彼迎IVR核心服务如何与核心机器学习组件交互以通过电话解决用户问题的高级架构。*\n\n## 机器学习驱动的IVR系统核心组件\n\n爱彼迎的IVR系统由以下关键机器学习组件驱动：\n\n### 1. 自动语音识别（ASR）：精准转录\n\n在语音驱动的支持系统中，实现高转录准确性至关重要，尤其是在嘈杂的电话环境中。通用语音识别模型在处理爱彼迎特定术语时常遇到困难。为了提高ASR准确性，爱彼迎：\n\n*   从通用预训练模型转向专门为嘈杂电话音频调整的模型。\n*   引入了领域特定短语列表优化，确保爱彼迎术语被正确识别。\n*   结果：词错误率（WER）从33%显著降低到约10%。这提高了下游帮助文章推荐的准确性，增加了用户参与度，改善了与ASR菜单交互用户的客户NPS，同时减少了对人工代理的依赖并缩短了客户服务处理时间。\n\n### 2. 联系原因预测：理解“为什么”\n\n转录呼叫者陈述后，下一步是识别其意图。爱彼迎通过创建详细的“联系原因分类法”来实现这一点，该分类法涵盖了所有潜在的爱彼迎咨询。一个意图检测模型将呼叫分类到相应的“联系原因”类别。\n\n*   **部署**：在生产环境中，爱彼迎部署了“问题检测服务”来托管意图检测模型，并行运行以实现最佳的可扩展性、灵活性和效率。平均意图检测延迟保持在50毫秒以下，确保了无缝的实时体验。\n*   **特殊情况**：对于呼叫者明确要求与人工代理通话的情况，系统使用不同的意图检测模型来识别此意图，并将呼叫路由到合适的团队。\n\n![意图检测架构和问题检测服务](https://cdn-images-1.medium.com/max/1024/0*oj7NCOlBGYOnNBOx)\n*图2：意图检测架构和问题检测服务。*\n\n### 3. 帮助文章检索：提供正确信息\n\n许多常见的爱彼迎问题可以通过提供清晰、相关的教育信息快速解决。爱彼迎使用“帮助文章检索和排名系统”来自动识别用户查询中的问题，并通过短信和爱彼迎应用通知发送最相关的帮助文章链接。该过程包含两个机器学习阶段：\n\n*   **语义检索和排名**：将爱彼迎帮助文章嵌入索引到向量数据库中，使用余弦相似度高效检索多达30篇相关文章（通常在60毫秒内）。一个基于LLM的排名模型随后对这些检索到的文章进行重新排名，将排名最高的文章直接呈现给用户。\n*   **效果**：该双阶段系统不仅支持IVR互动，还支持客户支持聊天机器人和帮助中心搜索。其有效性通过Precision@N等指标持续评估。\n\n![帮助文章检索和排名系统架构图](https://cdn-images-1.medium.com/max/1024/1*wlkl-CT0czyGqNdKx-ffIw.png)\n*图3：帮助文章检索和排名系统架构图。*\n\n### 4. 释义模型：增强用户理解\n\nIVR客户支持的一个关键挑战是确保用户在接收帮助文章链接之前清楚理解解决方案。为了解决这个问题，爱彼迎实施了一种轻量级的释义方法，利用一组精选的标准化摘要。\n\n*   **实现**：UX撰稿人创建了常见爱彼迎场景的简洁明了的释义。在线服务时，用户查询通过基于文本嵌入相似度的最近邻匹配映射到这些精选摘要。\n*   **效果**：手动评估端到端模型输出证实精度超过90%。在针对联系客户支持的英语房东进行的实验中，在发送文章链接前呈现释义摘要增加了用户对文章内容的参与度，从而提高了自助解决率，减少了对直接客户支持协助的需求。\n\n## 结论\n\n通过结合自动语音识别、联系原因检测系统、帮助文章检索系统和释义模型，爱彼迎创建了一个IVR系统，该系统简化了支持互动并提高了用户满意度。该解决方案使呼叫者能够自然地描述问题，减少了常见查询对人工代理的依赖，并通过自助服务提供即时、相关的支持。当需要人工协助时，系统通过将用户路由到合适的代理并提供必要的上下文，确保了平稳的过渡。\n\n![图片 1](https://cdn-images-1.medium.com/max/1024/1*zyT9hDwGkSCvZ-wKEx669w.jpeg)",
      "shortSummary": "爱彼迎利用机器学习彻底改造其语音支持（IVR）系统。通过智能IVR，用户可以自然表达问题，系统通过自动语音识别（ASR）、意图检测、帮助文章检索和释义模型提供自助服务或智能路由。这显著提高了支持效率和用户满意度，减少了对人工代理的依赖，并确保了需要时与合适代理的无缝连接。",
      "translated_title": "大规模倾听、学习与帮助：机器学习如何改变爱彼迎的语音支持体验",
      "images": [
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*zyT9hDwGkSCvZ-wKEx669w.jpeg",
          "alt": "",
          "title": "",
          "position": 1
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*4MMPeZJDlFDELNNSZ8dGPA.png",
          "alt": "",
          "title": "",
          "position": 2
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/0*oj7NCOlBGYOnNBOx",
          "alt": "",
          "title": "",
          "position": 3
        },
        {
          "url": "https://cdn-images-1.medium.com/max/1024/1*wlkl-CT0czyGqNdKx-ffIw.png",
          "alt": "",
          "title": "",
          "position": 4
        },
        {
          "url": "https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b71f912d4760",
          "alt": "",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "RSS",
      "content": "<h3><strong>Listening, Learning, and Helping at Scale: How Machine Learning Transforms Airbnb’s Voice Support Experience</strong></h3><p>A look into how Airbnb uses speech recognition, intent detection, and language models to understand users and assist agents more effectively.</p><p><em>By </em><a href=\"https://www.linkedin.com/in/yuanpei-cao-792b103b/\"><em>Yuanpei Cao</em></a><em>, </em><a href=\"https://www.linkedin.com/in/heng-j-1a44a711/\"><em>H</em>eng Ji</a><em>, </em><a href=\"https://www.linkedin.com/in/elaineliu5/\"><em>Elaine Liu</em></a><em>, </em><a href=\"https://www.linkedin.com/in/peng-wang-13117371/\"><em>Peng Wang</em></a><em>, and </em><a href=\"https://www.linkedin.com/in/tiantian-zhang-a4208726/\"><em>Tiantian Zhang</em></a></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zyT9hDwGkSCvZ-wKEx669w.jpeg\" /></figure><p>At Airbnb, we aim to provide a smooth, intuitive, and helpful community support experience, whether it’s helping a guest navigate a booking change or helping a host with a listing issue. While our Help Center and customer support chatbot helps resolve many inquiries efficiently, some users prefer the immediacy of a voice conversation with a support representative. To make these interactions faster and more effective, we’ve significantly improved our Interactive Voice Response (IVR) system via machine learning.</p><p>Over the years, Airbnb has invested in conversational AI to enhance customer support. In our previous blog posts <a href=\"https://medium.com/airbnb-engineering/task-oriented-conversational-ai-in-airbnb-customer-support-5ebf49169eaa\"><em>Task-Oriented Conversational AI in Airbnb Customer Support</em></a> and<a href=\"https://medium.com/airbnb-engineering/using-chatbots-to-provide-faster-covid-19-community-support-567c97c5c1c9\"> <em>Using Chatbots to Provide Faster COVID-19 Community Support</em></a>, we explored how AI-driven chatbots streamline guest and host interactions through automated messaging. This post explains how we extend that work to voice-based support, leveraging machine learning to improve real-time phone interactions with our intelligent IVR system.</p><p>We’ll take you through the end-to-end IVR journey, the key machine learning components that power it, and how we designed a system that delivers faster, more human-like, and more intuitive voice support for our community.</p><h3>Reimagining the voice support journey</h3><p>Traditional IVR systems often rely on rigid menu trees, requiring callers to press buttons and navigate pre-set paths. Instead, we designed an adaptive, conversational IVR that listens, understands, and responds in real time. Here’s normally what happens when a caller reaches out to Airbnb support:</p><ol><li><strong>Call and greeting: </strong>IVR picks up and prompts, <em>“In a few sentences, please tell us why you’re calling today.”</em></li><li><strong>Automated speech recognition (ASR):</strong> The caller’s response is transcribed with Airbnb-specific ASR. For example, if a caller says, <em>“I need to request a refund for my reservation,”</em> ASR accurately converts this speech into text, preserving key domain-specific terms.</li><li><strong>Understanding intent:</strong> A Contact Reason Detection model classifies the issue into a category like cancellations, refunds, account issues, etc.</li><li><strong>Decision-making:</strong> If self-service is possible, the system retrieves and sends a relevant help article or an intelligent workflow via SMS or app notification. If the caller explicitly requests agent support or the issue requires human intervention, the call is routed to a customer support agent with relevant details attached.</li><li><strong>Clarifying response:</strong> A Paraphrasing model generates a summary of the user intent, which IVR shares with the user before delivering the solution. This ensures that users understand the context of the resource they receive. Continuing our example, the system would respond, “<em>I understand your issue is regarding a refund request.</em> <em>We have sent you a link to resources about this topic. Follow the instructions to find answers. If you need to speak with an agent, press 0 to be connected to our customer service representative.</em>” The underscored Paraphrasing component enhances engagement by bridging the gap between system-generated responses and user comprehension, making the self-service experience more intuitive.</li><li><strong>Resolution or escalation:</strong> The caller receives an SMS or app notification with a direct link to a relevant <a href=\"https://www.airbnb.com/help\">Airbnb Help Center</a> article. If further assistance is needed, they can press 0 to connect with a customer service representative.</li></ol><p>By moving away from rigid menus to natural language understanding, we allow guests and hosts to express their issues in their own words, helping to increase satisfaction and resolution efficiency.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*BNyYIWtMRorDGJ935DcQJw.png\" /><figcaption>Figure 1: High-level architecture of how Airbnb IVR Core Service interacts with core machine learning components to resolve user issues over the phone.</figcaption></figure><h3>Breaking down our ML-powered IVR system</h3><h4>1. Automated speech recognition (ASR): transcribing with precision</h4><p>In a voice-driven support system, achieving high transcription accuracy is essential, particularly in noisy phone environments where speech can be unclear. General speech recognition models often struggle with Airbnb-specific terminology, leading to errors like misinterpreting “listing” as “lifting” or “help with my stay” as “happy Christmas Day.” These inaccuracies create challenges in understanding user intent and impact downstream processes.</p><p>To enhance ASR accuracy, we transitioned from a generic high-quality pretrained model to one specifically adapted for noisy phone audio. Additionally, we introduced a domain-specific phrase list optimization that ensures Airbnb terms are properly recognized. Based on a sample of hundreds of clips, this significantly <strong>reduced the word error rate (WER) from 33% to approximately 10%</strong>. The reduced WER significantly enhanced the accuracy of downstream help article recommendations, increasing user engagement, improving customer NPS among users who interacted with the ASR menu, while reducing reliance on human agents and lowering customer service handling time.</p><h4>2. Contact Reason prediction: understanding the why</h4><p>After transcribing the caller’s statements, the next step involves identifying their intent. We accomplished this by creating a detailed Contact Reason taxonomy that categorizes all potential Airbnb inquiries, as elaborated in “<a href=\"https://medium.com/airbnb-engineering/t-leaf-taxonomy-learning-and-evaluation-framework-30ae19ce8c52\">T-LEAF: Taxonomy Learning and EvaluAtion Framework</a>.” We then use an intent detection model to classify calls into a Contact Reason category, ensuring each inquiry is handled appropriately. For example, if a caller mentions “I haven’t received my refund yet,” the model predicts the Contact Reason as Missing Refund and forwards it to the relevant downstream components.</p><p>In production, we deploy the Issue Detection Service to host the intent detection models, running them in parallel to achieve optimal scalability, flexibility, and efficiency. Parallel computing ensures that intent detection <strong>latency remains under 50ms on average</strong>, making the process imperceptible to IVR users and ensuring a seamless real-time experience. The detected intent is then analyzed within the IVR workflow to determine the next action, whether it’s guiding the user through a self-service resolution or escalating directly to a human agent.</p><p>Occasionally, callers prefer to speak directly with a human agent instead of describing their issues, using terms like “agent” or “escalation.” For such scenarios, we use a different intent detection model to recognize when a caller wants to escalate to a human agent. If this intent is detected, the IVR system honors the caller’s request and routes the call to the suitable support team.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Q7LxFhZitCrNdqKAy_ffOw.png\" /><figcaption>Figure 2. Intent detection architecture and Issue Detection Service.</figcaption></figure><h4>3. Help article retrieval: delivering the right information</h4><p>Many common Airbnb issues can be quickly resolved by providing clear and relevant educational information. To help provide useful information to users and minimize the need for human customer support, we use the Help Article Retrieval and Ranking system. This advanced system automatically identifies the issue in a user’s inquiry and delivers the most relevant help article link via SMS text message and Airbnb app notification. Our process incorporates two machine learning stages.</p><p><strong>Semantic retrieval and ranking:</strong> We index Airbnb Help Article embeddings into a vector database, enabling efficient retrieval of up to 30 relevant articles per user query using cosine similarity, typically within 60ms. An LLM-based ranking model then re-ranks these retrieved articles, with the top-ranked article directly presented to users via IVR channels. This dual-stage system not only powers IVR interactions but also supports our customer support chatbot and Help Center search. Across these platforms, its effectiveness is continuously evaluated using metrics like Precision@N, facilitating ongoing improvements and refinements.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wlkl-CT0czyGqNdKx-ffIw.png\" /><figcaption>Figure 3. Architecture diagram for the Help Article Retrieval and Ranking system.</figcaption></figure><h4>4. Paraphrasing model: enhancing user understanding</h4><p>A key challenge in IVR-based customer support is ensuring users clearly understand the resolution before receiving help article links, as they typically lack visibility into the article’s contents or title. To address this, we implemented a lightweight paraphrasing approach leveraging a curated set of standardized summaries.</p><p>UX writers created concise and clear paraphrases for common Airbnb scenarios. During online serving, user inquiries are mapped to these curated summaries via nearest-neighbor matching based on text embedding similarity. We calibrated a similarity threshold to ensure high-quality matches. Manual evaluation of end-to-end model outputs confirmed precision exceeding 90%.</p><p>The outcome was a finite-state solution delivering the most appropriate paraphrased IVR prompt before presenting a help article link. For example, if a caller states, “I need to cancel my reservation and request a refund,” the model generates a response like “I understand your issue is about a refund request” before sending the retrieved help article link.</p><p>Integrating this model ensures users receive clear, contextually relevant summaries prior to accessing help articles. In an experiment targeting English hosts who contacted customer support, we found that presenting a paraphrased summary before sending the article link increases user engagement with article content, resulting in improvement in self-resolution rates, helping to reduce the need for direct customer support assistance.</p><h3>Conclusion</h3><p>By combining Automated Speech Recognition and Contact Reason Detection systems with a help article retrieval system, and a paraphrasing model, we have created an IVR system that streamlines support interactions and improves user satisfaction. Our solution enables callers to describe issues naturally, reduces dependency on human agents for common inquiries, and provides instant, relevant support through self-service. When human assistance is necessary, the system ensures a smooth transition by routing users to the right agent with essential context.</p><p>Interested in working at Airbnb? Check out our <a href=\"https://careers.airbnb.com/\">open roles</a>.</p><h3><strong>Acknowledgements</strong></h3><p>Thanks to Zhenyu Zhao, Mia Zhao, Wayne Zhang, Lucca Siaudzionis, Lulu Chen, Sukey Xu, Floria Wan, Michael Zhou, Can Yang, Yaolin Chen, Shuaihu Wang, Huifan Qu, Ming Shang,Yu Jiang, Wanting Chen, Elena Zhao, Shanna Su, Cassie Cao, Hao Wang, Haoran Zhu, Xirui Liu, Ying Tan, Xiaohan Zeng, Xiaoyu Meng, Gavin Li, Gaurav Rai, Hemanth Kolla, Ihor Hordiienko, Matheus Scharf, and Stepan Sydoruk who helped bring this vision to life. Also thanks to Paige Schwartz, Stephanie Chu, Neal Cohen, Becky Ajuonuma, Iman Saleh, Dani Normanm, Javier Salido, and Lauren Mackevich for the review and editing.</p><p>Thanks to Jeremy Werner, Joy Zhang, Claire Cheng, Yashar Mehdad, Shuohao Zhang, Shawn Yan, Kelvin Xiong, Michael Lubavin, Teng Wang, Wei Ji, and Chenhao Yang’s leadership support on building conversational AI products at Airbnb.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b71f912d4760\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/airbnb-engineering/listening-learning-and-helping-at-scale-how-machine-learning-transforms-airbnbs-voice-support-b71f912d4760\">Listening, Learning, and Helping at Scale: How Machine Learning Transforms Airbnb’s Voice Support…</a> was originally published in <a href=\"https://medium.com/airbnb-engineering\">The Airbnb Tech Blog</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"
    }
  ],
  "lastUpdated": "2025-10-15T04:33:34.271Z"
}