{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "GitHub 2025年6月可用性报告 (原标题: GitHub Availability Report: June 2025)",
      "link": "https://github.blog/news-insights/company-news/github-availability-report-june-2025/",
      "pubDate": "Wed, 16 Jul 2025 21:06:17 +0000",
      "isoDate": "2025-07-16T21:06:17.000Z",
      "creator": "Jakub Oleksy",
      "summary": "## GitHub 2025年6月可用性报告\n\n在2025年6月，GitHub服务共经历了三次导致性能下降的事件。\n\n### 事件一：2025年6月5日 (UTC时间 17:47 - 19:20，持续1小时33分钟)\n\n*   **受影响服务：** Actions\n*   **影响：**\n    *   47.2%的运行启动延迟，平均延迟14分钟。\n    *   21.0%的运行失败。\n    *   60%的Copilot Coding Agent会话被取消。\n    *   所有使用分支构建的Pages站点部署失败（Pages服务本身不受影响）。\n*   **原因：** 内部Actions服务之间负载激增，暴露出配置错误，导致运行启动关键路径中的请求被限流。\n*   **缓解措施：** 纠正服务配置以防止限流，并更新部署流程以确保正确配置得以保留。\n\n### 事件二：2025年6月12日 (UTC时间 17:55 - 21:07，持续3小时12分钟)\n\n*   **受影响服务：** GitHub Copilot\n*   **影响：**\n    *   Gemini模型不可用，Claude模型可用性降低。\n    *   VS Code、JetBrains IDEs和GitHub Copilot Chat中，聊天完成错误率显著升高，响应时间变慢，出现超时和聊天功能中断。\n*   **原因：** 影响其中一个模型提供商的故障。\n*   **缓解措施：** 暂时禁用受影响的提供商端点以减少用户影响。GitHub正在更新基础设施提供商故障的事件响应手册，并改进监控和警报系统，以减少未来此类问题的检测和缓解时间。\n\n### 事件三：2025年6月17日 (UTC时间 19:32 - 20:03，持续31分钟)\n\n*   **受影响服务：** 内部路由策略部署\n*   **影响：** 导致数据中心内部分网络地址块的可达性问题。\n    *   github.com UI（已认证用户）：3-4%的错误率。\n    *   API（已认证调用者）：40%的错误率。\n    *   UI和API（未认证请求）：接近100%的错误率。\n    *   Actions：2.5%的运行延迟（平均8分钟），3%的运行失败。\n    *   大文件存储（LFS）请求：1%的错误。\n*   **原因：** 向部分网络设备部署内部路由策略。\n*   **缓解措施：** 于19:54 UTC回滚部署，受影响系统的网络可用性恢复。20:03 UTC完全恢复正常运行。GitHub正在扩展路由策略更改的验证流程，以防止类似问题。\n\n### 更多信息\n\n*   请关注GitHub状态页面获取实时更新和事件回顾。\n*   访问GitHub工程博客了解更多工作进展。\n\n### 相关内容\n\n*   **Docs**：掌握GitHub所需的一切。\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n*   **GitHub**：在GitHub上构建未来。\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n*   **Customer stories**：了解使用GitHub进行构建的公司和工程团队。\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n*   **GitHub Universe 2025**：参加10月28-29日在旧金山举行的Universe大会。\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)",
      "shortSummary": "GitHub在2025年6月经历了三次服务降级事件。6月5日，Actions服务因配置错误导致运行延迟和失败。6月12日，GitHub Copilot因模型提供商故障导致服务中断和错误率升高。6月17日，内部路由策略部署引发网络可达性问题，影响了UI、API和Actions。GitHub已采取措施纠正问题，并计划改进配置管理、事件响应和验证流程，以防止未来再次发生类似事件。",
      "translated_title": "GitHub 2025年6月可用性报告",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 4
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>In June, we experienced three incidents that resulted in degraded performance across GitHub services.</p>\n<p>The post <a href=\"https://github.blog/news-insights/company-news/github-availability-report-june-2025/\">GitHub Availability Report: June 2025</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何在攻击者之前捕获 GitHub Actions 工作流注入 (原标题: How to catch GitHub Actions workflow injections before attackers do)",
      "link": "https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/",
      "pubDate": "Wed, 16 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-16T16:00:00.000Z",
      "creator": "Dylan Birtolo",
      "summary": "# 如何在攻击者之前捕获 GitHub Actions 工作流注入\n\n在代码开发和项目维护中，安全性至关重要，并且从项目初期就考虑安全比后期修补要容易得多。GitHub Actions 工作流注入是 GitHub 仓库中最常见的漏洞之一，但幸运的是，它相对容易解决，GitHub 也提供了相关工具。\n\n![CodeQL 在 2024 年发现的最常见漏洞类型条形图。从多到少依次为：注入、访问控制失效、不安全设计、加密失败、身份识别与认证失败、安全配置错误、软件和数据完整性失败、安全日志记录和监控失败、服务器端请求伪造以及易受攻击和过时的组件。](https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?resize=768%2C768)\n*此图表来自 2024 年 Octoverse 报告，详细说明了 CodeQL 在 2024 年识别出的最常见 OWASP 分类漏洞类型。最新数据显示了类似的趋势，强调了尽管几十年来持续发出警告，注入攻击的风险依然存在。*\n\n## 培养安全思维\n\n安全是一个持续的过程，需要不断关注以确保代码安全。自动化工具虽然帮助巨大，但并非一劳永逸的解决方案。因此，理解安全漏洞的成因及其解决办法至关重要。没有工具是 100% 有效的，但通过提高理解和加深知识，将能更好地应对威胁。\n\n## 解释 Actions 工作流注入\n\nGitHub Actions 工作流注入是指恶意攻击者能够提交一个由仓库工作流运行的命令。当攻击者控制数据（例如，创建 issue 标题或分支名称），并且你执行了这些不受信任的输入时，就可能发生这种情况。例如，你可能在工作流的 `run` 部分执行了它。\n\n这种漏洞最常见的原因之一是代码中使用了 `${{}}` 语法。在预处理步骤中，此语法会自动扩展，这种扩展可能会通过插入新命令来改变你的代码。然后，当系统执行代码时，这些恶意命令也会被执行。\n\n**示例：**\n考虑以下工作流：\n```yaml\n- name: print title\n  run: echo \"${{ github.event.issue.title }}\"\n```\n假设此工作流在用户创建 issue 时触发。攻击者可以在 issue 标题中加入恶意代码（例如 `touch pwned.txt`），当此工作流运行时，代码就会被执行。更重要的是，此代码将以工作流被授予的权限运行，而这些权限攻击者通常无法获得。这是 Actions 工作流注入的根本问题。\n\nActions 工作流注入的最大问题在于缺乏对这一问题的认识，以及难以找到所有可能导致此漏洞的实例。\n\n## 主动保护代码的方法\n\n预防漏洞的出现比事后修补更容易。在编写代码时，应牢记以下几点来保护自己免受 Actions 工作流注入的侵害。请记住，即使遵循所有这些准则，也不能保证你完全受到保护。\n\n1.  **使用环境变量：**\n    Actions 工作流注入是由于扩展本应被视为不受信任的输入而发生的。当它被插入到工作流中时，如果包含恶意代码，就会改变预期的行为。然后当工作流触发并执行时，攻击者的代码就会运行。\n    一个解决方案是避免在工作流的 `run` 等部分直接使用 `${{}}` 语法。相反，将不受信任的数据扩展到环境变量中，然后在运行工作流时使用该环境变量。\n    以上述示例为例，它将变为：\n    ```yaml\n    - name: print title\n      env:\n        TITLE: ${{ github.event.issue.title }}\n      run: echo \"$TITLE\"\n    ```\n    这并不会使输入变得可信，但有助于保护你免受攻击者利用此漏洞的一些方式。\n\n2.  **最小权限原则：**\n    当 Actions 工作流注入触发时，它会以工作流被授予的权限运行。你可以通过设置工作流的 `GITHUB_TOKEN` 权限来指定工作流的权限。因此，确保你的工作流仅以执行任务所需的最低权限级别运行非常重要。否则，如果攻击者设法将代码注入你的工作流，你可能会授予他们意想不到的权限。\n\n3.  **谨慎使用 `pull_request_target`：**\n    当注入发生在由 `pull_request_target` 触发的工作流中时，其影响通常比 `pull_request` 更具破坏性。`pull_request` 和 `pull_request_target` 工作流触发器之间存在显著差异：\n    *   `pull_request` 工作流触发器在从 fork 触发时，默认阻止对目标仓库的写入权限和秘密访问。（请注意，当工作流从同一仓库中的分支触发时，它有权访问秘密并可能拥有写入权限。）\n    *   相比之下，`pull_request_target` 工作流触发器允许工作流编写者解除一些限制。虽然这在某些场景中很重要，但这意味着使用 `pull_request_target` 而非 `pull_request` 可能会使你的仓库面临更大的风险。\n    因此，除非你有非常特殊的需求，否则应使用 `pull_request` 触发器。如果你使用后者，鉴于其额外的权限，你需要对工作流格外小心。\n\n4.  **问题不只存在于 `main` 分支：**\n    在开发代码时创建多个分支是很常见的，通常用于各种功能或错误修复。不幸的是，如果你使用 `pull_request_target` 触发器，这些分支仍然是潜在的漏洞。攻击者可以针对在分支的拉取请求上运行的工作流，并仍然利用此漏洞。这意味着你不能仅仅因为针对 `main` 分支的工作流是安全的就认为你的仓库是安全的。你需要审查仓库中所有公开可见的分支。\n\n## CodeQL 的作用\n\nCodeQL 是 GitHub 的代码分析工具，可对你的代码进行自动化安全检查。CodeQL 最相关的特定功能是代码扫描功能，它可以提供有关代码的反馈并帮助识别潜在的安全漏洞。GitHub 最近已将扫描 GitHub Actions 工作流文件的功能普遍可用，你可以使用此功能查找多种类型的漏洞，例如潜在的 Actions 工作流注入风险。\n\nCodeQL 擅长发现不受信任数据可能被使用的地方，原因之一是其**污点追踪**功能。CodeQL 会追踪不受信任数据在代码中的流动，并识别可能不像前面示例那样明显的潜在风险。\n\n启用 CodeQL 扫描 Actions 工作流非常简单，只需使用默认设置启用 CodeQL 代码扫描即可，它会自动包含分析 Actions 工作流，并将在任何受保护的分支上运行。然后，你可以检查代码扫描结果以识别潜在风险并开始修复它们。如果你已经在使用 CodeQL 的高级设置，可以通过将 `actions` 语言添加到目标语言来添加对扫描 Actions 工作流的支持。\n\n虽然 CodeQL 是一个非常有效的工具，并且非常擅长发现这种特定漏洞，但它仍然不是 100% 有效的。请记住，没有工具是完美的，你应该专注于保持安全思维并批判性地审视自己的代码。\n\n## 后续步骤\n\nActions 工作流注入是 GitHub 上最普遍的漏洞之一，但它们相对容易解决。消除此漏洞的最大问题仅仅是意识到它们是一个问题，并发现代码中可能的薄弱环节。既然你已经意识到了这个问题，并且有 CodeQL 作为一个有用的工具，你应该能够开始在自己的代码中查找和修复这些漏洞。如果你牢记主动措施，你将能够更好地防止它们在未来编写的代码中出现。\n\n如果你想了解更多关于 Actions 工作流注入的信息，GitHub 之前发布了一个关于如何保护 Actions 工作流安全的四部分系列文章。第二部分专门讨论 Actions 工作流注入，但我们鼓励你阅读整个系列。\n\n需要帮助搜索代码以查找潜在漏洞吗？立即在你的项目中设置代码扫描。\n\n---\n\n**作者：**\n![Dylan Birtolo](https://avatars.githubusercontent.com/u/39363041?v=4&s=200)\nDylan Birtolo 是 GitHub 的高级内容撰稿人，负责分享 GitHub 的所有优点。他从事技术写作近 20 年，其中大部分时间在微软的各个团队工作。业余时间，他与动物打交道，玩很多游戏，并且是一名专业的马上长矛比武者。\n\n---\n\n**探索更多来自 GitHub 的内容：**\n![Docs 图标](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n**文档**\n掌握 GitHub 所需的一切，尽在一个地方。\n[前往文档](https://docs.github.com/)\n\n![GitHub 图标](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n**GitHub**\n在 GitHub 上构建未来，这里是任何地方的任何人都可以构建任何东西的地方。\n[开始构建](https://github.com/)\n\n![客户案例图标](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n**客户案例**\n了解使用 GitHub 进行构建的公司和工程团队。\n[了解更多](https://github.com/customer-stories)\n\n![GitHub Universe 2025 图标](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)\n**GitHub Universe 2025**\n最后机会：节省 700 美元购买 Universe 现场通行证，并于 10 月 28-29 日在旧金山加入我们。\n[立即注册](https://githubuniverse.com/)",
      "shortSummary": "GitHub Actions 工作流注入是 GitHub 仓库中常见的漏洞，攻击者通过执行不受信任的输入（如 issue 标题）注入恶意命令。为防范此类攻击，建议使用环境变量处理不受信任数据、遵循最小权限原则、谨慎使用 `pull_request_target` 触发器，并检查所有公开分支。GitHub 的 CodeQL 工具通过污点追踪功能，能自动化检测并帮助修复这些漏洞。安全是一个持续过程，结合工具和安全思维是关键。",
      "translated_title": "如何在攻击者之前捕获 GitHub Actions 工作流注入",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/vulnerabilities.png?resize=768%2C768",
          "alt": "A bar chart detailing the most common vulnerabilities found by CodeQL in 2024. In order from most to least, they are: injection, broken access control, insecure design, cryptographic failures, identification and authentication failures, security misconfigurations, software and data integrity failures, security logging and monitoring failures, server side request forgery, and vulnerable and outdated components.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/39363041?v=4&s=200",
          "alt": "Dylan Birtolo",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Strengthen your repositories against actions workflow injections — one of the most common vulnerabilities.</p>\n<p>The post <a href=\"https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/\">How to catch GitHub Actions workflow injections before attackers do</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "为爱而码：一场充满乐趣、奇思妙想和无限创意的夏季编程马拉松 (原标题: For the Love of Code: a summer hackathon for joyful, ridiculous, and wildly creative projects)",
      "link": "https://github.blog/open-source/for-the-love-of-code-2025/",
      "pubDate": "Wed, 16 Jul 2025 15:00:00 +0000",
      "isoDate": "2025-07-16T15:00:00.000Z",
      "creator": "Lee Reilly",
      "summary": "# 为爱而码：一场充满乐趣、奇思妙想和无限创意的夏季编程马拉松\n\nGitHub 宣布举办一场名为“为爱而码”（For the Love of Code）的全球性夏季编程马拉松，旨在鼓励开发者们出于乐趣、创意和探索精神来构建项目，而不仅仅是为了解决问题。\n\n## 活动时间\n*   2025年7月16日至9月22日。\n\n## 参赛对象\n*   所有经验水平的开发者，包括学生、维护者、业余爱好者、创意编码者、资深专业人士和好奇的初学者。\n*   可选择个人参赛或组队（团队人数上限为10人）。\n*   参赛者需年满13岁并拥有GitHub账户（部分地区可能受法律限制）。\n\n## 参赛内容\n*   参赛者可以构建任何他们想做的项目，包括但不限于：Web应用、命令行工具（CLI）、游戏、AI探索或创意实验。\n*   鼓励独立完成、与朋友合作或借助GitHub Copilot。\n*   鼓励使用开源项目、复用旧想法或原型（只要在活动期间构建或重建）。\n*   可以使用付费工具、许可软件或API，但需在README中注明，并避免提交敏感信息。\n*   非传统软件项目（如硬件破解、交互艺术、生成式项目）只要涉及代码并能在公共GitHub仓库中托管，也符合要求。\n*   禁止构建任何不尊重、不安全、有害或违反GitHub行为准则的内容（如NSFW内容、仇恨言论）。\n\n## 参赛类别（六大主题）\n1.  **按钮、蜂鸣与闪光（Buttons, beeps, and blinkenlights）**\n    *   涉及硬件（真实或模拟）的项目，具有闪烁、蜂鸣、嗡嗡声或带来惊喜的特点。强调互动性、物理性、触觉性和一点点混乱感。\n    *   *示例：* 显示构建状态的交通灯、测试通过时会喊“LGTM!”的焊接小助手、检测老板靠近时显示“实际工作”的屏幕、笔记本开合驱动的摩尔斯电码生成器、在ESP32 T-Display上可视化吉他音符的Rust项目。\n2.  **变革的代理（Agents of change）**\n    *   AI驱动的体验、代理或传统机器人，它们可以提供帮助、制造障碍或产生有趣的误解。涵盖自动化工作流、代码评审或荒谬的助手类项目。\n    *   *示例：* LLM驱动的过度戏剧化更新日志编写器、以讽刺高级开发人员或过于友善的实习生口吻评审PR的代理、AI辅助的餐厅账单分摊应用、Shania Twain风格的Slack或Discord机器人。\n3.  **终端才华（Terminal talent）**\n    *   巧妙、实用或纯粹有趣的命令行工具、扩展和TUI（文本用户界面）项目。具有个性的实用工具、精心设计的界面或让终端更生动的脚本。\n    *   *示例：* 命令行卡拉OK机、基于Issue和PR提供每日运势的GitHub CLI扩展、自动化长期未处理事项的交互式工具、终端动画派对鹦鹉、机械键盘声音模拟器。\n4.  **游戏时间（Game on）**\n    *   可玩、益智或纯粹有趣的项目。涵盖各种互动体验，如游戏原型、机制混搭或类型融合。强调怀旧、巧妙或原创性，乐趣优先，功能其次。\n    *   *示例：* 复古街机游戏、AI生成情节和NPC的冒险游戏、使用Copilot构建的垂直跳跃游戏、Octocats版的Flappy Bird克隆、在GitHub代码行中下落的垂直滚动游戏。\n5.  **世界奇观（World wide wonders）**\n    *   任何能让人微笑、思考、学习或点击“查看源代码”的Web项目。无论是初次HTML尝试、已计划发布的工具，还是具有意外用途的有趣副项目。\n    *   *示例：* 基于GitHub用户名和贡献记录进行“吐槽”的Web应用、具有拨号上网加载效果和像素艺术的90年代风格网站、需要杀死Doom中敌人才能通过的验证码、交互式随机复古科幻仪表板。\n6.  **包罗万象（Everything but the kitchen sink）**\n    *   为那些过于小众、特定或难以归类的创意项目而设的通配符类别。包括扩展、插件、工具、GitHub Actions或意外有用的原型。\n    *   *示例：* 提交代码时播放情景喜剧笑声的Git Hook、为函数提供Yelp式评论的VS Code扩展、如果团队本周没有合并带有正面表情符号的PR就拒绝部署的GitHub Action、纯粹为了重写而用Rust重写的项目、将宠物带入编辑器的VS Code扩展。\n\n## 奖项设置\n*   **互联网永生：** 优秀作品将在GitHub博客上展示。\n*   **GitHub Copilot Pro+：** 每个类别获奖者将获得12个月的GitHub Copilot Pro+订阅。\n*   **荣誉与氛围：** 以及一个终于可以构建心仪项目的绝佳理由。\n*   **真正的奖品：** 从事你热爱的事情。\n*   每位参赛者最多获得一份奖品，但其他优秀作品仍会获得表彰。\n\n## GitHub Copilot的鼓励使用\n*   Copilot不仅是代码补全工具，更是创意伙伴，可用于头脑风暴、解释代码等。\n*   鼓励参赛者探索Copilot的创意用途，包括Agent模式。\n\n## 如何参与\n1.  构建一个充满乐趣的项目（个人、与朋友或与Copilot合作）。\n2.  在2025年9月22日世界协调时间（AoE）晚上11:59之前，将代码推送到公共GitHub仓库。\n3.  通过官方提交表格提交作品。\n4.  在项目进展中添加标签`#ForTheLoveOfCode`，优秀作品将在社交媒体和GitHub Explore页面上展示。\n\n## 规则要点\n*   鼓励使用开源。\n*   鼓励使用GitHub Copilot，但非强制。\n*   最多可提交42个项目。\n*   项目必须在公共GitHub仓库中，并附有清晰的README文件。\n*   请查阅完整的条款和条件以及行为准则。\n\n## 评判标准\n*   由GitHub Stars、Campus Experts和工作人员组成的评审团将根据项目的乐趣性、执行力、技术难度、独创性以及与类别的相关性进行评估。\n*   对GitHub Copilot的意外使用将获得额外加分（非实际分数）。\n*   每个类别将选出三名获奖者，并于2025年10月22日前在GitHub博客上公布。\n\n## 常见问题\n*   **团队合作：** 可以，最多10人。\n*   **提交次数：** 最多42次。\n*   **时间投入：** 随意，可短可长。\n*   **新手参与：** 欢迎，提供了入门资源。\n*   **截止日期后编辑：** 仓库可继续工作，但评判以截止日期版本为准。\n*   **提交表单错误：** 重新提交即可，以最新版本为准。\n*   **README内容：** 应包含工具、依赖、设置说明，并考虑添加`#ForTheLoveOfCode`主题。\n*   **视频/演示：** 非强制，但强烈鼓励（GIF、截图、短视频有助于展示）。\n*   **外部托管演示：** 可以，但代码仍需在公共GitHub仓库中。\n*   **项目展示：** 提交即表示同意GitHub在选中时展示项目并注明出处。",
      "shortSummary": "GitHub将举办“为爱而码”夏季编程马拉松，时间为2025年7月16日至9月22日。该活动鼓励所有水平的开发者，无论是个人还是团队，构建充满乐趣、创意和独特性的项目，涵盖硬件、AI、游戏和Web应用等六大类别。参赛者可自由选择是否使用GitHub Copilot。优胜者将获得GitHub博客展示和Copilot Pro+订阅。活动旨在激发编程乐趣和创造力，项目将根据乐趣性、执行力和独创性进行评判。",
      "translated_title": "为爱而码：一场充满乐趣、奇思妙想和无限创意的夏季编程马拉松",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>That idea you've been sitting on? The domain you bought at 2AM? A silly or serious side project? This summer, we invite you to build it — for the joy, for the vibes, For the Love of Code 🧡</p>\n<p>The post <a href=\"https://github.blog/open-source/for-the-love-of-code-2025/\">For the Love of Code: a summer hackathon for joyful, ridiculous, and wildly creative projects</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "从混乱到清晰：使用GitHub Copilot代理改进开发者工作流程 (原标题: From chaos to clarity: Using GitHub Copilot agents to improve developer workflows)",
      "link": "https://github.blog/ai-and-ml/github-copilot/from-chaos-to-clarity-using-github-copilot-agents-to-improve-developer-workflows/",
      "pubDate": "Tue, 15 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-15T16:00:00.000Z",
      "creator": "Chris Reddington",
      "summary": "## 从混乱到清晰：使用GitHub Copilot代理改进开发者工作流程\n\n现代软件开发项目初期可能结构松散，但随着发展，这些早期努力可能变得脆弱。本文通过一个实际案例，展示了如何利用GitHub Copilot编码代理（agent）来重构和增强一个个人GitHub Actions项目，使其从一个零散的工具转变为一个结构良好、测试覆盖、文档齐全且易于维护的项目。\n\n### 核心案例：`validate-file-exists` GitHub Action\n\n作者在2024年11月（原文如此，可能为笔误）创建了一个名为`validate-file-exists`的GitHub Action，旨在确保仓库中存在特定文件（如`dependabot.yml`）。尽管功能可用，但它缺乏文档、元数据不一致、输入验证不足，并且没有为Copilot提供清晰的自定义指令或设置步骤。本文详细介绍了如何使用Copilot代理模式在VS Code中解决这些问题。\n\n### 关键改进步骤\n\n1.  **改进Copilot自定义指令 (`copilot-instructions.md`)**\n    *   **问题：** 原始指令过于简略，缺乏仓库目的、用法、结构描述以及对Copilot的明确指导。\n    *   **行动：** 基于最佳实践，要求Copilot根据代码库更新指令，使其包含：\n        *   仓库/代码库的清晰摘要和Action功能。\n        *   贡献指南（如何构建、格式化、lint和测试代码库，包括提交前的期望）。\n        *   项目结构概述。\n        *   关键技术原则（严格的TypeScript、TSDoc、专注且可管理的功能）。\n    *   **结果：** Copilot获得了正确的上下文，能够进行有意义的贡献。文章中提供了更新后的指令示例。\n\n2.  **添加`copilot-setup-steps.yaml`**\n    *   **目的：** 为Copilot编码代理提供必要的工作环境，包括安装框架、依赖项和工具。\n    *   **行动：** 根据GitHub文档创建`.github/copilot-setup-steps.yaml`文件。该文件负责检出代码、设置Node.js并安装所需的依赖项。作者将Node.js版本配置为从`.node-version`文件获取，以与CI工作流保持一致。\n    *   **结果：** Copilot编码代理具备了构建、lint和测试代码库所需的依赖项和工具，使其能够在进行更改时检查质量。\n\n3.  **让Copilot发现技术债务**\n    *   **行动：** 使用VS Code中的Copilot Chat，询问Copilot项目中的技术债务，并要求提供优先列表，以便创建GitHub Issue，包含问题陈述、验收标准和文件修改建议。\n    *   **Copilot的建议：**\n        *   包元数据不一致。\n        *   README不匹配（输入名称错误）。\n        *   对空或格式错误的输入缺乏验证。\n    *   **行动：** 要求Copilot为这些问题编写一个Issue，并将其分配给Copilot。\n\n4.  **Copilot编码代理实际操作**\n    *   **过程：** 任务分配后，代理异步地启动了一个新的拉取请求（PR）。它探索了仓库内容以理解问题，制定了计划，并执行了以下操作：\n        *   修复了`package.json`中的名称、描述、URL和作者字段。\n        *   更新了README使用示例以匹配代码。\n        *   添加了输入验证逻辑（拒绝空字符串、仅包含逗号的输入）。\n        *   为这些边缘情况编写了四个新测试。\n        *   确认了linting、格式化和代码覆盖率完好无损。\n        *   更新了PR正文，附带已完成工作的清单。\n    *   **结果：** Copilot在11分钟内完成了所有任务。尽管CI工作流最初因作者未在指令中包含的Markdown linting检查而失败，但通过在PR评论中要求Copilot修复，它成功更新了代码，并通过了检查。\n\n### 额外案例：使用Copilot编码代理和Playwright MCP服务器进行UI更改\n\n作者还展示了Copilot在另一个项目（一个基于Next.js和Tailwind CSS的Trend Radar可视化应用）中进行UI更改的能力。\n\n*   **问题：** 用户必须手动输入点数据。\n*   **期望解决方案：** 允许用户点击雷达放置点，并支持拖放重新定位以更改点的类别或可能性。\n*   **Copilot的工作：** 在几次PR评论迭代后，Copilot编码代理实现了点击放置逻辑、添加了拖放支持、编写了单元测试、截取了屏幕截图并附加到PR中，并更新了PR（并回复评论）以总结已完成的工作。\n*   **重要说明：** Playwright现在默认安装在Copilot编码代理中，这使得Copilot也能够验证视觉行为。\n\n### 总结与展望\n\n此次经历不仅是一次清理会话，更是现代软件协作的实践。GitHub Copilot编码代理被视为新的团队成员。通过为仓库提供清晰的上下文和意图，可以邀请Copilot进行有意义的贡献。作者鼓励开发者尝试使用Copilot代理来清理旧的GitHub Action、重构被忽视的仓库或添加验证和测试。关键在于：\n\n*   编写清晰简洁的`copilot-instructions.md`来指导代理。\n*   使用`copilot-setup-steps.yaml`为代理提供所需的工具。\n*   设定清晰且范围明确的任务。\n\nCopilot现在通过Playwright MCP服务器可以访问浏览器，从而能够与网页交互并添加屏幕截图到PR中。开发者无需启动新项目，即可在现有项目上尝试Copilot及其代理能力。\n\n**作者：**\n\n![Chris Reddington](https://avatars.githubusercontent.com/u/791642?v=4&s=200)\n\nChris Reddington 是GitHub开发者关系团队中一位充满热情的开发者倡导者和高级项目经理。\n\n**更多来自GitHub的资源：**\n\n*   **文档：**\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n    掌握GitHub所需的一切，尽在一处。\n*   **GitHub：**\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n    在GitHub上构建未来，这里是任何人、任何地点构建任何东西的地方。\n*   **客户案例：**\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n    了解使用GitHub进行构建的公司和工程团队。\n*   **GitHub Universe 2025：**\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)\n    最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山加入我们。",
      "shortSummary": "本文介绍了如何利用GitHub Copilot编码代理改进开发者工作流程。通过一个GitHub Action项目案例，作者展示了Copilot如何帮助完善自定义指令、配置开发环境、识别并解决技术债务，以及在拉取请求中协作。Copilot还被用于一个UI项目的迭代改进，并能通过Playwright进行视觉验证。文章强调了清晰的指令和任务范围对Copilot协作的重要性，鼓励开发者在现有项目中尝试Copilot的代理能力，将其视为一个高效的团队成员。",
      "translated_title": "从混乱到清晰：使用GitHub Copilot代理改进开发者工作流程",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/791642?v=4&s=200",
          "alt": "Chris Reddington",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Explore how you can set Copilot coding agent up for success with custom instruction and Copilot setup steps.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/from-chaos-to-clarity-using-github-copilot-agents-to-improve-developer-workflows/\">From chaos to clarity: Using GitHub Copilot agents to improve developer workflows</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "AI时代的代码审查：为什么开发者将永远掌握合并按钮 (原标题: Code review in the age of AI: Why developers will always own the merge button)",
      "link": "https://github.blog/ai-and-ml/generative-ai/code-review-in-the-age-of-ai-why-developers-will-always-own-the-merge-button/",
      "pubDate": "Mon, 14 Jul 2025 16:38:03 +0000",
      "isoDate": "2025-07-14T16:38:03.000Z",
      "creator": "Elle Shwer",
      "summary": "## AI时代的开发者与代码审查\n\n在软件开发中，GitHub于2008年推出的拉取请求（PR）通过将纯文本差异与社交工作流（评论、批准和合并按钮）相结合，将问责制融入现代软件开发。即使在大型语言模型（LLM）能够生成代码、提交PR并回复审查评论的今天，GitHub认为最终的合并决定权和代码责任仍属于开发者。AI改变的是合并前的一切，本文探讨了GitHub如何重新思考AI辅助下的代码审查。\n\n### 代码审查的（不变）目的\n\n代码审查远不止是发现错误。一个好的审查能够：\n*   发现缺陷和安全问题\n*   确保高代码质量\n*   在团队间分享知识，并保持与代码库模式和标准的一致性\n*   保障长期可维护性\n\nAI并不能改变这些核心目的，它只是转移了瓶颈。AI可以快速发现未使用的导入，但无法决定新端点是否损害隐私或何时处理复杂的抽象。合并按钮仍然需要（并将永远需要）开发者的“指纹”。\n\n### 从GitHub Copilot代码审查能力中获得的经验\n\nGitHub Copilot代码审查团队通过深入访谈，发现了三个一致的模式：\n*   **对AI无特殊待遇**：审查者对模型生成的差异与对其他开发者生成的差异一样严格。\n*   **自我审查提升了质量**：在提交PR前使用Copilot进行自我审查的开发者，通常能消除一整类琐碎的细节问题（如修剪导入、缺少测试），从而减少了约三分之一的来回沟通。\n*   **AI不能替代人类判断**：编程常涉及权衡，LLM可以提供信息，但最终决策需由人根据组织目标和标准做出。\n\n核心原则是：AI增强开发者的判断力，而非取代它。这些发现正在指导Copilot代码审查功能的构建。\n\n### GitHub Copilot代码审查普遍可用\n\nGitHub Copilot的代码审查代理现已面向所有Copilot计划普遍可用。它能在人类打开差异文件前，发现错误、性能问题，甚至建议修复方案。用户可以在仓库规则中启用自动审查，或在GitHub、GitHub Mobile或VS Code中按需请求Copilot审查。\n\n### AI当前能（和不能）处理什么\n\nLLM在审查的“繁琐”层面表现出色：\n*   **机械扫描**：检查拼写错误、参数使用情况。\n*   **模式匹配**：识别SQL注入、遗漏的await。\n*   **死板的一致性**：变量命名规范（snake_case vs. camelCase）。\n\n未来它们还能理解产品和领域上下文。但它们在以下方面仍有不足：\n*   **架构和权衡**：是否拆分服务？本地缓存？何时偿还技术债务？\n*   **指导**：解释模式的重要性以及何时打破规则。\n*   **价值观**：是否应该构建此功能？\n\n这些差距确保了开发者始终处于核心控制地位。\n\n### 现代代码审查的行动指南\n\n最有效的AI辅助代码审查方法始于提交拉取请求之前，遵循“己所不欲，勿施于人”的黄金法则。\n\n**1. 在IDE中使用AI进行代码自我审查**\n*   在推送代码前，运行GitHub Copilot代码审查，捕获明显问题，让队友专注于需要开发者洞察力的细微问题。\n*   Copilot可以检查暂存的差异，建议文档字符串，并标记空指针解引用。\n*   在提交PR前修复所有发现的问题，减少队友看到的“噪音”。\n\n**2. 对代码负责**\n*   即使代码由AI生成，一旦提交，开发者仍需对其负责。\n*   这意味着理解代码功能，确保其符合团队标准，并与现有代码库良好集成。\n\n**3. 通过自动化CI门禁运行代码**\n*   持续集成（CI）流水线应已运行单元测试、秘密扫描、CodeQL、依赖检查和风格检查器。\n*   实践个人代码卫生小贴士：在IDE中审查自己的代码，确保变量命名、注释和结构符合团队约定，彻底测试AI生成的代码。\n\n**4. 利用AI专注于判断力至关重要的领域**\n*   AI的真正力量在于处理常规工作，让开发者专注于最有价值的判断。\n*   AI不替代现有自动化检查，确保测试通过、覆盖率达标、静态分析工具完成工作。\n*   LLM擅长发现语法问题、模式、潜在错误和风格不一致，尤其擅长发现LLM自身可能犯的错误。\n\n**5. 明确定义角色**\n*   明确AI反馈何时应被考虑，以及何时人类判断优先。\n*   开发者应负责代码架构、业务目标和组织价值观的一致性。\n*   AI特别适用于审查冗长重复的PR，因为这些PR容易遗漏细节。\n\n### 构建可持续AI辅助审查流程的实施建议\n\n*   **文档化明确指南**：规定何时使用AI进行代码审查，信任哪种反馈，以及开发者与AI审查意见不一致时如何升级。例如，GitHub Copilot允许使用自定义指令设置其与代码交互的规则。\n*   **定期更新指南**：根据团队反馈和不断发展的AI能力进行调整。\n*   **鼓励开放团队讨论**：分享AI辅助审查的积极和消极经验，帮助团队学习和改进。\n*   **持续完善自动化**：利用审查者的反馈改进自动化测试策略，识别可自动化的重复问题解决方案。\n\n### 开发者判断力依然至关重要\n\n尽管AI可以处理代码审查中的大部分常规工作，但开发者的判断力在以下方面仍然不可替代：\n*   **架构权衡**：是否拆分服务？本地缓存？何时偿还技术债务？\n*   **指导和文化**：PR线程是团队的课堂，机器人无法讲述复杂代码背后的故事。\n*   **伦理和产品价值观**：“我们是否应该构建这个功能？”是AI无法回答的问题。\n\n目标是让开发者更高效，让他们专注于自己最擅长的领域。",
      "shortSummary": "在AI时代，开发者将始终掌握代码合并的最终决定权。GitHub Copilot等AI工具旨在增强而非取代人类在代码审查中的判断力。AI能处理语法、风格和常见缺陷等重复性任务，从而让开发者专注于架构决策、权衡取舍、知识共享和业务价值等更复杂的方面。通过AI进行自我审查可提高代码质量，减少琐碎修改。最终，代码的责任仍归属于点击“合并”的开发者。",
      "translated_title": "AI时代的代码审查：为什么开发者将永远掌握合并按钮",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>When it comes to merging code, developers will always make the final decision. But we’re rethinking how tools like GitHub Copilot can help. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/code-review-in-the-age-of-ai-why-developers-will-always-own-the-merge-button/\">Code review in the age of AI: Why developers will always own the merge button</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用 CodeQL 建模 CORS 框架以发现安全漏洞 (原标题: Modeling CORS frameworks with CodeQL to find security vulnerabilities)",
      "link": "https://github.blog/security/application-security/modeling-cors-frameworks-with-codeql-to-find-security-vulnerabilities/",
      "pubDate": "Thu, 10 Jul 2025 17:38:14 +0000",
      "isoDate": "2025-07-10T17:38:14.000Z",
      "creator": "Kevin Stubbings",
      "summary": "## 使用 CodeQL 建模 CORS 框架以发现安全漏洞\n\n本文探讨了如何利用 CodeQL 建模 CORS 框架和开发者头部，以提高 CORS 安全覆盖范围并发现潜在漏洞。不安全的 CORS 框架使用或自定义 CORS 实现中的逻辑错误可能导致严重的认证绕过和内网服务访问等安全问题。\n\n### CodeQL 的优势\n\n*   **详细信息获取能力**：CodeQL 等静态分析器能够获取关于结构、函数和导入库的详细信息，使其比 `grep` 等简单工具更具通用性。\n*   **易于发现错误配置**：CORS 框架通常通过特定结构和函数设置配置，CodeQL 是发现代码库中错误配置的有效方式。\n\n### CodeQL 中的头部建模\n\n在向 CodeQL 添加代码时，最佳实践是检查现有查询和框架，避免重复造轮子。CodeQL 通常已为大多数语言提供了覆盖默认情况的 CORS 查询。\n\n1.  **手动设置头部**：最简单的 CORS 实现方式是手动设置 `Access-Control-Allow-Origin` 和 `Access-Control-Allow-Credentials` 响应头部。\n2.  **识别和检查**：通过建模语言框架（如 Django、FastAPI、Flask），CodeQL 可以识别代码中设置这些头部的位置，并检查它们是否匹配易受攻击的值。\n    *   **示例**：Go 语言中将 `Access-Control-Allow-Origin` 设置为 `*`，可能导致未认证资源被任意网站访问。\n    ```go\n    func saveHandler(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    }\n    ```\n    *   **更严重错误配置**：反射请求源头部并允许凭证，可能导致攻击网站以当前登录用户身份发起请求，从而危及整个 Web 应用程序。\n    ```go\n    func saveHandler(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", r.Header.Get(\"Origin\"))\n        w.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n    }\n    ```\n3.  **CodeQL 建模头部写入**：\n    *   `HTTP.qll` 中的 `HeaderWrite` 类用于建模 HTTP 头部写入，其他模块和类可扩展它以查找所有头部写入。\n    *   `AllowCredentialsHeaderWrite` 类扩展 `Http::HeaderWrite`，用于查找 `Access-Control-Allow-Credentials` 设置为 `true` 的所有头部写入。\n    *   通过创建扩展更通用超类的类（如 `HTTP::HeaderWrite`），可以使模型的影响力在所有需要它们的 CodeQL 安全查询中得到利用。\n\n### CodeQL 中的框架建模\n\n许多开发者使用 CORS 框架而非手动设置头部。CORS 框架通常使用 Web 框架中的中间件为每个响应添加头部。\n\n1.  **建模目标**：在 CodeQL 中建模 CORS 框架时，通常是建模表示 CORS 策略的相关结构和方法。\n2.  **验证使用**：一旦建模的结构或方法具有正确的值，查询应检查该结构是否实际在代码库中使用。\n3.  **Go 语言示例 (Gin CORS)**：\n    *   Gin CORS 是一个用于 Gin Web 框架的 CORS 中间件框架。\n    *   **配置示例**：\n    ```go\n    router.Use(cors.New(cors.Config{\n        AllowOrigins: []string{\"https://foo.com\"},\n        AllowMethods: []string{\"PUT\", \"PATCH\"},\n        AllowHeaders: []string{\"Origin\"},\n        ExposeHeaders: []string{\"Content-Length\"},\n        AllowCredentials: true,\n        AllowOriginFunc: func(origin string) bool {\n            return origin == \"https://github.com\"\n        }\n    }))\n    ```\n    *   **建模 `Config` 类型**：使用 `SSAWithFields`（带有字段的单静态赋值）来建模 `Config` 类型，以跟踪包含 CORS 配置结构的变量。\n    *   **建模字段写入**：查找 `AllowOrigins`、`AllowCredentials`、`AllowOriginFunc` 等相关头部字段的所有写入实例。\n    *   `getConfig` 函数用于验证对相关头部的任何写入都影响相同的配置结构。\n    *   通过让来自不同框架的 CORS 相关头部写入都扩展 `UniversalOriginWrite` 和 `UniversalCredentialsWrite`，可以在 CORS 错误配置查询中使用它们。\n\n### 编写 CodeQL CORS 错误配置查询\n\nCORS 问题分为两类：\n\n*   **无凭证**：查找 `*` 或 `null`。\n*   **有凭证**：查找源反射或 `null`。\n\nCodeQL 的 Go 语言查询目前主要关注“带凭证的 CORS”类型，因为它适用于所有应用程序，且通常代表更严重的漏洞。\n\n1.  **查询逻辑**：查询关注关键漏洞，检查是否允许凭证，以及允许的源是来自不受信任的远程源还是硬编码为 `null`。\n2.  **谓词使用**：\n    *   `allowCredentialsIsSetToTrue` 谓词用于检查是否设置了凭证，它使用 `AllowCredentialsHeaderWrite`（针对手动头部）或 `UniversalAllowCredentialsWrite`（针对框架）。\n    *   `flowsFromUntrustedToAllowOrigin` 和 `allowOriginIsNull` 确保最终的头部写入是易受攻击的。\n3.  **避免误报**：查询会检查是否存在字符串比较等防护措施，以防止远程源到达源之前产生误报。\n\n### 额外提示\n\n*   **定制化查询**：CodeQL 查询需要针对每个 Web 框架进行定制，因为每个框架实现 CORS 策略的方式不同，且漏洞模式取决于框架行为。\n*   **示例**：Gin CORS 的 `AllowOriginFunc` 可能覆盖 `AllowOrigins`。可以编写 CodeQL 查询来查找始终返回 `true` 的 `AllowOriginFunc`，如果与凭证结合，这将导致高严重性漏洞。\n\n### 总结\n\n理解 Web 框架和头部与 CodeQL 的行为后，可以轻松发现代码中的安全问题，减少漏洞进入工作的机会。CodeQL 支持 CORS 错误配置查询的语言数量仍在增长，社区仍有改进空间。GitHub Code Security 也能通过检测和建议修复 CORS 错误配置等缺陷来帮助保护项目。",
      "shortSummary": "本文介绍了如何使用 CodeQL 建模 CORS 框架和开发者头部，以发现 Web 应用程序中的安全漏洞。通过 CodeQL 的静态分析能力，可以识别手动设置的易受攻击的 CORS 头部（如 `Access-Control-Allow-Origin: *` 或源反射与凭证结合），以及框架（如 Go 的 Gin CORS）中的错误配置。文章详细阐述了如何在 CodeQL 中建模头部写入和框架结构，并编写针对“带凭证的 CORS”等关键漏洞的查询，帮助开发者和安全研究人员提高代码安全性。",
      "translated_title": "使用 CodeQL 建模 CORS 框架以发现安全漏洞",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Discover how to increase the coverage of your CodeQL CORS security by modeling developer headers and frameworks.</p>\n<p>The post <a href=\"https://github.blog/security/application-security/modeling-cors-frameworks-with-codeql-to-find-security-vulnerabilities/\">Modeling CORS frameworks with CodeQL to find security vulnerabilities</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "超越提示词编写：如何成为你AI结对编程伙伴的更好搭档 (原标题: Beyond prompt crafting: How to be a better partner for your AI pair programmer)",
      "link": "https://github.blog/ai-and-ml/github-copilot/beyond-prompt-crafting-how-to-be-a-better-partner-for-your-ai-pair-programmer/",
      "pubDate": "Wed, 09 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-09T16:00:00.000Z",
      "creator": "Christopher Harrison",
      "summary": "# 超越提示词编写：如何成为你AI结对编程伙伴的更好搭档\n\n本文探讨了如何通过提供更丰富的上下文信息，而非仅仅依赖精心设计的提示词，来提升GitHub Copilot的代码建议质量。\n\n## 上下文是成功的关键\n\n文章通过一个寻找早午餐地点的故事类比，强调了上下文的重要性。就像人类对话一样，AI工具（如Copilot）需要持续的、迭代的上下文信息才能给出符合预期的结果。如果Copilot未能提供预期的建议，很可能是因为它缺乏必要的上下文，就像故事中最初缺乏“想吃华夫饼”这一关键信息一样。\n\n## GitHub Copilot 如何处理代码\n\n理解Copilot的工作方式对于提供有效上下文至关重要：\n\n*   **阅读代码和注释**：Copilot像人类开发者一样“阅读”它被指向的文件中的代码和注释。\n*   **不运行代码**：除了代理模式（agent mode），Copilot在生成代码建议时不会构建或运行代码。\n*   **缺乏“机构知识”**：Copilot不具备人类开发者所拥有的经验背景信息，例如代码的历史原因、内部库的使用规范或必须遵循的模式。\n*   **需要结构化上下文**：如果缺乏这些背景信息，Copilot可能会生成语法正确但与项目特定格式或结构不符的代码（例如，生成原始SQL而非使用数据抽象层）。\n\n## 提升 Copilot 建议质量的方法\n\n文章提出了几种超越提示词编写，为Copilot提供更好上下文的方法：\n\n### 1. 使用代码注释改进上下文\n\n*   **破除误解**：打破“高质量代码不需要注释”的普遍观念。即使代码对一位开发者可读，也可能对所有开发者并非如此。\n*   **提升可读性**：少量注释能大大提高代码可读性，这同样适用于Copilot。\n*   **Copilot 的“阅读”方式**：Copilot通过阅读注释来更好地理解代码的功能和实现方式，从而生成遵循现有模式和实践的高质量建议。\n*   **专业提示**：在打开文件时，养成添加注释的习惯，甚至可以请Copilot生成注释初稿，再进行补充。\n\n### 2. 利用自定义指令文件 (`copilot-instructions.md`)\n\n*   **项目级背景信息**：自定义指令文件用于提供项目层面的背景信息，如使用的技术栈、框架、编码标准以及项目构建的背景。\n*   **文件位置与格式**：将此文件放置在 `.github/copilot-instructions.md`，使用 Markdown 格式，可以创建如“项目结构”、“技术”、“编码标准”等章节。\n*   **全局性应用**：这些指令会随每个聊天请求发送给Copilot，因此应仅限于项目整体相关的信息，避免过于详细，以免干扰Copilot判断重点。\n*   **示例结构**：文章提供了一个单体仓库的示例大纲，包含后端、前端、代码标准和项目结构等部分，指导Copilot理解工作环境。\n\n### 3. 为特定任务提供具体指令 (`.instructions.md`)\n\n*   **任务特定性**：除了项目级指令，还可以创建针对特定任务类型的指令文件（例如，Flask 路由的创建、单元测试的编写）。\n*   **文件位置**：这些文件通常放置在 `.github/instructions/` 目录下。\n*   **链接与模式匹配**：指令文件可以包含指向项目内其他文件（作为示例原型）或其它指令文件的超链接。此外，还可以通过文件模式（如 `applyTo: server/tests/test_*.py`）将指令隐式应用于特定类型的文件。\n*   **长期投资**：构建这些指令文件虽然需要时间，但能带来更高质量的代码和更高的生产力。\n\n### 4. 完全可复用的提示文件 (实验性功能)\n\n*   **脚本化提示**：VS Code团队正在开发一项实验性功能——提示文件（prompt files），允许创建脚本化的Copilot提示。\n*   **可配置性**：可以配置这些提示适用的Copilot模式（ask, edit, agent）、调用的工具以及向开发者提出的问题。\n*   **团队协作**：团队可以创建这些文件以提高提示的复用性和一致性。\n\n### 5. 通过模型上下文协议 (MCP) 扩展 Copilot 能力\n\n*   **开放协议**：MCP（Model Context Protocol）是一个开源协议，允许组织将其服务或数据暴露给生成式AI工具。\n*   **“求助”功能**：将MCP服务器添加到IDE后，Copilot可以“求助”这些服务器来查找信息或执行任务。\n*   **权威来源**：例如，Playwright MCP服务器可以帮助创建端到端测试，GitHub MCP服务器提供对GitHub服务（仓库、问题、拉取请求）的访问。\n*   **自定义 MCP 服务器**：组织可以创建自己的MCP服务器，让Copilot查询内部代码库或库套件，从而根据内部环境提供代码建议。MCP确保了信息的准确性、相关性和时效性。\n\n## 总结\n\n提示词编写固然重要，是开发者使用GitHub Copilot应学习的首要技能。但它只是Copilot生成高质量答案的一部分。通过采纳上述最佳实践——包括良好的代码注释、自定义指令文件以及利用MCP服务器——开发者可以帮助Copilot更好地理解其意图和期望的实现方式，从而确保获得“华夫饼”而非“煎蛋卷”般的代码建议。",
      "shortSummary": "超越提示词编写，为AI结对编程伙伴（如GitHub Copilot）提供丰富上下文至关重要。这包括通过代码注释提升可读性，利用项目级自定义指令（`copilot-instructions.md`）和特定任务指令（`.instructions.md`）提供背景信息和规范。此外，通过模型上下文协议（MCP）可让Copilot访问外部服务或内部知识库，确保其建议准确且符合项目需求。这些方法共同帮助Copilot理解你的真正意图，从而生成更高质量的代码。",
      "translated_title": "超越提示词编写：如何成为你AI结对编程伙伴的更好搭档",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Ensuring quality code suggestions from Copilot goes beyond the perfect prompt. Context is key to success when working with your AI pair programmer.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/beyond-prompt-crafting-how-to-be-a-better-partner-for-your-ai-pair-programmer/\">Beyond prompt crafting: How to be a better partner for your AI pair programmer</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "Git 安全漏洞公告 (原标题: Git security vulnerabilities announced)",
      "link": "https://github.blog/open-source/git/git-security-vulnerabilities-announced-6/",
      "pubDate": "Tue, 08 Jul 2025 17:02:11 +0000",
      "isoDate": "2025-07-08T17:02:11.000Z",
      "creator": "Taylor Blau",
      "summary": "# Git 安全漏洞公告\n\nGit 项目今日发布新版本，旨在解决影响所有先前 Git 版本的七个安全漏洞。\n\n## 漏洞详情\n\n### Git 核心漏洞\n\n*   **CVE-2025-48384 (配置值处理)**\n    *   **问题描述：** Git 在读取配置值时会去除末尾的回车符 (CR) 和换行符 (LF)，但在写入时不会引用末尾的 CR，导致其丢失。当初始化路径包含末尾 CR 的子模块时，会使用被去除 CR 的路径，导致子模块被检出到错误的位置。\n    *   **潜在风险：** 如果被去除 CR 的路径与子模块的 hooks 目录之间存在符号链接，攻击者可通过子模块的 `post-checkout` 钩子执行任意代码。\n    *   **发现者/修复者：** David Leadbeater 发现，Justin Tobler 和 Patrick Steinhardt 修复。\n\n*   **CVE-2025-48385 (克隆时的捆绑包获取)**\n    *   **问题描述：** Git 客户端在克隆时可选地从服务器获取捆绑包。客户端未正确验证广告的捆绑包，允许远程端执行协议注入。\n    *   **潜在风险：** 当广告特制的捆绑包时，远程端可导致客户端将捆绑包写入任意位置，可能导致类似前一个 CVE 的代码执行。\n    *   **发现者/修复者：** David Leadbeater 发现，Patrick Steinhardt 修复。\n\n*   **CVE-2025-48386 (仅限 Windows，凭据助手)**\n    *   **问题描述：** Git 在从经过身份验证的远程克隆时使用凭据助手，其中 Wincred 助手使用静态缓冲区内容作为唯一密钥来存储和检索凭据。但它未正确检查缓冲区剩余空间。\n    *   **潜在风险：** 可能导致缓冲区溢出。\n    *   **发现者/修复者：** David Leadbeater 发现，Taylor Blau 和 Jeff King 共同修复。\n\n### Git GUI 和 Gitk 漏洞\n\n本次发布解决了与 Gitk 和 Git GUI 相关的四个新 CVE。这两个工具都是基于 Tcl/Tk 的图形界面。\n\n*   **CVE-2025-27613 (Gitk，任意文件写入/截断)**\n    *   **问题描述：** 在特制仓库中运行 Gitk 且不带额外命令行参数时，Gitk 可写入和截断任意可写文件。\n    *   **影响范围：** “支持每文件编码”选项必须启用，但“显示此行来源”操作无论如何都会受影响。\n    *   **发现者/修复者：** Avi Halachmi 发现，Johannes Sixt 修复。\n\n*   **CVE-2025-27614 (Gitk，任意脚本执行)**\n    *   **问题描述：** 如果用户被诱骗运行 `gitk filename`（其中 filename 具有特定结构），他们可能运行攻击者提供的任意脚本。\n    *   **潜在风险：** 导致任意代码执行。\n    *   **发现者/修复者：** Avi Halachmi 发现并修复。\n\n*   **CVE-2025-46334 (Git GUI，仅限 Windows，路径查找)**\n    *   **问题描述：** 如果恶意仓库包含可执行文件 `sh.exe` 或常见文本转换程序（如 `astextplain`、`exif` 或 `ps2ascii`），Windows 上的路径查找可能会在工作树中找到这些可执行文件。\n    *   **潜在风险：** 如果用户在此类仓库中运行 Git GUI 并从菜单中选择“Git Bash”或“浏览文件”，这些程序可能被调用，导致任意代码执行。\n    *   **发现者/修复者：** Mark Levedahl 发现并修复。\n\n*   **CVE-2025-46335 (Git GUI，任意文件创建/覆盖)**\n    *   **问题描述：** 当用户被诱骗在不受信任的仓库中编辑特命名目录中的文件时，Git GUI 可创建和覆盖任意可写文件。\n    *   **发现者/修复者：** Johannes Sixt 发现并修复。\n\n## 升级建议与缓解措施\n\n保护自己免受这些漏洞影响的最有效方法是升级到 **Git 2.50.1**，这是包含上述漏洞修复的最新版本。\n\n如果无法立即升级，可以通过以下措施降低风险：\n\n*   避免对不受信任的仓库运行 `git clone --recurse-submodules`。\n*   通过将 `transfer.bundleURI` 配置值设置为“false”来禁用自动获取捆绑包 URI。\n*   在 Windows 上避免使用 `wincred` 凭据助手。\n*   避免在不受信任的仓库中运行 Gitk 和 Git GUI。\n\n## GitHub 的应对措施\n\n为了保护用户免受这些漏洞相关的攻击，GitHub 已采取积极措施：\n\n*   已安排发布 GitHub Desktop 的更新版本。\n*   GitHub Codespaces 和 GitHub Actions 将很快更新其 Git 版本。\n*   GitHub 本身，包括 Enterprise Server，不受这些漏洞影响。\n\n## 作者与相关信息\n\n本文由 GitHub 软件工程师 Taylor Blau 撰写。\n\n![Taylor Blau](https://avatars.githubusercontent.com/u/443245?v=4&s=200)\n\n### 相关文章\n\n*   **Git 2.50 亮点**\n*   **聚焦您的开源项目**\n*   **探索更多来自 GitHub**\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) 客户案例：了解使用 GitHub 进行构建的公司和工程团队。\n*   ![Git Merge 2025](https://github.blog/wp-content/uploads/2025/05/git-merge-24-Orange.svg) Git Merge 2025：在 Git 20 周年之际，探索其影响、演变和未来。",
      "shortSummary": "Git 项目发布新版本，修复了影响所有先前 Git 版本的七个安全漏洞。这些漏洞涵盖 Git 核心（如配置处理、捆绑包获取、Windows凭据助手）以及 Git GUI 和 Gitk 工具（涉及任意文件操作、脚本执行和路径查找）。最有效的防护是升级到 Git 2.50.1。若无法立即升级，建议避免对不受信任的仓库使用特定Git功能，并谨慎运行Git GUI/Gitk。GitHub 已采取措施保护用户，其自身服务不受影响。",
      "translated_title": "Git 安全漏洞公告",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/443245?v=4&s=200",
          "alt": "Taylor Blau",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/05/git-merge-24-Orange.svg",
          "alt": "Git Merge 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Today, the Git project released new versions to address seven security vulnerabilities that affect all prior versions of Git.</p>\n<p>The post <a href=\"https://github.blog/open-source/git/git-security-vulnerabilities-announced-6/\">Git security vulnerabilities announced</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "CVE-2025-53367: DjVuLibre中一个可利用的越界写入漏洞 (原标题: CVE-2025-53367: An exploitable out-of-bounds write in DjVuLibre)",
      "link": "https://github.blog/security/vulnerability-research/cve-2025-53367-an-exploitable-out-of-bounds-write-in-djvulibre/",
      "pubDate": "Thu, 03 Jul 2025 20:52:20 +0000",
      "isoDate": "2025-07-03T20:52:20.000Z",
      "creator": "Kevin Backhouse",
      "summary": "## CVE-2025-53367：DjVuLibre中的越界写入漏洞\n\n### 概述\n\nDjVuLibre 3.5.29 版本已发布，修复了编号为 **CVE-2025-53367 (GHSL-2025-055)** 的越界写入（OOB）漏洞。该漏洞位于 `MMRDecoder::scanruns` 方法中，可能导致用户在 Linux 桌面系统上打开特制文档时，攻击者获得代码执行权限。\n\nDjVu 是一种文档文件格式，功能类似于 PDF，并受许多 Linux 发行版上的默认文档查看器（如 Evince 和 Papers）支持。即使 DjVu 文件被命名为 `.pdf` 扩展名，Evince/Papers 也能自动检测其为 DjVu 文档并调用 DjVuLibre 进行解码。\n\n### 漏洞发现与利用\n\n*   **发现者**：Antonio 在研究 Evince 文档阅读器时通过模糊测试发现了此漏洞。\n*   **概念验证 (POC)**：Kev 已为此漏洞开发了一个概念验证攻击代码。该 POC 可以在完全更新的 Ubuntu 25.04 (x86_64) 系统上运行，并绕过所有标准安全防护（包括 ASLR）。\n*   **攻击演示**：在演示中，Kev 点击了一个恶意 DjVu 文档（文件名为 `poc.pdf`，但实际是 DjVu 格式）。默认文档查看器 `/usr/bin/papers` 加载文档，检测到 DjVu 格式，并使用 DjVuLibre 进行解码。该文件利用越界写入漏洞，触发了 `system(\"google-chrome https://www.youtube.com/…\")` 的调用。\n*   **可靠性**：尽管 POC 能够绕过 ASLR，但其可靠性尚有待提高（有时会连续工作十次，然后突然停止工作几分钟）。研究人员认为可以开发出更可靠的利用方式。\n*   **AppArmor 限制**：POC 触发的是打开 YouTube 视频而非计算器，是因为 `/usr/bin/papers` 在 AppArmor 配置文件下运行。该配置文件禁止启动任意进程，但对 `google-chrome` 做了例外处理。然而，此 AppArmor 配置文件并非特别严格，例如，它允许向用户主目录写入任意文件（除了少数明显的文件如 `~/.bashrc`），因此无法阻止有决心的攻击者获得代码执行。\n\n### 漏洞技术细节\n\n`MMRDecoder::scanruns` 方法受越界写入漏洞影响，因为它未检查 `xr` 指针是否保持在分配缓冲区的边界内。在解码过程中，行程编码数据被写入 `lineruns` 和 `prevruns` 两个缓冲区：\n\n```cpp\n//libdjvu/MMRDecoder.h\nclass DJVUAPI MMRDecoder : public GPEnabled {\n...\npublic:\n  unsigned short *lineruns;\n...\n  unsigned short *prevruns;\n...\n}\n```\n\n变量 `pr` 和 `xr` 指向这些缓冲区中的当前位置。`scanruns` 函数未检查这些指针是否保持在分配缓冲区的边界内：\n\n```cpp\n//libdjvu/MMRDecoder.cpp\nconst unsigned short * MMRDecoder::scanruns(const unsigned short **endptr) {\n...\n  // Swap run buffers\n  unsigned short *pr = lineruns;\n  unsigned short *xr = prevruns;\n  prevruns = pr;\n  lineruns = xr;\n...\n  for(a0=0,rle=0,b1=*pr++;a0 < width;) {\n...\n    *xr = rle; xr++; rle = 0;\n...\n    *xr = rle; xr++; rle = 0;\n...\n    *xr = inc+rle-a0; xr++;\n  }\n```\n\n这可能导致写入超出分配内存的范围，从而引发堆损坏。同样的原因也可能导致 `pr` 发生越界读取。\n\n概念验证攻击代码的源代码将在几周内发布到 GitHub Security Lab 仓库。\n\n### 致谢\n\n感谢 Léon Bottou 和 Bill Riemers 在收到报告后不到两天内迅速响应并发布了修复。\n\n### 时间线\n\n*   **2025-07-01**：通过电子邮件向作者（Léon Bottou, Bill Riemers, Yann LeCun）报告。\n*   **2025-07-01**：收到 Bill Riemers 和 Léon Bottou 的回复。\n*   **2025-07-02**：Léon Bottou 添加了修复提交：[https://sourceforge.net/p/djvu/djvulibre-git/ci/33f645196593d70bd5e37f55b63886c31c82c3da/](https://sourceforge.net/p/djvu/djvulibre-git/ci/33f645196593d70bd5e37f55b63886c31c82c3da/)\n*   **2025-07-03**：DjVuLibre 3.5.29 版本发布：[https://sourceforge.net/p/djvu/www-git/ci/9748b43794440aff40bae066132aa5c22e7fd6a3/](https://sourceforge.net/p/djvu/www-git/ci/9748b43794440aff40bae066132aa5c22e7fd6a3/)\n\n### 研究人员\n\n*   **Kevin Backhouse**\n    ![Kevin Backhouse](https://avatars.githubusercontent.com/u/4358136?v=4&s=200)\n    GitHub 安全实验室团队的安全研究员，通过寻找漏洞并与维护者合作修复，帮助提高开源软件的安全性。\n\n*   **Antonio Morales**\n    ![Antonio Morales](https://avatars.githubusercontent.com/u/55253029?v=4&s=200)",
      "shortSummary": "CVE-2025-53367是DjVuLibre 3.5.29版本中修复的一个越界写入漏洞，位于`MMRDecoder::scanruns`方法。该漏洞允许攻击者通过诱导用户打开特制的DjVu文档，在Linux桌面系统上实现代码执行。由于Evince和Papers等默认文档查看器会调用DjVuLibre处理DjVu文件，用户面临风险。尽管存在ASLR和AppArmor等安全防护，概念验证（POC）攻击已成功演示。该漏洞已迅速得到修复，新版本DjVuLibre 3.5.29已发布。",
      "translated_title": "CVE-2025-53367: DjVuLibre中一个可利用的越界写入漏洞",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/4358136?v=4&s=200",
          "alt": "Kevin Backhouse",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/55253029?v=4&s=200",
          "alt": "Antonio Morales",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>DjVuLibre has a vulnerability that could enable an attacker to gain code execution on a Linux Desktop system when the user tries to open a crafted document.</p>\n<p>The post <a href=\"https://github.blog/security/vulnerability-research/cve-2025-53367-an-exploitable-out-of-bounds-write-in-djvulibre/\">CVE-2025-53367: An exploitable out-of-bounds write in DjVuLibre</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用GitHub Copilot和MCP改进工作流程的5种方法 (原标题: 5 ways to transform your workflow using GitHub Copilot and MCP)",
      "link": "https://github.blog/ai-and-ml/github-copilot/5-ways-to-transform-your-workflow-using-github-copilot-and-mcp/",
      "pubDate": "Wed, 02 Jul 2025 17:44:02 +0000",
      "isoDate": "2025-07-02T17:44:02.000Z",
      "creator": "Klint Finley",
      "summary": "# 使用GitHub Copilot和MCP改进工作流程的5种方法\n\n本文探讨了如何利用模型上下文协议（Model Context Protocol, MCP）与GitHub Copilot结合，以优化开发工作流程。\n\n## MCP简介\n\n传统的AI编码助手通常独立运行，仅限于当前工作区内的代码。随着模型上下文协议（MCP）的引入，AI开发工作流程正在进一步演进，以整合更多工具和上下文。\n\n*   **什么是MCP？** MCP是由Anthropic开发的一个开放标准，旨在帮助GitHub Copilot等AI助手安全地连接到外部数据源和工具。\n*   **解决LLM挑战：** MCP解决了大型语言模型（LLM）在提供正确上下文以生成准确有用响应方面的常见挑战。\n*   **标准化访问：** 它标准化了AI工具访问外部上下文（如代码库、文档或设计规范）的方式，并使其更容易融入开发工作流程。\n*   **核心价值：** MCP的真正价值在于，它使开发者能够直接在集成开发环境（IDE）中执行以前需要多种工具、上下文切换和手动操作的任务，从而节省时间、保持专注并更快地交付代码。\n*   **场景示例：** 本文将通过实现一个安全的JWT（JSON Web Token）认证系统来演示MCP的端到端工作流程。\n\n## 使用MCP转换工作流程的五种方式\n\n### 1. 使用MCP连接设计与开发（Figma）\n\n设计与开发之间的鸿沟一直是产品团队的摩擦点。MCP提供了一种标准化方式，让GitHub Copilot能够安全地直接访问和解释设计规范。\n\n*   **功能：** Copilot能够自动检索精确的设计参数（如颜色、间距、排版和组件状态），并生成准确、即用的代码，从而减少猜测并简化设计师与开发人员之间的交接。\n*   **GitHub Copilot的代理能力：**\n    *   **代理模式（IDE中）：** 将Copilot Chat转变为实时协作伙伴，可规划、编辑文件、运行测试套件、读取失败、修复问题并循环直到成功。\n    *   **编码代理（GitHub项目中）：** 将Issue交给Copilot，它会在受保护的工作区中编写代码、运行检查/测试，并打开拉取请求供审查。\n*   **JWT认证示例：**\n    *   询问Copilot：“登录表单和认证组件的最新设计更新是什么？”它将从Figma检索相关规范。\n    *   然后提示它创建React组件，如`LoginForm`（包含精确的间距、颜色、排版）、`AuthErrorMessage`（包含正确的错误样式）和`TokenRefreshNotification`，Copilot将提供与Figma设计规范一致的即用代码。\n\n### 2. 利用Obsidian知识库（Obsidian）\n\n在实现JWT认证等复杂功能时，通常需要参考分散在知识库中的过往决策、架构笔记和研究成果。非官方的、社区维护的Obsidian MCP服务器通过将GitHub Copilot直接连接到Obsidian笔记库来弥补这一空白。\n\n*   **功能：**\n    *   **搜索与检索：** 告诉Copilot：“搜索所有提及JWT或令牌验证的文件并解释上下文。”Copilot可以搜索笔记库中的所有Markdown文件，检索特定的架构决策记录（ADR）内容，访问以前安全审查的会议记录，并获取团队编码标准中的实现指南。\n    *   **信息综合：** 可以进一步提示：“获取上次关于认证的架构会议记录内容并总结关键决策。”Copilot将定位相关文件并提取关键信息。\n    *   **文档创建：** 收集所需上下文后，可以要求Copilot综合信息：“创建一个名为‘jwt-implementation-summary.md’的新笔记，结合我们的认证标准和新的JWT方法。”Copilot将直接在笔记库中创建此文档。\n*   **设置要求：** 此集成需要社区的“Obsidian Local REST API”插件和API密钥。\n\n### 3. 使用Playwright测试代码（Playwright）\n\n将MCP与Playwright集成，将测试创建从手动、易错的过程转变为简单、引导式的体验。\n\n*   **功能：**\n    *   **生成测试：** 针对JWT认证系统，可以提示Copilot：“测试JWT认证流程，包括登录、自动令牌刷新和受保护路由访问。”Copilot将分析认证实现并生成全面的测试覆盖。\n    *   **运行与反馈：** Copilot随后使用Playwright运行测试，并立即提供失败反馈，为常见问题（如时序问题或选择器更改）提供修复建议。\n\n### 4. 更快地提交拉取请求（GitHub）\n\n拉取请求是协作开发的基础。GitHub的远程MCP服务器（目前在VS Code或Visual Studio中提供公共测试版）有助于将此过程转变为智能、自动化的工作流程。\n\n*   **功能：**\n    *   **PR创建：** 针对JWT认证示例，可以提示Copilot：“为我的认证功能更改创建一个拉取请求。”\n    *   **智能分析：** Copilot将分析跨多个文件的代码更改、相关问题和项目上下文、团队审查模式和专业领域，以及以前类似的实现。\n    *   **建议与推荐：** Copilot会返回包含概述、所做更改、测试策略甚至相关问题的Markdown文本。它还会根据代码所有权、专业映射和当前工作量，为更改的各个方面建议合适的审查者。\n\n### 5. 监控应用程序性能（Grafana）\n\n在处理完核心认证逻辑后，需要通过监控应用程序在生产环境中的行为来确保其性能。使用MCP通过开源的Grafana MCP服务器连接到Grafana，使这一过程变得更容易。\n\n*   **功能：**\n    *   **查询指标：** 告诉Copilot：“显示过去6小时内auth-service仪表板的认证延迟和错误率面板。”在配置Grafana MCP服务器后，Copilot可以查询Grafana实例以检查认证延迟指标、分析登录端点的错误率、审查现有认证服务的警报规则，并识别失败认证尝试中的模式。\n    *   **数据呈现：** Copilot将面板数据作为base64编码的图像返回，并在需要时提取原始时间序列数据。\n    *   **高级操作：** 通过使用`--enable-write`标志和编辑器角色API密钥启动服务器，可以启用写入操作，允许Copilot根据认证指标分析创建新的警报规则或修改仪表板配置。\n\n## 后续步骤与最佳实践\n\n在深入使用这些强大的集成之前，需要配置开发环境：\n\n*   **安装MCP扩展：** 通过官方扩展在IDE中启用MCP支持。\n*   **配置API访问：** 为每个服务（GitHub、Obsidian、Figma等）设置认证。\n*   **定义上下文边界：** 确定AI应可访问哪些信息。\n*   **安全考虑：** 实施适当的访问控制和数据隐私措施。\n\n**一些最佳实践：**\n\n*   **从小处着手：** 从一个集成开始，逐步扩展使用范围。\n*   **维护文档：** 保持知识库和文档的最新状态，以获得最佳AI协助。\n*   **定期审查Copilot的输出：** 定期审计AI生成的建议，以确保质量和安全性。\n*   **建立团队协作：** 确保团队理解并采用一致的MCP使用模式。\n\nMCP生态系统的不断发展将继续扩展其可能性。",
      "shortSummary": "模型上下文协议（MCP）通过连接GitHub Copilot与外部系统，革新了开发工作流程。它使Copilot能直接在IDE中访问Figma设计、Obsidian知识库、Playwright测试、GitHub拉取请求和Grafana监控数据。这五种集成方式显著提升了开发效率、上下文理解和团队协作，帮助开发者更快地交付高质量代码，并简化了从设计到部署的整个流程。",
      "translated_title": "使用GitHub Copilot和MCP改进工作流程的5种方法",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Learn how to streamline your development workflow with five different MCP use cases. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/5-ways-to-transform-your-workflow-using-github-copilot-and-mcp/\">5 ways to transform your workflow using GitHub Copilot and MCP</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-07-19T04:40:23.544Z"
}