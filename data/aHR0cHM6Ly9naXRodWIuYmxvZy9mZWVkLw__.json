{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "如何使用 Playwright MCP 和 GitHub Copilot 调试 Web 应用 (原标题: How to debug a web app with Playwright MCP and GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-to-debug-a-web-app-with-playwright-mcp-and-github-copilot/",
      "pubDate": "Fri, 05 Sep 2025 16:00:00 +0000",
      "isoDate": "2025-09-05T16:00:00.000Z",
      "creator": "Christopher Harrison",
      "summary": "## 如何使用 Playwright MCP 和 GitHub Copilot 调试 Web 应用\n\n### 引言：自动化调试的挑战与解决方案\n\n传统的 bug 报告通常包含复现步骤，但手动验证这些步骤既耗时又繁琐。许多项目缺乏健壮的端到端测试来自动化此过程。本文介绍了一种解决方案：利用 GitHub Copilot 代理模式结合 Playwright 模型上下文协议（MCP）服务器，实现 Web 应用 bug 的自动化复现、追踪和解决。\n\n### Playwright 与 MCP 概述\n\n*   **Playwright**：一个用于 Web 应用的端到端测试框架。它允许开发者创建脚本来模拟用户行为，验证应用程序的功能集，并确保产品质量。例如，在购物应用中，Playwright 可以自动化搜索产品、添加到购物车和完成购买的整个流程。\n*   **MCP (Model Context Protocol)**：由 Anthropic 开发的开放且开源的协议，旨在向 AI 代理暴露工具。这些工具可以提供额外的上下文信息，或允许 AI 代理执行特定操作。\n*   **Playwright MCP 服务器**：将 Playwright 的功能作为工具提供给 AI 代理（如 GitHub Copilot）。这使得 Copilot 能够创建测试脚本并直接执行 Playwright 操作，从而自动化地执行 bug 复现步骤。\n\n### 在 VS Code 中配置 Playwright MCP 服务器\n\n要在 VS Code 中使用 Playwright MCP 服务器，需要进行以下配置：\n\n1.  **安装或配置**：可以在 VS Code 中全局安装 Playwright MCP 服务器，或者在项目的 `.vscode` 文件夹中创建一个名为 `mcp.json` 的文件，并添加以下配置：\n    ```json\n    {\n      \"servers\": {\n        \"playwright\": {\n          \"command\": \"npx",
      "shortSummary": "本文介绍了如何利用 GitHub Copilot 代理模式和 Playwright 模型上下文协议 (MCP) 服务器自动化 Web 应用的 bug 调试。Playwright 作为端到端测试框架，通过 MCP 协议将工具暴露给 AI 代理。开发者可在 VS Code 中配置 Playwright MCP 服务器，然后指示 Copilot 自动执行 bug 复现步骤，确认问题，追踪代码（包括前端、API 调用和后端），并定位错误。Copilot 甚至能在提出修复方案后，利用 Playwright 验证其有效性，显著提升调试效率，让 AI 能够“看到”代码更改对网站的实际影响。",
      "translated_title": "如何使用 Playwright MCP 和 GitHub Copilot 调试 Web 应用",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/image.png?resize=1024%2C816",
          "alt": "A screenshot showing the play button below \"servers\", just above \"playwright\", in a VS Code window.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/6109729?v=4&s=200",
          "alt": "Christopher Harrison",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Reproduce and debug web app issues with ease using the Playwright MCP server and GitHub Copilot.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-to-debug-a-web-app-with-playwright-mcp-and-github-copilot/\">How to debug a web app with Playwright MCP and GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 在新的政府贸易规则下为叙利亚开发者提供更广泛的访问权限 (原标题: GitHub is enabling broader access for developers in Syria following new government trade rules)",
      "link": "https://github.blog/company/github-is-enabling-broader-access-for-developers-in-syria-following-new-government-trade-rules/",
      "pubDate": "Fri, 05 Sep 2025 06:00:00 +0000",
      "isoDate": "2025-09-05T06:00:00.000Z",
      "creator": "Mike Linksvayer",
      "summary": "# GitHub 在新的政府贸易规则下为叙利亚开发者提供更广泛的访问权限\n\n## 引言\nGitHub 宣布，随着对叙利亚的制裁和出口管制放松，将为叙利亚开发者提供更广泛的访问权限。这一举措是 GitHub 长期以来坚持的“所有开发者都应自由使用 GitHub，无论他们身在何处”这一核心立场的又一重要里程碑。\n\n## 主要变化与影响\n*   **服务恢复**：GitHub.com 上的私人和付费功能将再次广泛向叙利亚的开发者开放，覆盖阿勒颇、霍姆斯、大马士革以及全国各地。\n*   **持续可用性**：在此之前，开源项目和其他公共仓库的协作功能一直保持可用，这在 GitHub Innovation Graph（一个提供叙利亚公共仓库贡献汇总数据的开放数据集）中有所体现。\n*   **感谢与欢迎**：GitHub 对那些为促成这一改变而持续发声并寻求更新的开发者表达了诚挚的感谢。GitHub 欢迎叙利亚开发者将他们的项目贡献给全球开发者社区，无论项目大小。\n\n## GitHub 的承诺与具体行动\nGitHub 承诺将继续致力于在法律允许的范围内，让尽可能多的开发者使用其平台。为此，GitHub 正在迅速采取以下措施：\n*   **解除限制**：解除对叙利亚开发者的限制。\n*   **恢复功能**：恢复账户的正常功能。\n*   **提供 Copilot**：提供 GitHub Copilot 的访问权限。\n\n这些更改目前正在进行中，预计将在未来一周内对相关账户生效。\n\n## 作者信息\n本文由开发者政策主管 Mike Linksvayer 撰写。\n\n![Mike Linksvayer](https://secure.gravatar.com/avatar/8cc1e22f2b79ef8eb4c53537d6ba5ac6ae3cf311c9eef3006657ebe8be0551ce?s=200&d=mm&r=g)\n\n## 相关内容\n*   **Docs**：掌握 GitHub 所需的一切，尽在一个地方。\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n*   **GitHub**：在 GitHub 上构建未来，这里是任何地方的任何人都可以构建任何东西的地方。\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n*   **客户案例**：了解使用 GitHub 进行构建的公司和工程团队。\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n*   **GitHub Universe 2025**：最后机会：节省 700 美元购买 Universe 现场通行证，于 10 月 28-29 日在旧金山与我们相聚。\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)",
      "shortSummary": "由于对叙利亚的制裁和出口管制放松，GitHub 正在恢复叙利亚开发者的全面访问权限。这意味着 GitHub.com 上的私人和付费功能将再次广泛可用，包括正常的账户功能和 GitHub Copilot。此前，开源项目协作一直保持开放。GitHub 感谢为这一改变发声的开发者，并重申其致力于在法律允许范围内，让所有开发者自由使用 GitHub 的承诺。相关更改预计将在下周内生效。",
      "translated_title": "GitHub 在新的政府贸易规则下为叙利亚开发者提供更广泛的访问权限",
      "images": [
        {
          "url": "https://secure.gravatar.com/avatar/8cc1e22f2b79ef8eb4c53537d6ba5ac6ae3cf311c9eef3006657ebe8be0551ce?s=200&d=mm&r=g",
          "alt": "Mike Linksvayer",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>With the relaxation of sanctions and export controls on Syria, GitHub will once again be broadly available to Syrian developers.</p>\n<p>The post <a href=\"https://github.blog/company/github-is-enabling-broader-access-for-developers-in-syria-following-new-government-trade-rules/\">GitHub is enabling broader access for developers in Syria following new government trade rules</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "通过MCP启发构建更智能的交互：从笨拙的工具调用到无缝的用户体验 (原标题: Building smarter interactions with MCP elicitation: From clunky tool calls to seamless user experiences)",
      "link": "https://github.blog/ai-and-ml/github-copilot/building-smarter-interactions-with-mcp-elicitation-from-clunky-tool-calls-to-seamless-user-experiences/",
      "pubDate": "Thu, 04 Sep 2025 16:00:00 +0000",
      "isoDate": "2025-09-04T16:00:00.000Z",
      "creator": "Chris Reddington",
      "summary": "## 通过MCP启发构建更智能的交互：从笨拙的工具调用到无缝的用户体验\n\n本文深入探讨了如何利用模型上下文协议（MCP）中的“启发”（Elicitation）机制，显著提升软件的用户体验，特别是针对AI驱动的交互。作者以一个回合制游戏（如井字棋、石头剪刀布）的MCP服务器为例，展示了如何从最初存在诸多“痛点”的交互方式，演变为更加自然和无缝的用户体验。\n\n### 什么是启发（Elicitation）？\n\n启发机制的核心思想是“如果缺少所需信息，就主动去获取”。它超越了简单的信息收集，旨在创建直观的交互：AI（通过MCP服务器）能够在任务执行过程中暂停，主动询问并获取所需信息，然后继续任务，从而避免了依赖硬编码的默认假设。\n\n**注意**：启发功能是MCP规范中的一个相对较新的特性（于2025年6月修订中添加），目前并非所有AI应用宿主都支持（例如，Visual Studio Code中的GitHub Copilot支持此功能）。\n\n### 实施过程中的挑战与改进\n\n作者在回合制游戏MCP服务器中实施启发功能时，遇到了以下挑战并进行了改进：\n\n1.  **初始实现与工具蔓延**：\n    *   最初，作者为新游戏创建（如难度、玩家姓名、先手顺序、游戏轮数）实现了基本的启发功能。\n    *   为了比较新旧方法，启发功能被实现为新的独立工具（例如 `create-tic-tac-toe-game-interactive`），导致服务器中出现大量功能重叠的工具（如 `create-tic-tac-toe-game` 和 `create-tic-tac-toe-game-interactive`）。\n    *   **问题**：AI代理（如Copilot）在面对名称和描述相似的工具时，难以选择正确的工具，导致行为不可预测。\n\n2.  **解决方案：工具整合与DRY原则**：\n    *   通过大量重构和整合，作者将工具数量从八个减少到四个，遵循“不要重复自己”（DRY）原则。\n    *   现在，当用户提示“我们玩一局井字棋”时，工具调用会识别出需要更多信息，从而触发启发机制，确保用户做出明确选择，而非使用预设的默认值。\n\n    ![GitHub Copilot Chat在Visual Studio Code中触发启发体验，请求用户提供额外偏好以自定义体验的截图](https://github.blog/wp-content/uploads/2025/09/image1.png?resize=1024%2C576)\n\n3.  **处理部分信息与实时调试**：\n    *   在直播中发现一个bug：无论用户是否已提供所需信息，启发步骤都会被触发。\n    *   **修复**：直播后，作者添加了检查机制，在工具调用后判断哪些信息已提供，只请求缺失的信息。同时，统一了工具和启发模式之间的属性名称，提高了清晰度。\n    *   例如，如果用户说“我们玩井字棋，我先走”，系统只会询问游戏难度和玩家姓名。\n\n### 启发机制在MCP服务器中的工作原理\n\n当MCP服务器调用 `create_game` 工具时，其内部流程如下：\n\n*   **检查必要参数**：判断用户是否指定了游戏类型或ID。\n*   **传递可选参数**：将已识别的参数传递给独立方法，检查是否缺少难度、玩家姓名或回合顺序等信息。\n*   **启动启发**：如果信息缺失，暂停工具执行，并仅从用户处收集缺失信息（这是直播后添加的改进）。\n*   **呈现模式驱动的提示**：用户会看到针对每个缺失参数格式化的问题。\n*   **收集响应**：MCP客户端（本例中为VS Code）负责处理UI交互。\n*   **完成原始请求**：一旦服务器收集到所有信息，工具将使用用户的偏好执行 `createGame` 方法。\n\n    ![GitHub Copilot Chat在Visual Studio Code中出现新的UI模态框，提示用户选择偏好，本例中用户选择难度为“困难”的截图](https://github.blog/wp-content/uploads/2025/09/image2.png?resize=1024%2C576)\n\n**结果**：用户可以获得个性化的游戏设置，例如“Chris vs AI (Hard)”，并由AI先手，而不是默认的“Player vs AI (Medium)”。\n\n### 关键经验教训\n\n1.  **用户体验至关重要**：启发机制虽然增加了复杂性，但通过主动询问用户偏好，提供了比强制使用默认值更好的体验。\n2.  **工具命名比想象中更重要**：在构建和使用MCP服务器中的工具时，清晰的命名和描述至关重要，模糊的名称会导致AI行为不可预测。\n3.  **迭代开发制胜**：先构建基本功能，在使用中识别痛点，然后通过添加启发等功能来改进用户体验，并利用AI编码代理进行清理。\n\n### 总结\n\n构建更好的AI工具不仅仅关乎底层模型，更在于创造能够解释上下文、提出好问题并准确满足用户需求的体验。启发机制是朝着这个方向迈出的重要一步，预示着MCP生态系统将支持更丰富、更智能的交互。",
      "shortSummary": "本文探讨了如何通过MCP启发（elicitation）机制提升AI交互的用户体验。该机制使AI在信息不足时能主动暂停并向用户请求必要数据，从而避免了僵硬的默认设置和笨拙的工具调用。作者通过一个回合制游戏MCP服务器的开发实践，解决了工具命名混淆和重复请求等问题，实现了工具整合与仅请求缺失信息。文章强调了用户体验、清晰的工具命名和迭代开发的重要性，旨在构建更智能、个性化的AI交互，让用户体验更自然、无缝。",
      "translated_title": "通过MCP启发构建更智能的交互：从笨拙的工具调用到无缝的用户体验",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/image1.png?resize=1024%2C576",
          "alt": "A screenshot of GitHub Copilot Chat in Visual Studio Code where the user has asked \"Let's play a game of tictactoe\". Copilot has triggered the elicitation experience, requesting additional preferences to customize the experience.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/image2.png?resize=1024%2C576",
          "alt": "A screenshot of GitHub Copilot Chat in Visual Studio Code where a new UI modal appears, prompting the user for their preferences. This example shows the user selecting the Difficulty as hard.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://avatars.githubusercontent.com/u/791642?v=4&s=200",
          "alt": "Chris Reddington",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 7
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Explore how MCP elicitation transforms AI tool interactions by gathering missing information upfront. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/building-smarter-interactions-with-mcp-elicitation-from-clunky-tool-calls-to-seamless-user-experiences/\">Building smarter interactions with MCP elicitation: From clunky tool calls to seamless user experiences</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "为 Copilot 编写更优自定义指令的 5 个技巧 (原标题: 5 tips for writing better custom instructions for Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/5-tips-for-writing-better-custom-instructions-for-copilot/",
      "pubDate": "Wed, 03 Sep 2025 16:00:00 +0000",
      "isoDate": "2025-09-03T16:00:00.000Z",
      "creator": "Christopher Harrison",
      "summary": "# 为 Copilot 编写更优自定义指令的 5 个技巧\n\n本文旨在提供五个关键技巧，帮助开发者为 GitHub Copilot 编写更有效的自定义指令，从而获得更优质的代码建议。核心理念是，Copilot 就像一位新加入的团队成员，需要充分的上下文信息才能高效工作。`copilot-instructions.md` 文件是 Copilot 聊天或代理请求的中心，用于提供项目背景和团队经验。\n\n作者强调，不必过度追求完美，因为生成式 AI 具有概率性。目标是尽可能地引导 Copilot 找到期望的答案。以下建议并非强制要求，而是基于经验的推荐，旨在显著提高 Copilot 建议的质量。\n\n## 1. 提供项目概览\n\n为 Copilot 提供一个项目的“电梯演讲”至关重要。指令文件的开头应简要说明应用是什么、目标受众以及主要功能。这有助于为 Copilot 设定高层次的项目背景。\n\n*   **示例：Contoso Companions**\n    *   一个支持宠物领养机构的网站。\n    *   机构可以管理地点、可用宠物和宣传活动。\n    *   潜在领养者可以搜索宠物、发现机构并提交领养申请。\n\n## 2. 明确项目使用的技术栈\n\n在明确项目目标后，下一步是详细列出用于构建项目的技术。这包括后端和前端技术、调用的 API 以及目标测试套件。建议使用列表形式突出显示所使用的技术，并可添加关于其使用方式的简短说明，帮助 Copilot 理解代码创建的环境。\n\n*   **示例技术栈：**\n    *   **后端：** Flask (API), Postgres (数据存储), SQLAlchemy (ORM)。开发、预发布和生产环境使用独立数据库。端到端测试会创建、填充并移除新数据库。\n    *   **前端：** Astro (核心站点和路由), Svelte (交互性), TypeScript (所有前端代码)。\n    *   **测试：** Python 使用 Unittest，TypeScript 使用 Vitest，端到端测试使用 Playwright。\n\n## 3. 阐明编码规范\n\n清晰的编码规范指导 Copilot 如何编写代码，例如 JavaScript/TypeScript 是否使用分号、Python 是否使用类型提示、使用制表符还是空格。作者倾向于将规范单独列为一个部分，因为许多规范适用于所有使用的语言，且更具可读性。也可以使用 `.instructions` 文件为特定类型的文件或单元测试提供指导。\n\n*   **专业提示：** “不完美”的指令文件也比什么都没有强得多。指令文件应随时间演进。\n*   **示例项目和代码规范：**\n    *   支持类型提示的语言始终使用类型提示。\n    *   JavaScript/TypeScript 使用分号。\n    *   单元测试和端到端测试是必需的，且在 PR 前必须通过，并应关注核心功能和可访问性。\n    *   始终遵循良好的安全实践和 RESTful API 设计原则。\n    *   可用时使用脚本执行操作。\n\n## 4. 解释项目结构\n\n项目结构多种多样，在自定义指令文件中列出项目结构，不仅可以节省 Copilot 的工作，还能提供关于文件夹内容的更多上下文。\n\n*   **示例项目结构：**\n    *   `server/`：Flask 后端代码\n    *   `models/`：SQLAlchemy ORM 模型\n    *   `routes/`：按资源组织的 API 端点\n    *   `tests/`：API 的单元测试\n    *   `utils/`：实用函数和辅助工具，包括数据库调用\n    *   `client/`：Astro/Svelte 前端代码\n    *   `src/components/`：可重用 Svelte 组件\n    *   `src/layouts/`：Astro 布局模板\n    *   `src/pages/`：Astro 页面和路由\n    *   `src/styles/`：CSS 样式表\n    *   `scripts/`：开发、部署和测试脚本\n    *   `docs/`：项目文档，需始终保持同步\n\n## 5. 指明可用的资源\n\n几乎每个项目都有辅助开发的脚本或资源。在自定义指令文件中提供这些资源的指针，可以提高 Copilot 的准确性和速度。\n\n*   **示例资源：**\n    *   `scripts` 文件夹：`start-app.sh` (安装库并启动应用), `setup-env.sh` (安装库), `test-project.sh` (安装库，运行单元和端到端测试)。\n    *   MCP 服务器：Playwright (用于生成 Playwright 测试或与站点交互), GitHub (用于与仓库和待办事项列表交互)。\n\n## 额外提示：让 GitHub Copilot 帮助你创建自定义指令文件\n\nCopilot 可以帮助你生成初始的 `copilot-instructions.md` 文件。文章提供了一个详细的提示示例，用于指导 Copilot 创建该文件，包括目标、限制、指导和遵循的步骤。使用此提示不仅可以节省时间，还可以帮助你理清项目思路和目标。\n\n## 总结\n\n拥有一个良好的指令文件是提高 Copilot 代码建议质量的重要第一步。`copilot-instructions.md` 文件应被视为任何使用 Copilot 的项目的必需品。从项目概览、技术栈、编码规范、项目结构和可用资源这几个基本部分开始，然后可以进一步探索更具体的 `.instructions` 文件。",
      "shortSummary": "为 GitHub Copilot 编写有效的自定义指令能显著提升代码建议质量。核心在于通过 `copilot-instructions.md` 文件提供清晰的上下文。关键技巧包括：提供项目概览、明确技术栈、阐明编码规范、解释项目结构，以及指明可用资源。这些指导帮助 Copilot 更好地理解项目，生成更准确的代码。即使不完美，一个指令文件也远胜于无。Copilot 甚至可以协助生成这些指令文件。",
      "translated_title": "为 Copilot 编写更优自定义指令的 5 个技巧",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>This guide offers five essential tips for writing effective GitHub Copilot custom instructions, covering project overview, tech stack, coding guidelines, structure, and resources, to help developers get better code suggestions.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/5-tips-for-writing-better-custom-instructions-for-copilot/\">5 tips for writing better custom instructions for Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "AI驱动的规范开发：从新的开源工具包开始 (原标题: Spec-driven development with AI: Get started with a new open source toolkit)",
      "link": "https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/",
      "pubDate": "Tue, 02 Sep 2025 16:48:03 +0000",
      "isoDate": "2025-09-02T16:48:03.000Z",
      "creator": "Den Delimarsky",
      "summary": "## AI驱动的规范开发：从新的开源工具包开始\n\n### 引言：AI编码的挑战与规范的重要性\n当前，AI编码代理日益强大，但普遍存在一个问题：生成的代码看似正确，却往往无法正常工作。这种“凭感觉编码”的方式适用于快速原型，但在构建关键任务应用或处理现有代码库时并不可靠。问题不在于AI的编码能力，而在于我们的方法。我们常常将AI编码代理视为搜索引擎，但它们更像是需要明确指令的、字面意义上的结对程序员。它们擅长模式识别，但仍需要清晰无歧义的指示。\n\n为此，我们正在重新思考规范——不再是静态文档，而是随项目演进的、活的、可执行的工件。规范成为共享的真理来源：当出现不明确之处时，回到规范；当项目变得复杂时，完善规范；当任务过于庞大时，将其分解。\n\n### Spec Kit：AI驱动规范开发的新工具包\nSpec Kit是我们新推出的开源工具包，旨在通过结构化的流程，将规范驱动开发引入您的AI编码工作流，支持GitHub Copilot、Claude Code和Gemini CLI等工具。\n\n### Spec Kit的四阶段规范驱动流程\nSpec Kit将您的规范置于工程流程的中心。其核心洞察在于：每个阶段都有特定的任务，并且只有当前任务得到充分验证后，才能进入下一阶段。您的主要角色是引导，而编码代理则负责大部分的编写工作。该流程分为四个阶段，并设有清晰的检查点：\n\n1.  **规定（Specify）**\n    *   **目标：** 您提供关于要构建什么以及为什么构建的高层描述，编码代理将生成详细的规范。\n    *   **内容：** 关注用户旅程、用户体验以及成功的定义。例如，谁将使用它？它为用户解决了什么问题？他们将如何与它互动？哪些结果是重要的？\n    *   **特点：** 这不是关于技术栈或应用设计，而是关于映射您希望创建的用户体验。它是一个活的工件，会随着您对用户及其需求的了解而演进。\n\n2.  **规划（Plan）**\n    *   **目标：** 您提供所需的技术栈、架构和约束，编码代理将生成全面的技术计划。\n    *   **内容：** 包括公司标准技术、与遗留系统的集成、合规性要求或性能目标等。您可以要求生成多个计划变体进行比较。\n    *   **优势：** 如果将内部文档提供给编码代理，它能将您的架构模式和标准直接整合到计划中，确保AI在开始工作前理解“游戏规则”。\n\n3.  **任务（Tasks）**\n    *   **目标：** 编码代理根据规范和计划，将其分解为实际的工作。\n    *   **内容：** 生成小而可审查的任务块，每个任务解决一个特定的问题。每个任务都应能独立实现和测试，这为AI提供了一种验证工作和保持进度的机制，类似于AI代理的测试驱动开发过程。\n    *   **示例：** 任务不再是“构建身份验证”，而是具体的“创建验证电子邮件格式的用户注册端点”。\n\n4.  **实施（Implement）**\n    *   **目标：** 您的编码代理逐一（或并行）处理任务。\n    *   **开发者角色：** 您作为开发者，审查聚焦于解决特定问题的代码变更，而不是数千行的代码转储。编码代理知道要构建什么（因为规范告诉它），知道如何构建（因为计划告诉它），也知道具体要做什么（因为任务告诉它）。\n    *   **关键：** 您的角色不仅是引导，更是验证。在每个阶段，您都需要反思和完善：规范是否捕捉了您真正想构建的内容？计划是否考虑了实际约束？AI是否遗漏了什么或错过了边缘情况？该流程内置了明确的检查点，供您批判生成的内容、发现差距并在继续前进之前进行纠正。AI生成工件，您确保它们是正确的。\n\n### 为何此方法有效？\n这种方法之所以成功，是因为语言模型的工作原理：它们擅长模式补全，但不擅长“读心术”。像“为我的应用添加照片分享功能”这样模糊的提示，会迫使模型猜测数千个未说明的需求，导致AI做出不准确的假设。相比之下，预先提供清晰的规范、技术计划和聚焦的任务，能为编码代理提供更高的清晰度，从而提高其整体效率。它不再猜测您的需求，而是知道要构建什么、如何构建以及按什么顺序构建。\n\n此方法适用于不同的技术栈（Python、JavaScript、Go等），因为核心挑战都是将意图转化为可工作的代码。规范清晰地捕捉意图，计划将其转化为技术决策，任务将其分解为可实现的部分，而AI编码代理则负责实际编码。\n\n对于大型组织，此方法解决了另一个关键问题：如何管理安全策略、合规规则、设计系统约束和集成需求？这些信息往往分散在各处。通过Spec Kit，所有这些内容都整合到规范和计划中，AI可以实际使用它们。安全要求不再是事后考虑，而是从第一天起就融入规范；设计系统也不再是后期附加，而是指导实施的技术计划的一部分。\n\n这种方法的迭代性赋予了它力量。传统开发可能使您早期决策受限，而规范驱动开发则使改变方向变得简单：只需更新规范，重新生成计划，然后让编码代理处理其余部分。\n\n### 适用场景\n规范驱动开发在以下三种场景中特别有效：\n\n1.  **全新项目（Greenfield，从零到一）：** 在启动新项目时，虽然直接开始编码很诱人，但前期投入少量工作创建规范和计划，能确保AI构建出您真正想要的东西，而非基于常见模式的通用解决方案。\n2.  **现有系统功能开发（Feature work，从N到N+1）：** 这是规范驱动开发最强大的应用场景。在复杂现有代码库中添加功能非常困难。通过为新功能创建规范，可以明确其与现有系统的交互方式。计划随后编码架构约束，确保新代码与项目原生融合，而非附加物。这使得持续开发更快、更安全。\n3.  **遗留系统现代化（Legacy modernization）：** 当需要重建遗留系统时，原始意图往往已随时间流逝。通过Spec Kit提供的规范驱动开发流程，您可以将核心业务逻辑捕获到现代规范中，在计划中设计全新的架构，然后让AI从头开始重建系统，而无需继承技术债务。核心优势在于将稳定的“是什么”与灵活的“如何做”分离，从而实现迭代开发而无需昂贵的重写。\n\n### 未来展望\n我们正在从“代码是真理来源”转向“意图是真理来源”。有了AI，规范成为真理来源，并决定了构建什么。这并非因为文档变得更重要，而是因为AI使规范变得可执行。当您的规范自动转化为可工作的代码时，它就决定了构建什么。Spec Kit是我们使这一转变成为现实的实验。我们将其开源，因为这种方法超越了任何单一工具或公司，真正的创新在于流程。未来我们将探讨如何将规范驱动开发实践与上下文工程相结合，以构建更高级的AI工具。\n\n我们期待听到您的使用体验和改进建议！如果您正在使用规范驱动模式进行开发，请与我们分享您的经验。我们特别关注：\n*   使工作流更具吸引力和可用性。\n*   可能的VS Code集成。\n*   比较和差异化多个实现。\n*   在组织中大规模管理规范和任务。\n\n我们很高兴看到您利用AI找到更好的方法，将人类的创造力转化为可工作的软件。\n\n### 作者信息\n由 ![Den Delimarsky](https://avatars.githubusercontent.com/u/53200638?v=4&s=200) 首席产品经理 Den Delimarsky 撰写。\n\n### 更多来自GitHub的探索\n*   **文档：** ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) 掌握GitHub所需的一切，尽在一个地方。前往文档\n*   **GitHub：** ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) 在GitHub上构建未来，这里是任何人、任何地方构建任何东西的平台。开始构建\n*   **客户案例：** ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) 了解使用GitHub进行构建的公司和工程团队。了解更多\n*   **GitHub Universe 2025：** ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) 最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山与我们相聚。立即注册",
      "shortSummary": "AI编码常因指令模糊而失败。Spec Kit是一个开源工具包，通过将规范作为核心，实现AI驱动的规范开发。它包含“规定、规划、任务、实施”四个阶段，确保AI在明确的意图、技术计划和细化任务指导下生成高质量代码。开发者在每个阶段验证和完善，将“意图”而非“代码”作为真理来源。此方法适用于新项目、功能开发和遗留系统现代化，解决了AI“凭感觉编码”的问题，提高了开发效率和准确性。",
      "translated_title": "AI驱动的规范开发：从新的开源工具包开始",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/53200638?v=4&s=200",
          "alt": "Den Delimarsky",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Developers can use their AI tool of choice for spec-driven development with this open source toolkit.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/\">Spec-driven development with AI: Get started with a new open source toolkit</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "揭秘：探索驱动 GitHub Copilot 的 AI 模型 (原标题: Under the hood: Exploring the AI models powering GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/under-the-hood-exploring-the-ai-models-powering-github-copilot/",
      "pubDate": "Fri, 29 Aug 2025 16:14:42 +0000",
      "isoDate": "2025-08-29T16:14:42.000Z",
      "creator": "Alexandra Lietzke",
      "summary": "## 揭秘：探索驱动 GitHub Copilot 的 AI 模型\n\n自2021年首次发布以来，GitHub Copilot 及其背后的 AI 模型经历了显著演进，从单一模型发展为多模型架构，始终以开发者为中心，旨在提升工作效率和流程顺畅度。\n\n### GitHub Copilot 的演进：从 Codex 到多模型架构\n\n*   **早期阶段**：GitHub Copilot 于2021年推出时，由 **Codex**（GPT-3 的衍生模型）提供支持。Codex 在理解和生成代码方面的能力在当时是革命性的，证明了 AI 作为开发者工具的巨大潜力。\n*   **当前发展**：Copilot 已从 Codex 转型，现在默认使用最新的前沿模型，并允许开发者选择多种高级模型。其功能也从最初的 IDE 内自动补全和代码生成，扩展到回答问题、生成测试、调试代码、分配任务、生成拉取请求、协助代码审查、分析代码库，甚至修复安全漏洞等。\n\n### 为何提供多模型？\n\n转向多模型架构不仅是为了跟上 AI 技术的进步，更重要的是为了赋予开发者选择权，让他们可以根据手头的任务选择最适合的 LLM。不同的模型擅长不同的任务，集成多样化的模型使 GitHub Copilot 能够通过以下功能提供更定制化、更强大的体验：\n\n*   **基础智能**：GitHub Copilot 现在默认在聊天、代理模式和代码补全中使用 **GPT-4.1**。该模型针对开发者工作流进行了优化，兼顾速度、推理能力和上下文处理，支持30多种编程语言。\n*   **前沿模型访问**：在 Pro+、Business 和 Enterprise 订阅层级中，开发者可以通过模型选择器访问一系列高级模型，包括：\n    *   **Anthropic**：Claude Sonnet 3.5, Claude Sonnet 3.7, Claude Sonnet 3.7 Thinking, Claude Sonnet 4, Claude Opus 4 (预览), Claude Opus 4.1 (预览)\n    *   **OpenAI**：GPT-4.1, GPT-5 (预览), GPT-5 mini (预览), o3 (预览), o3-mini, o4-mini (预览)\n    *   **Google**：Gemini 2.0 Flash, Gemini 2.5 Pro\n    每个选项在速度、推理深度和多模态能力之间提供不同的权衡。\n\n### 代理工作流中的开发者选择\n\nCopilot 对多模型的支持，赋予了开发者自主选择构建方式的权力，无论是优先考虑速度、精确性还是创造力。这种灵活性使得开发者能够根据个人偏好定制体验，从而转化为实际的生产力提升。Copilot 的代理能力意味着：\n\n*   开发者无需切换编辑器或离开 GitHub，Copilot 作为 GitHub 原生工具，直接在 IDE 和 GitHub 中运行，便于在不中断流程的情况下委派任务。\n*   开发者可以根据自己的偏好工作，无论是通过 Copilot 自动化任务、接受建议修复，还是让编码代理接管。\n*   Copilot 能够全面理解代码库上下文，分析和索引代码，尊重分支保护，并无缝融入现有审查流程。\n*   Copilot 处理繁琐工作，如分类评论、修补漏洞或解决跨代码库的阻塞问题，让开发者专注于核心任务。\n\n### Copilot 如何选择模型\n\nGitHub Copilot 不仅仅是一个单一的 AI 模型，它是一个动态平台，能够智能地将正确的模型与正确的任务匹配。这种灵活性是提供无缝开发者体验的核心，并基于对开发者工作方式、需求和时机的深刻理解。\n\n#### 模型与功能的匹配\n\n每个 Copilot 功能都由一个专门选择的模型提供支持，以满足其独特需求：\n\n*   **代码补全**：现在默认使用 GPT-4.1，针对30多种编程语言的速度、准确性和相关性进行了优化。\n*   **代理模式**：专为更复杂的、多步骤任务设计，利用具有高级推理和规划能力的模型。默认使用 GPT-4.1，但开发者可以根据专业需求选择其他高级模型，如 Anthropic 的 Claude Sonnet 系列、Google 的 Gemini 2.0 Flash 或 OpenAI 的推理模型（o1, o3-mini）。\n*   **Copilot 聊天**：对于关于代码和开发概念的自然语言查询，Copilot 聊天依赖于具有强大语言理解和生成能力的模型。默认运行在 GPT-4.1 上，并可选择 Claude 3.5/3.7 Sonnet、Claude 3.7 Sonnet Thinking、Gemini 2.0 Flash、o1 和 o3-mini 等模型。\n*   **编码代理 (新)**：当开发者委派任务（如分类问题、生成拉取请求或修补漏洞）时，Copilot 编码代理可以作为一个有用的工具，将 Copilot 变成一个可以交接任务的“同事”。\n*   **代码审查 (新)**：代码审查是 GitHub Copilot 功能集的新增部分，由 GPT-4.1 提供支持，因为它在准确性和响应速度之间取得了平衡。对于大型代码库的深度推理，开发者可以选择 Claude 3.7 Sonnet 或 Claude 3.7 Sonnet Thinking 等模型。\n\n#### 针对不同任务选择模型\n\n开发任务的复杂性和上下文各不相同。因此，GitHub Copilot 允许用户选择最适合其需求的模型，尤其是在聊天和代理模式下：\n\n*   **o4-mini (OpenAI)**：速度快，低延迟补全。\n*   **GPT-4.1 (OpenAI)**：平衡性能和多模态支持。\n*   **GPT-5 mini (OpenAI)**：轻量级推理。\n*   **GPT-5 (OpenAI)**：用于复杂任务的高端推理。\n*   **o3 (OpenAI)**：高级规划和多步骤推理。\n*   **Claude Sonnet 3.5**：可靠的日常编码任务。\n*   **Claude Sonnet 3.7**：大型代码库的深度推理。\n*   **Claude Sonnet 3.7 Thinking**：长周期、结构化问题解决。\n*   **Claude Sonnet 4**：更高的推理深度。\n*   **Claude Opus 4**：高级推理能力。\n*   **Claude Opus 4.1**：最先进的 Anthropic 选项。\n*   **Gemini 2.0 Flash (Google)**：快速、多模态能力。\n*   **Gemini 2.5 Pro (Google)**：高级多模态推理。\n\n### 近期升级：全面采用 GPT-4.1\n\nCopilot 聊天、代码补全和拉取请求摘要现在均运行在 OpenAI 的 GPT-4.1 上。此次升级带来了：\n\n*   **更快的响应**：响应生成速度比 GPT-4o 快约40%。\n*   **增加的上下文窗口**：支持比以前默认模型显著更多的上下文。\n\nPro+、Business 和 Enterprise 计划的高级模型访问权限已扩展，包括 Anthropic、Google 和 OpenAI 的广泛强大 AI 选项。新的 Pro+ 层级使个人开发者也能解锁这些高级模型的全部潜力。\n\n### 总结\n\n随着 AI 世界的不断发展，驱动 GitHub Copilot 的模型也将持续演进。GitHub 致力于不断完善和更新其 AI 基础设施，以提供最佳的开发者体验。鼓励开发者探索 Copilot 中可用的不同模型，发现它们如何增强编码旅程。",
      "shortSummary": "GitHub Copilot 已从单一的 Codex 模型演变为多模型架构，目前默认使用 GPT-4.1，并为高级订阅用户提供 Anthropic、OpenAI 和 Google 的多种前沿模型选择。这种多模型策略赋予开发者根据任务需求（如速度、推理深度）进行选择的灵活性。Copilot 的代理能力深度集成到 GitHub 工作流中，能处理复杂任务和重复性工作，显著提升了开发者体验和生产力。近期升级使 Copilot 聊天、代码补全和拉取请求摘要响应速度更快，上下文窗口更大。",
      "translated_title": "揭秘：探索驱动 GitHub Copilot 的 AI 模型",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Learn how GitHub Copilot’s evolving models and infrastructure center developer choice and power agentic workflows.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/under-the-hood-exploring-the-ai-models-powering-github-copilot/\">Under the hood: Exploring the AI models powering GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 模型如何帮助开源维护者专注于重要事项 (原标题: How GitHub Models can help open source maintainers focus on what matters)",
      "link": "https://github.blog/open-source/maintainers/how-github-models-can-help-open-source-maintainers-focus-on-what-matters/",
      "pubDate": "Thu, 28 Aug 2025 19:02:44 +0000",
      "isoDate": "2025-08-28T19:02:44.000Z",
      "creator": "Ashley Wolf",
      "summary": "## GitHub 模型如何帮助开源维护者专注于重要事项\n\n### 引言：开源维护者的挑战与 GitHub Models 的诞生\n\n开源项目的发展离不开维护者的热情与坚持。然而，维护者常常被大量重复性任务所困扰，例如问题分类、审查贡献、管理重复项和手动标记等。这些必要但繁琐的工作占据了他们大量时间，使其无法专注于项目最初吸引他们的核心开发工作。为了解决这一痛点，GitHub 推出了 GitHub Models，旨在利用 AI 自动化这些重复性的项目管理任务，将 AI 直接融入代码和工作流中，从而让维护者能够重新聚焦于项目的核心价值。\n\n### 维护者对 AI 需求调查结果\n\nGitHub 对 500 多名领先开源项目的维护者进行了调查，以了解他们对 AI 的具体需求：\n\n*   **60%** 的维护者希望在问题分类（包括标记、归类和管理流程）方面获得帮助。\n*   **30%** 的维护者需要重复问题检测，即自动查找和链接相似问题。\n*   **10%** 的维护者寻求垃圾信息保护，以过滤低质量的贡献。\n*   **5%** 的维护者需要“低质量拉取请求”（“slop”）检测，以识别那些增加噪音的低质量贡献。\n\n调查还显示，维护者希望 AI 充当“第二双眼睛”，除非明确要求，否则不应主动干预。他们最关注的需求包括问题分类、查找相似问题以及帮助编写最小复现步骤。此外，根据主题或功能对问题进行聚类也被一些维护者认为是至关重要的。\n\n### GitHub Models + GitHub Actions = 持续维护者支持 (Continuous AI)\n\nGitHub 将这种模式称为“持续 AI”，它通过自动化的 AI 工作流来增强协作，其变革性作用类似于 CI/CD 对测试和部署的影响。通过结合 GitHub Models 和 GitHub Actions，维护者可以立即开始应用这一模式。要启用此功能，只需在仓库或组织中启用 GitHub Models，并将提供的 YAML 配置复制到项目的 `.github/workflows` 目录中。在工作流 YAML 中添加 `permissions: models: read` 即可让 Action 使用内置的 `GITHUB_TOKEN` 调用模型，无需特殊设置或外部密钥。\n\n### 核心应用场景与示例\n\n以下是 GitHub Models 结合 GitHub Actions 帮助维护者管理项目的具体示例：\n\n1.  **自动问题去重 (Automatic Issue Deduplication)**\n    *   **问题：** 维护者经常收到多个描述相同 bug 的问题报告。\n    *   **解决方案：** 实现 GitHub Models 工作流，自动检查新问题是否与现有问题相似，并发布包含链接的评论。\n    *   **示例工作流：** 使用 `pelikhan/action-genai-issue-dedup@v0`，可调整标签、检查数量和回溯时间窗。\n\n2.  **问题完整性检查 (Issue Completeness)**\n    *   **问题：** Bug 报告常缺少关键信息，如版本号、复现步骤或预期/实际行为。\n    *   **解决方案：** 自动检测不完整问题，并友好地请求缺失的详细信息。\n    *   **示例工作流：** 使用 `actions/ai-inference@v1` 结合特定提示，机器人会根据分析结果评论请求补充信息。\n\n3.  **垃圾信息和“低质量”内容检测 (Spam and “slop” detection)**\n    *   **问题：** 维护者会收到垃圾拉取请求或低质量的“修复拼写错误”等贡献。\n    *   **解决方案：** 使用 AI 自动标记可疑或低质量的贡献（如“spam”、“ai-generated”、“needs-review”）。\n    *   **示例工作流：** 使用 `actions/ai-inference@v1` 进行检测，然后 `actions/github-script@v7` 根据 AI 判断自动添加标签。\n\n4.  **持续问题解决器 (Continuous Resolver)**\n    *   **问题：** 仓库中积累了数百个开放问题，其中许多可能已解决或过时，手动关闭耗时耗力。\n    *   **解决方案：** 运行一个定期调度的工作流，识别已解决或不再相关的问题和拉取请求，并自动评论或关闭它们。\n    *   **示例工作流：** 使用 `ashleywolf/continuous-ai-resolver@main`，有助于贡献者找到活跃且相关的工作，避免“问题堆积”。\n\n5.  **新贡献者引导 (New contributor onboarding)**\n    *   **问题：** 首次贡献者提交拉取请求时，可能遗漏了 `CONTRIBUTING.md` 中的关键步骤。\n    *   **解决方案：** 发送 AI 生成的友好欢迎消息，其中包含指南链接和有益建议。\n    *   **示例工作流：** 使用 `actions/ai-inference@v1` 生成欢迎消息，然后 `actions/github-script@v7` 发布评论，帮助新贡献者成功融入。\n\n### 最佳实践\n\n*   从小处着手，逐步扩展自动化。\n*   在完全信任自动化之前，让维护者了解其运作情况。\n*   自定义 AI 提示，使其与项目语调和风格保持一致。\n*   持续监控结果并根据需要进行调整。\n*   避免一刀切的自动化、未经审查的更改或任何可能骚扰贡献者的行为。\n\n### 如何开始\n\n如果您准备尝试使用 AI：\n\n1.  在仓库设置中启用 GitHub Models。\n2.  使用 Playground 测试提示和模型。\n3.  将有效的提示保存为 `.prompt.yml` 文件。\n4.  使用上述示例构建您的第一个 Action。\n5.  与社区分享您的经验，共同学习和改进这些工具。\n\n### 相关资源\n\n*   文章作者：Ashley Wolf\n    ![Ashley Wolf](https://avatars.githubusercontent.com/u/10735907?v=4&s=200)\n*   探索更多来自 GitHub 的资源：\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) **文档：** 掌握 GitHub 所需的一切。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) **GitHub：** 在 GitHub 上构建未来。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) **客户案例：** 了解使用 GitHub 的公司和工程团队。\n    *   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) **GitHub Universe 2025：** 注册参加即将举行的活动。",
      "shortSummary": "GitHub Models 利用 AI 自动化开源项目维护中的重复性任务，帮助维护者专注于核心开发。通过与 GitHub Actions 结合，实现“持续 AI”工作流，解决问题分类、重复检测、垃圾信息过滤、问题清理和新贡献者引导等痛点。调查显示，维护者最需要 AI 协助处理问题分类和重复问题。文章提供了具体的工作流示例和最佳实践，旨在提高效率并改善社区体验，让维护者能够更有效地管理项目。",
      "translated_title": "GitHub 模型如何帮助开源维护者专注于重要事项",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/10735907?v=4&s=200",
          "alt": "Ashley Wolf",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how GitHub Models helps open source maintainers automate repetitive tasks like issue triage, duplicate detection, and contributor onboarding — saving hours each week.</p>\n<p>The post <a href=\"https://github.blog/open-source/maintainers/how-github-models-can-help-open-source-maintainers-focus-on-what-matters/\">How GitHub Models can help open source maintainers focus on what matters</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "我们如何使用 Copilot 加速秘密保护工程 (原标题: How we accelerated Secret Protection engineering with Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-we-accelerated-secret-protection-engineering-with-copilot/",
      "pubDate": "Thu, 28 Aug 2025 17:08:51 +0000",
      "isoDate": "2025-08-28T17:08:51.000Z",
      "creator": "Parth Sehgal",
      "summary": "GitHub Secret Protection 旨在帮助开发团队在凭据造成损害之前捕获暴露的凭据。它通过为代码中发现的敏感凭据创建警报来工作，并提供多种功能来进一步缓解泄露：\n\n*   **推送保护**：在泄露发生前阻止包含敏感数据的提交。\n*   **有效性检查**：通过指示哪些秘密是活跃的并需要立即关注来帮助用户分类警报。这是通过针对与令牌提供商关联的非侵入性 API 端点进行测试来计算凭据的有效性。\n*   **合作伙伴计划**：允许提供商收到公共存储库中某些令牌类型泄露的通知。\n*   **Copilot 秘密扫描**：检测通用秘密，如密码或连接字符串。\n*   **自定义模式**：定义用于检测项目或组织特定秘密的表达式。\n\nGitHub 的 Aaron 和 Parth 在有效性检查方面投入了大量工作，该功能于 2023 年发布，最初支持最常见的令牌类型（如 AWS 密钥、GCP 凭据、Slack 令牌），并能验证大约 80% 的新创建警报。然而，对于不那么常见的令牌类型，扩展支持的速度较慢。\n\n### 利用智能代理加速工作流\n\n随着 2024 年底到 2025 年智能 AI 和编码代理的兴起，团队开始探索使用编码代理来弥补这一差距。他们审视了现有添加新令牌类型验证支持的框架驱动工作流：\n\n1.  研究提供商以确定合适的令牌验证端点。\n2.  编写代码（验证器）。\n3.  暗发布（darkship）验证器，观察错误。\n4.  完全发布验证器。\n\n![一个图表展示了研究、编码、暗发布（观察）和发布的框架驱动工作流。根据需要，工作流可以在“暗发布”之后重复“编码”步骤。](https://github.blog/wp-content/uploads/2025/08/validation_copilot_workflow.png?resize=1024%2C294)\n\n编码和发布步骤（第二和第四步）被确定为自动化的首选目标。研究步骤（第一步）仍需人工干预，因为 Copilot 在可靠地找到最不具侵入性的端点、创建和测试实时令牌以及解释细微的 API 变化方面存在困难。\n\n### Copilot 的实施与效果\n\n*   **集成方式**：人工驱动的研究任务的输出被输入到一个手动调度的 GitHub 工作流中，该工作流创建一个详细的问题，可分配给编码代理。该问题作为全面的提示，包含项目背景、API 文档链接和示例。为了解决 Copilot 有时难以遵循链接的问题，还添加了额外的备注字段。\n\n![GitHub Actions“运行工作流”表单的屏幕截图，用于创建新的验证器。表单显示了分支的下拉菜单，以及令牌类型、令牌名称、提供商、文档 URL、端点 URL、验证器的其他备注的文本字段，所有这些都使用来自 Example.com 的 PAT 作为演示的示例输入。](https://github.blog/wp-content/uploads/2025/08/482245106-12fa681b-7c3e-4660-9b12-6a08ce4ade5e.png?resize=1371%2C718)\n\n*   **代理输出**：Copilot 自动生成拉取请求，将研究和规划转化为可操作的代码。这些代码经过自动化测试、人工审查，并最终由工程师部署。\n*   **局限性**：Copilot 并非完美无缺，有时会遗漏细节或未能按预期遵循文档。\n*   **暗发布阶段**：工程师利用暗发布阶段来安全地修复 API 文档与实际行为之间的任何差异。\n*   **成果**：在引入 AI 之前，团队花费数月时间验证了 32 种合作伙伴令牌类型。而通过 Copilot，工程实习生在短短几周内指导 Copilot 增加了近 90 种新类型。Copilot 显著提高了速度和规模，成为一个“倍增器”，能够并行处理多个研究任务的输出。\n\n### 经验与启示\n\n*   **自动化放大可重复性**：对于定义明确的流程，编码代理可以扩展工作并倍增影响力。\n*   **将 Copilot 视为团队成员**：其贡献需要与人类代码相同的仔细审查、测试和反馈。\n*   **提示质量决定结果**：详细、示例丰富的提示（有时需要额外备注）有助于 Copilot 交付高质量的拉取请求。\n*   **迭代优化流程**：提示和工作流需要不断完善和调整。\n*   **并行化是超能力**：通过适当的设置，可以同时分配多项任务，解除原本会排队等待单个工程师处理的工作。\n\n团队认为，在任何存在可重复工程任务的地方，编码代理都具有巨大潜力。他们鼓励其他团队利用可重复性、投资高质量提示，并始终将协作和审查置于核心地位。",
      "shortSummary": "GitHub Secret Protection 旨在防止凭据泄露，其中有效性检查是核心功能。为加速对不常见令牌类型的支持，团队引入了 Copilot 编码代理。通过将 Copilot 整合到验证工作流的编码和发布阶段，团队在数周内增加了近 90 种令牌类型，而此前数月仅增加了 32 种。Copilot 显著提升了效率和规模，但人类的判断、代码审查和高质量的提示仍然至关重要。",
      "translated_title": "我们如何使用 Copilot 加速秘密保护工程",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/validation_copilot_workflow.png?resize=1024%2C294",
          "alt": "A diagram showing the framework-driven workflow of research, code, darkship (observe), and release. As needed, the workflow can repeat the \"code\" step after \"darkship.\"",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/482245106-12fa681b-7c3e-4660-9b12-6a08ce4ade5e.png?resize=1371%2C718",
          "alt": "Screenshot of the GitHub Actions “Run workflow” form to create a new validator. Form shows a dropdown for branch, and text fields for Token Type, Token Name, Provider, Documentation URL, Endpoint URL, Other Notes for Validator all with sample input using a PAT from Example.comas demonstration.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://avatars.githubusercontent.com/u/3690636?v=4&s=200",
          "alt": "Parth Sehgal",
          "title": "",
          "position": 3
        },
        {
          "url": "https://avatars.githubusercontent.com/u/73763104?v=4&s=200",
          "alt": "Aaron Waggener",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how the Secret Protection engineering team collaborated with GitHub Copilot coding agent to expand validity check coverage.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-we-accelerated-secret-protection-engineering-with-copilot/\">How we accelerated Secret Protection engineering with Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何在github.com上使用GitHub Copilot：高级用户指南 (原标题: How to use GitHub Copilot on github.com: A power user’s guide)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-to-use-github-copilot-on-github-com-a-power-users-guide/",
      "pubDate": "Wed, 27 Aug 2025 16:00:00 +0000",
      "isoDate": "2025-08-27T16:00:00.000Z",
      "creator": "Andrea Griffiths",
      "summary": "## GitHub Copilot在github.com上的高级应用指南\n\n本文深入探讨了GitHub Copilot在github.com上的独特功能，这些功能与集成开发环境（IDE）中的Copilot有所不同，主要侧重于项目管理、团队协作和快速原型开发。它无需安装任何扩展或进行额外设置，用户只需访问github.com/copilot即可开始使用，将其作为AI驱动的命令中心。\n\n### 核心功能与应用场景\n\n#### 1. 从截图创建问题\n\n当遇到bug并有截图时，Copilot可以自动生成问题报告：\n*   **操作步骤**：\n    1.  截取bug的屏幕截图（例如，图标错位或布局问题）。\n    2.  将截图拖入github.com/copilot的聊天界面。\n    3.  添加提示，例如：“使用‘bug’标签创建一个新问题。使用此截图描述重叠的箭头图标。应用此仓库的UI问题模板。”\n*   **优势**：Copilot能够读取图像，生成清晰的标题和描述，应用正确的标签，并使用仓库的问题模板，比手动输入更快，且能捕捉到可能遗漏的细节。\n\n#### 2. 让智能代理处理日常工作\n\n问题创建后，可以将其分配给Copilot编码代理来处理解决方案：\n*   **操作步骤**：在聊天线程中，告诉Copilot：“将此问题分配给自己并起草一个修复方案。”\n*   **功能**：代理将分析代码库，识别根本原因，并提交一个包含修复方案的拉取请求草稿。\n*   **适用场景**：适用于常规bug、文档更新和依赖升级等任务。对于更复杂的特性，作者仍倾向于在IDE中进行手动开发。\n*   **专业提示**：代理可以跨问题工作、运行工作流并进行后续跟踪，就像一个团队成员一样。\n\n#### 3. 使用Spark进行实时原型开发\n\n当需要测试组件行为或验证设计理念时，GitHub Spark是一个强大的工具：\n*   **功能**：\n    *   快速搭建工作代码。\n    *   预览并与输出进行交互。\n    *   通过链接与协作者分享工作。\n*   **示例提示**：“为API定价页面创建一个功能对比表。显示免费、专业和企业层级，并用勾选标记表示功能。”\n*   **优势**：几分钟内即可获得带有实时预览的工作代码。可以直接在Spark、GitHub Codespaces或VS Code中编辑，即时查看更改，并发布和分享原型。\n*   **专业提示**：使用Spark可以实时运行和编辑代码片段，快速练习不熟悉的语法。\n\n#### 4. 为任务选择最佳模型\n\ngithub.com上提供多种AI模型，用户可以根据任务需求进行切换：\n*   **模型推荐**：\n    *   **GPT-4.1**：适用于通用编码和推理。\n    *   **Claude Sonnet 4**：适用于结构化写作、重构和上下文密集型任务。\n    *   **Opus 4**：适用于创造力、边缘案例和提供替代视角。\n*   **操作步骤**：在聊天线程中，点击模型名称，选择不同的模型并重新加载响应。\n*   **专业提示**：通过模型比较可以减少“幻觉”并提高输出质量。\n\n#### 5. 导航会话分支\n\nGitHub Copilot会将用户发送的每条消息下的多个响应进行分组，尤其是在切换模型时。这些分组就像独立的“会话分支”，彼此隔离：\n*   **实际应用**：\n    *   通过为同一问题切换模型来比较不同的重构方法。\n    *   通过审查多个AI生成的答案来测试多种架构模式。\n    *   并排探索替代解释，而不会混淆上下文。\n*   **专业提示**：将每条消息视为Git中的一个基础提交。模型切换会创建该消息下的替代响应，让用户无需重新开始即可审查不同的方法。\n\n#### 6. 战略性结合Web端与IDE\n\nCopilot在github.com和IDE结合使用时效能最高，各自发挥所长：\n\n| 任务           | 在github.com上使用，当您需要…         | 在IDE中使，当您需要…         |\n| :------------- | :---------------------------------- | :-------------------------- |\n| 项目协调       | 跨仓库可见性                        | 单一代码库焦点              |\n| 问题管理       | 创建和分配问题                      | 实施解决方案                |\n| 代理工作       | 通过编码代理进行异步自动化          | 通过代理模式进行实时协作    |\n| 原型开发       | 快速演示和分享                      | 深入调试                    |\n\n**工作流示例**：在github.com上启动项目讨论，在Spark中原型化解决方案，为团队创建问题，然后切换到VS Code进行实现。\n\n### 构建AI原生开发工作流\n\n一个典型的AI原生开发日可能包括：访问github.com/copilot，检查分配的拉取请求和问题，使用聊天总结项目状态和团队活动，指派代理处理新创建的问题，在Spark中原型化新想法，在线程中使用会话和切换模型，并通过拉取请求推送最终更改。关键在于，github.com上的Copilot处理协调和探索工作，而IDE处理详细的实现。两者结合，可以覆盖完整的开发工作流。\n\n### 结论\n\nGitHub Copilot在github.com上将浏览器转变为个人开发任务控制中心。它不再仅仅是代码自动补全工具，而是一个全面的工作流编排器。立即访问github.com/copilot开始构建您的AI原生开发流程。\n\n### 作者信息\n\n本文由 **Andrea Griffiths** 撰写。\n\n![Andrea Griffiths](https://github.blog/wp-content/uploads/2025/08/Andrea-Griffiths_avatar_1755783168-200x200.jpeg)\n\nAndrea是GitHub的高级开发者倡导者，拥有十多年的开发者工具经验。她将技术深度与使先进技术更易于访问的使命相结合。她居住在佛罗里达州，与她的威尔士伴侣、两个儿子和两条狗一起生活，并继续通过GitHub的全球倡议推动创新和支持开源。\n\n### 相关内容\n\n探索更多来自GitHub的内容：\n\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) **文档**：掌握GitHub所需的一切，尽在一个地方。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) **GitHub**：在GitHub上构建未来，这里是任何人都可以构建任何东西的地方。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) **客户案例**：了解使用GitHub进行构建的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) **GitHub Universe 2025**：最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山加入我们。",
      "shortSummary": "GitHub Copilot在github.com上提供与IDE不同的功能，专注于项目管理、团队协作和快速原型开发。用户可从截图创建问题，指派AI代理修复bug，并使用Spark快速搭建和分享原型。它支持切换多种AI模型以优化任务，并能管理会话分支。通过将github.com上的Copilot与IDE结合使用，可以实现从项目协调到代码实现的完整AI原生开发工作流，将其从代码补全工具转变为全面的工作流编排器。",
      "translated_title": "如何在github.com上使用GitHub Copilot：高级用户指南",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/Andrea-Griffiths_avatar_1755783168-200x200.jpeg",
          "alt": "Andrea Griffiths",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Explore how to use GitHub Copilot on github.com to automate tasks, assign agents, prototype ideas, and streamline your entire workflow — all without an IDE.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-to-use-github-copilot-on-github-com-a-power-users-guide/\">How to use GitHub Copilot on github.com: A power user’s guide</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "重新发现学习的乐趣：Jason Lengstorf 谈开发现状 (原标题: Rediscovering joy in learning: Jason Lengstorf on the state of development)",
      "link": "https://github.blog/developer-skills/career-growth/rediscovering-joy-in-learning-jason-lengstorf-on-the-state-of-development/",
      "pubDate": "Tue, 26 Aug 2025 16:10:14 +0000",
      "isoDate": "2025-08-26T16:10:14.000Z",
      "creator": "Andrea Griffiths",
      "summary": "# 重新发现学习的乐趣：Jason Lengstorf 谈开发现状\n\n本文探讨了开发者在学习新技能时普遍存在的焦虑，并结合 Jason Lengstorf（“Learn with Jason”和 CodeTV 创始人）的观点，提出了关于学习方法、AI 影响和开源可持续性的深刻见解。\n\n## 停止恐慌式学习，拥抱好奇心\n\n*   **问题现状：** 许多开发者因担心职业发展而被迫学习最新框架，导致恐慌和压力。Jason Lengstorf 认为这种方式是错误的，并强调学习应该是有趣的。\n*   **Jason 的主张：** “享受乐趣并非不工作。事实上，享受乐趣会让你更有可能记住知识，更有可能坚持完成项目并分享它。”他通过“Learn with Jason”项目，为开发者创造探索和发现的空间，而非填鸭式灌输。\n*   **益处：** 当开发者带着好奇心而非绝望去学习时，他们能更深入地吸收概念，更有意义地贡献项目，真正完成所启动的工作，并乐于分享知识。这也有助于为下一代开发者树立健康的学习榜样。\n\n## AI：赋能工具而非替代品\n\n*   **核心观点：** Jason 用“填缝剂和马桶搋子”与“水管工”的比喻来形容 AI 与熟练开发者的关系。AI 能够放大你已有的知识，但无法取代领域专业知识。\n*   **实际案例：** 在一次直播中，Jason 和 Jack Harrington 使用 AI 构建了一个 MCP (Model Context Protocol) 服务器。AI 自动生成了代码，但当遇到一个配置文件的组件名称缺失的 bug 时，Jack 因熟悉系统而迅速修复，而 Jason（即使有20年经验）则需要反向工程整个 AI 生成的代码才能调试。\n*   **AI 的影响：**\n    *   对于熟练开发者：极大地提高效率。\n    *   对于学习者：加速学习过程。\n    *   对于不愿学习者：迅速陷入更大的困境。\n*   **生态系统成熟：** 像 MCP 这样的共享标准出现，表明 AI 工具生态系统正从“每周一个新框架”的阶段走向成熟。\n\n## 支撑世界的开发者：开源维护者的重要性\n\n*   **隐形英雄：** 许多关键的开源基础设施（如 Zod、SQLite、全球时区数据库）由少数无名英雄维护，他们默默支撑着整个生态系统，包括大量 AI 应用。例如，Colin McDonald 维护着 Zod。\n*   **依赖现状：** 开发者日常使用的工具（如 Tailwind, ShadCN/UI, Vue, Nuxt, React）大多是个人维护者或小团队的无私贡献。\n*   **责任与支持：** 开发者应识别其工作中的“承重”依赖项，并通过 GitHub Sponsors 或其他方式提供经济支持。开源的可持续性关乎整个行业的健康，因为当关键基础设施依赖于无偿志愿者时，我们是在不稳定的基础上进行构建。\n\n## Web 创新的下一波浪潮\n\n*   **当前状态：** JavaScript 生态系统处于“奇怪的停滞期”，争论多于创新；而 CSS 正在经历蓬勃发展，新的浏览器功能不断涌现。\n*   **AI 对用户体验的改变：** Jason 预测 AI 将使 UX 变得更加对话式，减少对复杂导航按钮、嵌套下拉菜单和信息架构的需求。这并非意味着所有界面都变成聊天框，而是需要新的组件架构来整合操作网站不同部分的自主代理。\n*   **机遇：** 浏览器中运行的本地 AI 模型、MCP 等标准化协议以及 Web 适应性需求的融合，为独立开发者带来了类似早期 JavaScript 框架时代和边缘函数民主化企业级能力的巨大机遇。\n\n## 展望未来\n\n*   **核心建议：** 停止因恐惧而学习，开始因好奇而创造；支持那些为你的应用提供动力的维护者。\n*   **做好准备：** 那些拥抱快乐学习、理解并支持开源基础设施、并对新兴模式保持好奇的开发者，将能更好地利用 AI 工具，构建更稳定的基础，并塑造未来的发展。\n*   **关键在于：** 你是否享受这段旅程。\n\n---\n\n**作者信息：**\n![Andrea Griffiths](https://github.blog/wp-content/uploads/2025/08/Andrea-Griffiths_avatar_1755783168-200x200.jpeg)\n本文作者 Andrea Griffiths 是 GitHub 的高级开发者倡导者，拥有十余年开发者工具经验。她致力于将复杂工程概念与实际应用相结合，并积极推动开源。\n\n**更多资源：**\n*   ![Docs Icon](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 的一切，尽在一个地方。\n*   ![GitHub Icon](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来，这里是任何人、任何地方构建任何东西的平台。\n*   ![Customer Stories Icon](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 的公司和工程团队。\n*   ![GitHub Universe 2025 Icon](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：最后机会：节省 $700 购买 Universe 现场通行证，于10月28-29日在旧金山与我们相聚。立即注册！",
      "shortSummary": "Jason Lengstorf 倡导开发者停止因恐惧而学习，转而享受学习的乐趣，因为乐趣能提高知识保留和项目完成度。他认为 AI 是知识的放大器而非替代品，能加速熟练开发者和学习者的效率，但无法取代领域专业知识。文章强调了开源维护者对关键基础设施的重要性，呼吁开发者支持他们。未来，AI 将改变用户体验，带来新的 Web 创新机遇。核心在于以好奇心构建，支持开源，并享受学习过程。",
      "translated_title": "重新发现学习的乐趣：Jason Lengstorf 谈开发现状",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/Andrea-Griffiths_avatar_1755783168-200x200.jpeg",
          "alt": "Andrea Griffiths",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>We sit down with Jason Lengstorf on the GitHub Podcast, where he shares his perspective on education, AI, open source, and more.</p>\n<p>The post <a href=\"https://github.blog/developer-skills/career-growth/rediscovering-joy-in-learning-jason-lengstorf-on-the-state-of-development/\">Rediscovering joy in learning: Jason Lengstorf on the state of development</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-09-07T04:31:02.838Z"
}