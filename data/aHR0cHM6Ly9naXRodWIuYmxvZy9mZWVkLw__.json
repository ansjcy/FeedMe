{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "从结对编程到对等编程：GitHub Copilot 中智能代理工作流的愿景 (原标题: From pair to peer programmer: Our vision for agentic workflows in GitHub Copilot)",
      "link": "https://github.blog/news-insights/product-news/from-pair-to-peer-programmer-our-vision-for-agentic-workflows-in-github-copilot/",
      "pubDate": "Wed, 25 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-25T16:00:00.000Z",
      "creator": "Tim Rogers",
      "summary": "# GitHub Copilot：从结对编程到对等编程的智能代理工作流愿景\n\n## 引言：GitHub Copilot 的演进\n\nGitHub Copilot 最初于2021年推出时，被定位为“AI结对程序员”，旨在帮助开发者保持专注、减少样板代码并加速编码。然而，GitHub 的愿景是让 Copilot 不仅仅是一个助手，而是能够主动与开发者协作，包括同步任务、独立解决问题，甚至审查代码。这标志着 Copilot 正从一个辅助工具向一个能够主动解决问题的智能代理转变。\n\n## 智能代理的未来愿景\n\n未来的 GitHub Copilot AI 代理将通过多步骤推理和执行来积极解决问题，具备以下能力：\n\n*   **独立问题解决**：Copilot 将分解复杂任务并采取必要步骤来解决它们，并在此过程中提供更新。\n*   **自适应协作**：无论是与开发者同步工作，还是在后台独立运行，Copilot 都将迭代自己的输出以推动项目进展。\n*   **主动提升代码质量**：Copilot 将主动协助解决问题、测试和代码审查等任务，确保更高质量、更易于维护的代码。\n\nCopilot 的未来在于其在不同模式之间灵活切换的能力——独立执行任务，同时让开发者随时了解情况并保持控制。这种演变将使开发者能够专注于更高层次的决策，而 Copilot 则承担更多的执行工作。\n\n## Copilot 的实际应用：迈向愿景的步伐\n\n### 1. 代理模式（Agent Mode）：IDE 中的实时 AI 队友\n\n代理模式是 GitHub Copilot 中一个独立的 AI 代理，它存在于开发者的代码环境中，感觉就像将电脑交给队友几分钟。当开发者发出指令时，代理会接管控制，解决问题，并通过定期检查点报告其工作。其能力包括：\n\n*   读取整个工作区以理解上下文。\n*   规划多步骤的修复或重构（并首先展示计划）。\n*   应用更改、运行测试，并在紧密的反馈循环中迭代。\n*   在意图不明确时寻求指导。\n*   通过“代理循环”运行和完善自己的工作——规划、应用更改、测试和迭代。\n\n在代理模式下，Copilot 不仅仅响应请求，而是主动朝着开发者的目标努力。开发者定义结果，Copilot 决定最佳方法，并在需要时寻求反馈、测试自己的解决方案并实时完善工作。这就像是快速推进的结对编程：开发者实时观察任务的展开，可以随时介入或重新定向。\n\n### 2. 编码代理（Coding Agent）：在你休息时工作的 AI 队友\n\n并非所有编码都实时发生。有时，开发者需要将任务交给队友，稍后再检查。这就是编码代理的作用——它是 Copilot 转型为独立代理的第一步。编码代理在云端启动自己的安全开发环境。开发者可以向 Copilot 分配多个问题，然后专注于其他工作，而它则处理繁重的工作。其能力包括：\n\n*   克隆仓库并在隔离环境中引导工具。\n*   将问题分解为步骤，实现更改，并编写或更新测试。\n*   通过运行测试和 Linter 验证其工作。\n*   打开草稿拉取请求（PR），并根据 PR 审查意见进行迭代。\n*   流式传输进度更新，以便开发者可以随时查看或介入。\n\n与编码代理合作就像是请另一房间的队友（拥有自己的笔记本电脑和设置）来解决问题。开发者可以自由地处理其他事情，但可以随时查看状态或提供反馈。\n\n## Copilot 智能代理未来的下一阶段：三大支柱\n\nCopilot 的下一阶段将建立在三个融合的支柱之上：\n\n1.  **更智能、更精简的模型**：大型语言模型（LLM）的持续突破不断提高准确性，同时降低延迟和成本。扩展的上下文窗口现在可以覆盖整个单体应用，为 Copilot 提供了推理复杂代码库和返回基于实际代码答案所需的“长程记忆”。\n2.  **更深层的上下文感知**：Copilot 越来越能理解工作背后的完整故事——问题、拉取请求历史、依赖图，甚至私有运行手册和 API 规范（通过 MCP）。通过利用这种更丰富的上下文，它可以建议与项目意图而非仅语法对齐的更改。\n3.  **开放、可组合的基础**：Copilot 被设计为可以无缝集成到开发者的技术栈中。开发者选择编辑器、模型和工具；Copilot 则插入其中，学习开发者的模式并加以放大。开发者处于主导地位，引导 AI 以比以往任何时候都更快的速度构建、测试和发布代码。\n\n## 总结\n\n综合来看，这些支柱将 Copilot 从单一助手转变为一个灵活的 AI 队友——一个可以帮助任何团队（从车库里的三名开发者到全球企业中的数千名开发者）以更少的摩擦和更快的速度规划、编码、测试和发布代码的伙伴。下一波浪潮已经到来。\n\n## 相关信息\n\n*   **作者**：\n    ![Tim Rogers](https://avatars.githubusercontent.com/u/116134?v=4&s=200)\n    Staff Product Manager\n*   **相关文章**：\n    *   GitHub Copilot: Meet the new coding agent\n    *   Implementing features has never been easier: Just assign a task or issue to Copilot. It runs in the background with GitHub Actions and submits its work as a pull request.\n*   **探索更多来自 GitHub**：\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切，尽在一处。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来，这里是任何人都可以构建任何东西的地方。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 进行构建的公司和工程团队。\n    *   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：最后机会：节省700美元购买 Universe 线下通行证，于10月28-29日在旧金山加入我们。",
      "shortSummary": "GitHub Copilot正从“AI结对程序员”进化为“对等程序员”，旨在通过智能代理实现更深层次的协作。其愿景是让Copilot能独立解决问题、自适应协作并主动提升代码质量。目前已推出“代理模式”在IDE中实时协助，以及“编码代理”在云端独立完成任务。未来发展将基于更智能的模型、更深层的上下文感知和开放可组合的基础，使Copilot成为一个灵活的AI队友，加速软件开发，适用于各种规模的团队。",
      "translated_title": "从结对编程到对等编程：GitHub Copilot 中智能代理工作流的愿景",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/116134?v=4&s=200",
          "alt": "Tim Rogers",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>AI agents in GitHub Copilot don’t just assist developers but actively solve problems through multi-step reasoning and execution. Here’s what that means.</p>\n<p>The post <a href=\"https://github.blog/news-insights/product-news/from-pair-to-peer-programmer-our-vision-for-agentic-workflows-in-github-copilot/\">From pair to peer programmer: Our vision for agentic workflows in GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "在AI时代，为什么开发者专业知识比以往任何时候都更重要 (原标题: Why developer expertise matters more than ever in the age of AI)",
      "link": "https://github.blog/developer-skills/career-growth/why-developer-expertise-matters-more-than-ever-in-the-age-of-ai/",
      "pubDate": "Tue, 24 Jun 2025 17:04:47 +0000",
      "isoDate": "2025-06-24T17:04:47.000Z",
      "creator": "Laura Lindeman",
      "summary": "## 在AI时代，为什么开发者专业知识比以往任何时候都更重要\n\nAI工具的普及显著提高了开发者的编码速度，例如GitHub Copilot能让开发者编码速度提升高达55%，初级开发者甚至能实现27%至39%的生产力增长。然而，文章强调，仅仅追求速度是不够的。作为开发者，核心在于理解代码的运作原理、其在整体系统中的位置以及故障发生时的处理方式。真正的专业知识在于批判性思维和系统性解决问题的能力，这对于构建弹性、可扩展和安全的软件至关重要。\n\nGitHub首席执行官Thomas Dohmke指出：“初创公司可以用AI生成的代码启动，但没有经验丰富的开发者就无法扩展。” AI是开发者的“超能力”，但前提是开发者必须作为“人在回路中”的关键角色，理解代码的“为什么”，并能够调试、指导AI工具，超越“凭感觉编码”。\n\n### AI生产力红利 + 开发者经验 = 更大的影响力\n\n文章通过以下几点阐述了人类判断力如何倍增AI的价值：\n\n*   **更快的提交（任务完成速度提高达55%）**：开发者通过深思熟虑的代码审查、编写测试和发现边缘情况，确保速度不以牺牲质量为代价。\n*   **降低认知负荷**：释放的思维带宽使开发者能够设计更好的架构、指导队友并解决更高层次的问题。\n*   **初级开发者更容易上手**：资深工程师提供背景信息、建立标准，并将AI建议转化为教学机会，从而培养长期专业知识。\n*   **自动化样板代码**：开发者根据实际项目需求调整脚手架、质疑假设并及早重构，以控制技术债务并确保系统安全。\n\n### 缺乏判断力的速度带来的风险\n\n仅仅追求速度而缺乏判断力可能导致：\n\n*   静态分析无法独立发现的安全漏洞。\n*   无法扩展超越演示阶段的架构选择。\n*   导致人类和模型都难以理解的文档偏差。\n\n### 掌握基础：AI时代开发者应关注的三个关键工作流程\n\n文章指出，要充分利用AI开发工具的价值，开发者必须掌握传统基础知识。一个缺乏基础理解（如拉取请求、代码审查和文档）的初级开发者，即使能快速交付，也可能因缺乏上下文或结构而引入错误、遗漏边缘情况或导致协作混乱。这并非AI问题，而是基础问题。文章强调了以下三个核心技能：\n\n#### 1. 在拉取请求（Pull Request）中追求卓越\n\n拉取请求是开发者协作的核心，旨在清晰地传达意图、解释理由，并方便他人（包括人类和AI）理解和参与工作。一个范围明确的PR应解释变更的“为什么”，而不仅仅是“什么”。\n\n*   **关键实践**：\n    *   保持PR小而专注（建议≤300行）。\n    *   PR描述应解释“为什么”变更，并链接相关问题或对话。\n    *   明确请求何种反馈（例如，快速检查或深入审查）。\n    *   在请求审查前，先自行审查：运行测试、预览变更，并纠正任何不清晰或不完善之处。\n\n*   **PR清单**：\n    *   范围 ≤ 300行（或拆分）。\n    *   标题 = 动词 + 对象（例如：重构认证中间件为异步）。\n    *   描述回答“为什么现在？”并链接到问题。\n    *   用⚠️ **BREAKING** 突出显示破坏性变更。\n    *   请求具体反馈（例如：并发策略是否可行？）。\n\n#### 2. 加强代码审查\n\nAI可以在几秒内生成代码，但如何审查这些代码才是真正专业知识的体现。代码审查不仅能发现错误，还能传授知识、促进团队协作并减少昂贵的错误。开发者通常阅读和审查的代码量远超编写量，因此建立强大的代码审查实践至关重要。\n\n*   **关键实践**：\n    *   在分配给他人之前，先自行审查自己的拉取请求。\n    *   保持拉取请求小而专注，以便于审查、调试和回滚。\n    *   作为审查者，关注清晰度：提问、质疑假设、检查代码如何处理边缘情况或意外数据。\n    *   提供具体的改进示例，并肯定好的设计选择。\n\n*   **审查启发式**：\n    *   首先阅读测试，它们编码了意图。\n    *   追踪数据流，从用户输入到数据库写入再到外部调用。\n    *   寻找全局变量、单例和缓存中的隐藏状态。\n    *   即使性能不在考虑范围内，也要问“负载下会发生什么？”\n    *   赞扬好的模式以强化团队标准。\n\n#### 3. 投资文档\n\n强大的拉取请求和代码审查有助于团队今天构建更好的软件，而文档则使明天构建更好的软件变得更容易。在AI时代，清晰、彻底的文档仍然是开发者最宝贵且常被忽视的技能之一。良好的文档有助于所有人保持一致，包括团队、新贡献者、利益相关者，甚至AI编码代理。\n\n*   **关键实践**：\n    *   保持文档清晰、简洁、结构化。\n    *   使用平实语言，专注于人们实际需要的信息，避免过多不必要的细节。\n    *   使用Diátaxis框架组织文档，将其分为四类：\n        *   **教程**：通过分步指南进行实践学习。\n        *   **操作指南**：针对任务的步骤，使用项目符号或编号列表。\n        *   **解释**：提供更深入的理解。\n        *   **参考**：技术规范，如API规范。\n\n### 开发者进阶工具包\n\n文章提供了一个技能进阶矩阵和一些快速提升的建议：\n\n| 技能       | 初级（Junior）         | 中级（Mid-level）       | 高级（Senior）                     |\n| :--------- | :--------------------- | :---------------------- | :--------------------------------- |\n| 拉取请求   | 描述变更               | 解释原因并链接问题      | 预测性能/安全影响并建议审查重点   |\n| 代码审查   | 留下👍/👎              | 给出可操作的评论        | 指导、建模架构权衡                 |\n| 文档       | 更新README             | 编写面向任务的指南      | 将文档作为产品进行管理并衡量指标 |\n\n**快速提升技巧**：\n\n*   使用`.github/CODEOWNERS`自动路由审查。\n*   使用PR和Issue模板以保持上下文一致性。\n*   学习GitHub Skills课程：使用Markdown进行沟通。\n\n### 总结\n\nAI正在改变我们编写代码的方式，但好奇心、判断力和批判性思维比以往任何时候都更重要。优秀的开发者不会仅仅接受AI的建议，他们会追问“为什么”，提供上下文，理解基本原理，以系统思维、有目的性地编写代码，并精心构建。保持好奇心，持续学习，这正是区分优秀开发者的特质，也是在AI驱动的未来中生存和发展的关键。\n\n**作者**：\n\n*   ![Laura Lindeman](https://avatars.githubusercontent.com/u/3505798?v=4&s=200)\n    Laura Lindeman，GitHub博客的博客编辑与策略师。\n*   ![GitHub Staff](https://avatars.githubusercontent.com/u/9919?v=4&s=200)\n    GitHub，全球领先的开发者体验平台，将安全性融入每一步，助力开发者自信创新。",
      "shortSummary": "AI工具显著提升了编码速度，但开发者专业知识在构建弹性、可扩展和安全软件方面比以往任何时候都更重要。速度若无判断力，将带来安全漏洞和扩展性问题。开发者需作为“人在回路中”的角色，掌握核心基础技能，如高质量的拉取请求、彻底的代码审查和清晰的文档。这些能力培养批判性思维和系统理解，确保AI带来的速度转化为高质量、可维护的软件，而非仅仅是快速交付。",
      "translated_title": "在AI时代，为什么开发者专业知识比以往任何时候都更重要",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/3505798?v=4&s=200",
          "alt": "Laura Lindeman",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/9919?v=4&s=200",
          "alt": "GitHub Staff",
          "title": "",
          "position": 2
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>AI can help you code faster, but knowing why the code works—and sharpening your human-in-the-loop skills—is what makes you a great developer.</p>\n<p>The post <a href=\"https://github.blog/developer-skills/career-growth/why-developer-expertise-matters-more-than-ever-in-the-age-of-ai/\">Why developer expertise matters more than ever in the age of AI</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub Copilot Spaces：为每次建议带来正确的上下文 (原标题: GitHub Copilot Spaces: Bring the right context to every suggestion)",
      "link": "https://github.blog/ai-and-ml/github-copilot/github-copilot-spaces-bring-the-right-context-to-every-suggestion/",
      "pubDate": "Wed, 18 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-18T16:00:00.000Z",
      "creator": "Andrea Griffiths",
      "summary": "# GitHub Copilot Spaces：为每次建议带来正确的上下文\n\n## 引言：AI辅助开发的上下文瓶颈\n\n当生成式AI工具（如GitHub Copilot）尝试猜测用户需求时，其有效性取决于猜测的准确性。然而，面对不熟悉的复杂代码库、团队内部的特定安全清单、或解释重要性的临时Slack对话等非模式化上下文时，即使是最强大的模型也可能基于假设而非实际知识来填补空白。这导致AI助手只能进行猜测，成为AI辅助开发中的新瓶颈。\n\n## GitHub Copilot Spaces 简介\n\nGitHub Copilot Spaces 旨在解决这一问题，它允许用户将Copilot应读取的精确上下文（包括代码、文档、对话记录、示例查询等）捆绑到一个可重用的“空间”中。一旦创建了空间，Copilot的每次聊天、代码补全或命令都将基于这些精选知识，从而生成感觉像是来自组织内部专家而非通用模型的答案。\n\n### 什么是 Copilot Space？\n\n一个空间可以被视为一个安全、可共享的知识容器，并包含行为指令：\n\n*   **附件：** 包含代码文件、整个文件夹、Markdown文档、对话记录或任何纯文本。这些为Copilot提供了答案的“事实依据”。\n*   **自定义指令：** 简短的系统提示，用于设置Copilot的语气、编码风格或评审期望，使Copilot符合团队的“内部规范”。\n*   **共享与权限：** 遵循GitHub现有的角色/可见性模型，无需管理新的访问控制列表。\n*   **实时更新：** 空间中的文件与您引用的分支保持同步，确保空间内容与代码库保持最新。\n\n**简而言之：** 一个空间就像是将团队的集体智慧固定在Copilot侧边栏，让每个人都能用自然语言查询它。结果是：更少的错误猜测、更少的复制粘贴，以及可直接提交的代码。\n\n## 5分钟快速入门指南：如何构建您的第一个空间\n\n1.  **创建空间：** 导航至 `github.com/copilot/spaces` 并点击“Create space”。清晰命名（例如 `frontend-styleguide`），并添加描述，以便队友了解何时使用。\n2.  **附加上下文：**\n    *   **从仓库：** 引入 `src/components` 等文件夹或 `eslint.config.js` 等单个文件。\n    *   **自由文本：** 将Slack对话、视频转录、入职清单甚至JSON Schema粘贴到“Text”选项卡中。Copilot会将其视为任何其他附件。\n3.  **编写自定义指令：** 一两句话即可，例如：“作为高级React评审员回应。强制执行我们的ESLint规则和Tailwind类命名约定。”\n4.  **保存并测试：** 在空间聊天中向Copilot提问（例如：“重构此`<Button>`组件以符合我们的可访问性清单”），观察它引用您刚附加的文件。\n\n## 个性化Copilot的编码风格（和语气）\n\n自定义指令是空间的“个性层”，它们与附件并存，使您能够通过简单的句子实现强大的功能：\n\n*   **强制执行规范：** “示例中始终偏好Vue 3 `script setup` 语法和Composition API。”\n*   **采用团队语气：** “简洁回答。代码块前包含一行摘要。”\n*   **教授项目特定词汇：** “称之为‘场景ID’（SCID），而不是测试用例ID。”\n\n## 自动化工作流：三个真实案例\n\n1.  **可访问性合规助手**\n    *   **内容：** WCAG标准的Markdown文档和GitHub内部的“完成定义”。\n    *   **指令：** “回答时，引用文档部分，如果需要更改则提供代码差异。”\n    *   **效果：** 用户可以询问“此新模态框的MAS-C合规性需要哪些步骤？”，Copilot会总结相关检查点，引用文档锚点，甚至建议ARIA属性或颜色对比修复。\n2.  **复杂Schema的数据查询助手**\n    *   **内容：** 40多个事件表的YAML Schema文件，以及保存为`.sql`文件的KQL示例片段。\n    *   **指令：** “仅生成KQL，除非要求，否则不提供散文解释。”\n    *   **效果：** 不熟悉数据库结构的产品经理和支持工程师可以询问“过去7天平均PR评审时间？”，Copilot会自动补全有效的KQL查询，包含正确的连接，并允许他们迭代。\n3.  **入职培训中心和知识库**\n    *   **内容：** 导出为SVG文本的关键架构图，以及来自多个仓库的ADR（架构决策记录）和设计文档。\n    *   **指令：** “像入职导师一样回答；链接到更深入的文档。”\n    *   **效果：** 新员工输入“我们的认证流程如何处理SAML？”即可获得结构化答案，包含链接和图表，所有这些都无需离开GitHub。由于空间与主分支保持同步，ADR的更新会自动传播，避免知识库过时。\n\n## 与GitHub原生集成的协作与安全\n\nSpaces 尊重您已使用的相同权限模型：\n\n*   **个人空间：** 除非共享，否则仅您可见。\n*   **组织拥有的空间：** 使用仓库或团队权限来控制访问。\n*   **只读与可编辑：** 允许主题专家维护规范，而其他人则消费内容。\n\n共享就像发送空间URL或将其固定到仓库README一样简单。任何有访问权限和Copilot许可证的用户都可以立即开始聊天。\n\n## Copilot Spaces 的未来展望\n\nGitHub 正在努力将Copilot Spaces 引入更多工作流，目前正在开发：\n\n*   **问题和PR附件：** 将内联讨论和评审注释纳入相同的上下文捆绑包。\n*   **IDE集成：** 在VS Code中查询空间，以匹配团队模式编写测试。\n*   **组织范围可发现性：** 帮助您像浏览仓库一样浏览空间，以便新工程师可以搜索“支付主题专家”并开始聊天。\n\n您的反馈将塑造这些优先级。\n\n## 立即开始\n\n前往 `github.com/copilot/spaces`，创建您的第一个空间，并告诉我们它如何简化您的工作流。以下是完整的设置步骤：\n\n1.  **启用预览功能：** 在“Settings > Copilot > Preview features”中启用Copilot Spaces。\n2.  **创建空间：** 创建一个小型、高影响力的空间，例如团队的代码评审清单或一组常见的数据查询。\n3.  **分享：** 在Slack或README中分享链接，观察对主题专家的咨询请求减少。\n4.  **迭代：** 精简未使用的附件，完善指令，或将大型空间拆分为更小的空间。\n\nCopilot Spaces 在公开预览期间免费，并且在使用基础模型时不会计入您的Copilot席位权益。我们期待看到当Copilot拥有正确的上下文时，您能构建出什么。\n\n**作者：**\n\n![Andrea Griffiths](https://github.blog/wp-content/uploads/2025/03/cropped-IMG_1971-200x200.jpeg)\n\nAndrea Griffiths 是 GitHub 的高级开发者倡导者，拥有十多年的开发者工具经验。她将技术深度与使先进技术更易于访问的使命相结合。在从军队服役和施工管理转型到软件开发后，她为连接复杂的工程概念与实际实现带来了独特的视角。她与她的威尔士伴侣、两个儿子和两只狗住在佛罗里达州，在那里她通过GitHub的全球倡议继续推动创新和支持开源。\n\n**探索更多来自GitHub的资源：**\n\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) [Docs](https://docs.github.com/)\n    掌握GitHub所需的一切，尽在一处。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) [GitHub](https://github.com/)\n    在GitHub上构建未来，这里是任何人、任何地方、构建任何东西的场所。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) [Customer stories](https://github.blog/customer-stories/)\n    了解使用GitHub进行构建的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) [GitHub Universe 2025](https://githubuniverse.com/)\n    最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山与我们相聚。",
      "shortSummary": "GitHub Copilot Spaces 旨在解决生成式AI在缺乏特定上下文时的问题。它允许用户将代码、文档、内部知识等捆绑成可重用的“空间”，并通过自定义指令个性化Copilot的行为。这使得Copilot能基于组织特有知识提供精确、专业的建议，减少错误和重复工作。功能包括快速创建、个性化风格、以及用于可访问性、数据查询和新员工培训的实际应用。Spaces遵循GitHub权限模型，未来将集成到IDE和PR工作流中。该功能在公开预览期间对所有Copilot用户免费。",
      "translated_title": "GitHub Copilot Spaces：为每次建议带来正确的上下文",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/03/cropped-IMG_1971-200x200.jpeg",
          "alt": "Andrea Griffiths",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to build your first space in minutes and customize Copilot to match your team's unique coding style and workflows.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/github-copilot-spaces-bring-the-right-context-to-every-suggestion/\">GitHub Copilot Spaces: Bring the right context to every suggestion</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用 GitHub Copilot 处理议题以提升生产力的 5 个技巧 (原标题: 5 tips for using GitHub Copilot with issues to boost your productivity)",
      "link": "https://github.blog/ai-and-ml/github-copilot/5-tips-for-using-github-copilot-with-issues-to-boost-your-productivity/",
      "pubDate": "Tue, 17 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-17T16:00:00.000Z",
      "creator": "Klint Finley",
      "summary": "## 使用 GitHub Copilot 处理议题以提升生产力的 5 个技巧\n\n软件开发中的议题管理可能既繁琐又耗时。GitHub Copilot 最新的议题管理功能旨在简化这一过程，帮助开发者创建、组织甚至解决议题。这些功能可以节省时间、减少摩擦并保持项目的一致性。\n\n### 1. 截图转议题：即时生成 Bug 报告\n\n编写详细的 Bug 报告通常重复且令人沮丧，导致文档不一致。Copilot 的“截图转议题”功能显著减少了这一摩擦。\n\n*   **操作方式**：只需将 Bug 截图粘贴到 Copilot 聊天中，并附上简短描述，Copilot 就会分析图像并为你生成一份全面的 Bug 报告。\n*   **优势**：无需费力描述视觉故障或 UI 问题，图像本身就能说明问题，Copilot 负责文档化。例如，遇到 UI 对齐问题或难以描述的视觉故障时，截屏后粘贴到 Copilot，并简要提及问题即可。\n*   **示例**：文章提到，用户提示“创建 Bug 议题，因为 Markdown 表格在评论中未正确渲染”，Copilot 随后自动起草报告，包括重现 Bug 的步骤。\n*   **提示**：清晰地标注截图（高亮或圈出问题区域）有助于 Copilot 生成更精确的议题描述。\n\n### 2. 自动元数据和模板\n\n当团队成员跳过添加正确的元数据时，项目会迅速变得混乱，不正确的模板、缺失的标签或错误的议题类型会使跟踪和优先级排序变得困难。Copilot 通过以下方式解决此问题：\n\n*   **自动推断**：根据你的提示自动推断最佳模板。\n*   **自动添加**：无需导航多个下拉菜单或记住标签约定，即可添加适当的标签和议题类型。\n*   **自定义**：可以要求 Copilot 添加特定标签或切换模板。\n*   **自动重格式化**：如果起草后更改模板，Copilot 会自动重格式化内容，无需手动复制。\n\n### 3. 通过版本控制和里程碑保持井然有序\n\n保持议题更新和正确分类对于清晰沟通、维持项目进度和确保可见性至关重要。Copilot 使添加项目和里程碑变得像输入提示一样简单。\n\n*   **灵活组织**：你可以精确指定议题的组织方式，例如，要求 Copilot 使用“Bug 报告”或“功能请求”模板，添加“优先级：高”、“前端”或“需要分类”等标签，或将议题类型设置为“任务”或“史诗”。\n*   **一致性**：Copilot 会自动应用这些细节，确保议题始终保持一致的分类。\n*   **历史记录**：Copilot 还会跟踪所有更改，使其易于查阅。你可以查看议题历史记录并在需要时恢复更改，确保重要信息不会丢失。\n\n### 4. 批量创建多个议题\n\n有时在客户会议、用户测试会话或 Bug 修复活动后，你需要记录多个议题。传统上，这意味着重复多次相同的创建过程。Copilot 支持多议题起草，允许你在一次对话中创建多个议题。\n\n*   **节省时间**：无论是记录功能请求还是文档化 Bug，批量创建都能显著节省时间。\n*   **操作方式**：只需提示 Copilot 创建议题，描述每一个，Copilot 就会全部起草。\n*   **示例**：你可以给出类似“为以下功能创建议题：- 渲染的 Markdown 中忽略换行符，尽管有双空格 - 粗体和斜体 Markdown 样式组合时未应用”的提示，一次创建两个议题。\n*   **流程**：你仍然需要审查并最终确定每个议题，但起草过程被简化为单一工作流。\n\n### 5. 让 AI 帮助修复 Bug：Copilot 编码代理\n\n创建议题只是成功的一半，修复它们才是真正的工作。现在，你可以直接将议题分配给 Copilot。\n\n*   **AI 协助**：只需要求 Copilot 编码代理接管议题，你的 AI 编码助手就会开始分析 Bug。\n*   **建议修复**：Copilot 甚至可以建议包含潜在修复的拉取请求草稿。\n*   **效率提升**：这种无缝交接减少了上下文切换，并加快了解决时间，让你的团队能够专注于更复杂的挑战。\n\n### GitHub 议题增强功能（超越 Copilot）\n\n除了 Copilot，GitHub 也在不断增强整体议题体验：\n\n*   **标准化议题类型**：跨仓库标准化议题类型，实现一致的跟踪和报告。\n*   **分解复杂任务**：将复杂任务分解为子议题，以便更好地管理进度。\n*   **高级搜索**：使用逻辑运算符进行高级搜索，快速找到所需内容。\n*   **扩展限制**：管理更大的项目，支持多达 50,000 个项目。\n\n### 立即开始增强议题管理\n\n准备好使用 GitHub Copilot 改变你的议题管理工作流了吗？访问 github.com/copilot 并尝试以下提示：\n\n*   “为……创建议题”\n*   “记录一个 Bug”\n*   或者直接上传截图并提及你想提交一个 Bug。\n\n亲身体验 Copilot 如何让议题管理不再像行政负担，而更像与你的 AI 结对程序员进行对话。",
      "shortSummary": "GitHub Copilot 推出五项新功能，旨在提升议题管理效率。这些功能包括：将截图转化为详细 Bug 报告、自动添加元数据和模板、通过版本控制和里程碑保持议题有序、支持批量创建多个议题，以及让 Copilot 编码代理协助分析和修复 Bug。Copilot 旨在简化议题创建、组织和解决流程，减少开发者的行政负担，提升生产力。",
      "translated_title": "使用 GitHub Copilot 处理议题以提升生产力的 5 个技巧",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/957053?v=4&s=200",
          "alt": "Klint Finley",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Reduce context-switching, minimize manual work, and accelerate resolution times with these new AI-powered features.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/5-tips-for-using-github-copilot-with-issues-to-boost-your-productivity/\">5 tips for using GitHub Copilot with issues to boost your productivity</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "Git 2.50 的亮点 (原标题: Highlights from Git 2.50)",
      "link": "https://github.blog/open-source/git/highlights-from-git-2-50/",
      "pubDate": "Mon, 16 Jun 2025 17:12:27 +0000",
      "isoDate": "2025-06-16T17:12:27.000Z",
      "creator": "Taylor Blau",
      "summary": "Git 开源项目发布了 Git 2.50 版本，包含了来自 98 位贡献者（其中 35 位是新贡献者）的新功能和错误修复。在深入探讨本次发布细节之前，值得一提的是，Git 用户和开发者大会 Git Merge 将于今年 9 月 29-30 日在旧金山举行，门票现已发售。\n\n以下是 Git 2.50 中一些最值得关注的功能和变化：\n\n*   **多余对象包（Cruft Packs）的改进**\n    *   **背景：** Git 2.37 引入了多余对象包（cruft packs）来存储不可达对象。Git 2.43 增加了 `git repack --max-cruft-size` 选项，旨在将不可达对象分散到多个包中。\n    *   **旧问题：** `git repack --max-cruft-size` 的行为令人困惑，与 `git repack --max-pack-size` 不同，并且在实际使用中常常无法达到预期效果，例如，它可能阻止合并小的多余对象包。\n    *   **Git 2.50 的解决方案：**\n        *   引入了新的选项 `--combine-cruft-below-size`：该选项用于确定哪些现有的多余对象包可以合并，从而允许用户逐步减少仓库中多余对象包的数量。\n        *   重新定义了 `--max-cruft-size`：现在它仅作为多余对象包特有的 `--max-pack-size` 覆盖选项，只决定输出包的大小，而不决定哪些包被合并。\n        *   修复了错误：解决了在某些情况下，存储在多个多余对象包中的对象无法“刷新”（更新修改时间）的问题，避免了对象被过早删除。\n\n*   **增量多包可达性位图（Incremental Multi-pack Reachability Bitmaps）**\n    *   **背景：** 多包索引（MIDXs）通过为分散在多个包中的对象提供单一索引，显著加速了大型仓库中的对象查找。多包可达性位图是 MIDX 特有的位图，用于提升可达性信息查询性能。然而，随着仓库增长，更新 MIDX 和位图需要重写整个文件，效率低下。\n    *   **Git 2.47 的进展：** 引入了增量 MIDX 格式，允许 MIDX 层叠。\n    *   **Git 2.50 的突破：** 为增量 MIDX 链带来了多包可达性位图支持，每个 MIDX 层都有自己的 `.bitmap` 文件。这使得在大型仓库中，随着新提交的推送，可以快速高效地添加新的可达性位图。\n    *   **现状：** 此功能仍被认为是高度实验性的，对增量多包索引和位图进行重打包的支持仍处于早期阶段。\n\n*   **ORT 合并引擎取代 Recursive**\n    *   **背景：** ORT（“Ostensibly Recursive’s Twin”）是 Git 旧有合并引擎“recursive”的全新重写，于 Git 2.33 引入，旨在提供更快的速度、更好的可维护性和更多新功能。\n    *   **新功能：** Git 2.50 允许在不实际持久化任何新对象的情况下判断两个事物是否可合并。通过 `merge-tree` 的新 `--quiet` 模式并依赖其退出码即可实现，避免了旧方法 `git merge-tree --write-tree` 可能导致的性能问题。\n    *   **重大里程碑：** ORT 已完全取代了“recursive”合并引擎，后者已从 Git 源代码中移除。ORT 自 Git 2.34 成为默认选项后，经过 16 个版本和两年半的迭代，现在“recursive”已彻底“调试完毕”（即被删除）。\n\n*   **`git cat-file` 的改进**\n    *   **对象类型过滤：** Git 2.50 将部分克隆中使用的对象过滤机制引入到 `git cat-file` 命令中。现在可以更简洁地按对象类型（如树对象）进行过滤，例如使用 `--filter='object:type=tree'`。\n    *   **移除 `--allow-unknown-type`：** 此版本使 `git cat-file` 的 `--allow-unknown-type` 选项静默失效，并移除了 `git hash-object` 写入未知类型对象的支持。这个功能在过去十年中很少被使用，且存在问题。\n\n*   **`git maintenance` 命令的增强**\n    *   **新增任务：** `git maintenance` 命令现在可以执行 `worktree-prune`（清理陈旧或损坏的工作树）、`rerere-gc`（清理旧的 rerere 条目）和 `reflog-expire`（从 reflog 中移除陈旧的不可达对象）等任务。\n    *   **`loose-objects` 任务配置：** 现有的 `loose-objects` 任务的配置得到了增强，可以通过 `maintenance.loose-objects.batchSize` 配置选项来调整为剩余松散对象创建新包的最大大小（之前固定为 50,000）。\n\n*   **`git reflog delete` 子命令**\n    *   **背景：** 之前要删除分支的整个 reflog，需要使用 `git reflog expire $BRANCH --expire=all`。\n    *   **Git 2.50 的改进：** 引入了新的 `delete` 子命令，现在可以使用更直观的 `git reflog delete $BRANCH` 来完成相同的操作。\n\n*   **引用处理的优化**\n    *   **`git update-ref` 性能提升：** 低级命令 `git update-ref` 不再检查提议的引用名称是否也可能是有效的对象 ID，从而为依赖它的高级命令带来了性能提升。\n    *   **引用前缀缓存：** Git 2.50 学习了如何缓存提议引用名称的任何前缀是否存在（例如，如果 `refs/heads/foo` 或 `refs/heads/foo/bar` 已经存在，则不能创建 `ref/heads/foo/bar/baz`）。\n    *   **迭代器查找优化：** Git 2.50 的引用后端学会了“查找”现有迭代器，通过重用相同的迭代器来检查每个可能的前缀，从而节省了时间。\n\n*   **TCP Keepalive 配置选项**\n    *   **背景：** Git 使用 curl 进行 HTTP 连接，并提供了 `http.lowSpeedLimit` 和 `http.lowSpeedTime` 等选项来控制连接。\n    *   **Git 2.50 的新增功能：** 引入了三个新的配置选项：`http.keepAliveIdle`、`http.keepAliveInterval` 和 `http.keepAliveCount`，用于精细控制 curl 的 TCP 探测行为（如果操作系统支持）。",
      "shortSummary": "Git 2.50 发布，带来了多项重要更新。核心亮点包括：ORT 合并引擎完全取代了旧的 recursive 引擎，提升了合并性能并支持无对象写入的合并判断。多余对象包管理得到显著改进，引入了 `--combine-cruft-below-size` 选项并修复了相关错误。增量多包可达性位图现在支持 MIDX 链，极大地优化了大型仓库的性能。此外，`git cat-file` 增加了对象类型过滤，`git maintenance` 新增了多项任务，`git reflog` 引入了更便捷的 `delete` 子命令，并优化了引用处理和 TCP Keepalive 配置。",
      "translated_title": "Git 2.50 的亮点",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/443245?v=4&s=200",
          "alt": "Taylor Blau",
          "title": "",
          "position": 1
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>The open source Git project just released Git 2.50. Here is GitHub’s look at some of the most interesting features and changes introduced since last time.</p>\n<p>The post <a href=\"https://github.blog/open-source/git/highlights-from-git-2-50/\">Highlights from Git 2.50</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 计费团队如何利用 GitHub Copilot 中的编码代理持续消除技术债务 (原标题: How the GitHub billing team uses the coding agent in GitHub Copilot to continuously burn down technical debt)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-the-github-billing-team-uses-the-coding-agent-in-github-copilot-to-continuously-burn-down-technical-debt/",
      "pubDate": "Thu, 12 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-12T16:00:00.000Z",
      "creator": "Brittany Ellich",
      "summary": "## GitHub 计费团队如何利用 GitHub Copilot 中的编码代理持续消除技术债务\n\n### 引言：技术债务的挑战\n\n软件在不断演进中会积累技术债务，这源于过去的快速修复、临时方案和妥协。技术债务如同金融债务，拖延越久成本越高，但在紧迫的截止日期和不断涌入的功能需求下，很难优先处理。传统的管理方法（如“园艺周”或延长功能时间线）效果不佳，因为它们将技术债务视为例外而非持续维护，或导致不切实际的估算。核心问题在于将技术债务视为对正常开发流程的干扰。理想状态是能够与日常工作并行，持续地消除技术债务。\n\n### 利用 AI 代理持续管理技术债务\n\nAI 代理（如 GitHub Copilot 中的编码代理）为管理技术债务提供了巨大机会。技术债务任务不再需要堆积在待办事项中。工程师可以专注于新功能和架构变更，同时将技术债务任务分配给 GitHub Copilot。\n\n### 编码代理的具体应用示例（来自 GitHub 计费团队的实践）\n\nGitHub 计费团队已通过 GitHub Copilot 编码代理成功解决了以下实际问题：\n\n*   **提高代码测试覆盖率：** 分配任务给 Copilot 增加测试覆盖，完成后通知审查。\n*   **替换依赖项：** 让 Copilot 处理耗时的库替换工作。\n*   **标准化代码库模式：** 统一错误返回和日志记录方式，提高可维护性。\n*   **优化前端加载模式：** 调整应用，仅在需要数据时才进行 API 调用，而非每次页面加载。\n*   **识别并消除废弃代码：** 让 Copilot 查找并安全移除未使用的函数、过时端点或陈旧配置。\n\n这些实践极大地提升了团队持续处理技术债务的能力，将消除技术债务的时间从数周的间歇性工作缩短到几分钟的发布问题和几小时的拉取请求审查。\n\n### 人机协作：AI 作为副驾驶\n\nAI 代理并非取代人类工程师，而是增强其能力。代理处理重复、耗时的工作（如重构遗留代码、更新依赖、标准化模式），而工程师则可以专注于架构决策、功能创新和解决复杂的业务问题。这使得软件更健康、团队交付更快、工程师工作更有活力。\n\n人类在整个过程中至关重要：AI 代理擅长明确、重复的任务，但大型架构决策和复杂业务逻辑仍需人类判断。每个提示都需要仔细考虑，每次代码更改都需要彻底审查。AI 代理提供速度和一致性，而人类提供战略性思考（优先处理哪个技术债务、评估业务影响、识别潜在问题）。人机协作的精髓在于人类定义问题、设定约束、验证解决方案，代理处理繁琐的实现细节。\n\n### 充分利用 GitHub Copilot 编码代理的技巧\n\n1.  **为你的仓库编写 Copilot 指令：** 显著改善体验，可让代理协助编写，包含开发脚本（格式化、linting）。\n2.  **分块处理任务：** 代理可能进行大范围修改，但审查大量文件的拉取请求效率低下。将大任务分解为更小的、可审查的子任务（例如，针对特定文件或文件夹改进测试覆盖）。\n3.  **掌握有效提示的艺术：** 明确说明上下文、约束和编码标准。\n4.  **始终彻底审查代码：** AI 代理不理解业务逻辑，代码审查是确保质量的核心环节。Copilot 编码代理与现有代码审查工具无缝集成。\n\n### 拥抱 AI 工具的软件工程师的未来\n\n技术债务长期以来是“无声的生产力杀手”，很少被优先处理直到成为危机。AI 编码代理提供了彻底改变这一局面的机会。能够有效与 AI 代理协作的工程师（掌握清晰提示、周到代码审查和战略性任务委派）将拥有巨大优势。他们将能够维护同行难以处理的代码库，解决他人回避的技术债务，并可能消除耗时且昂贵的系统重写。这种转变需要有意识的努力：实验工具、了解其优缺点并将其整合到工作流程中。这将使工程师更高效、更少挫败，专注于工程的创造性方面，并为用户带来更稳定、维护良好的应用程序。\n\n### 作者信息及相关资源\n\n*   作者：Brittany Ellich，GitHub 软件工程师。\n    ![Brittany Ellich](https://avatars.githubusercontent.com/u/25957322?v=4&s=200)\n*   更多来自 GitHub 的资源：\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 的公司和工程团队。\n    *   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) Enterprise content：专为您策划的高管见解。",
      "shortSummary": "GitHub 计费团队利用 GitHub Copilot 的编码代理持续消除技术债务。传统技术债务管理效率低下，而 AI 代理能并行处理测试覆盖、依赖替换、代码标准化和死代码清理等任务。这并非取代工程师，而是增强其能力，让人类专注于架构和创新，AI 处理重复性工作。关键在于人机协作，工程师提供战略指导和彻底审查，AI 负责高效执行。通过有效提示和分块处理，团队能显著提升生产力，使软件更健康，并避免昂贵的系统重写。",
      "translated_title": "GitHub 计费团队如何利用 GitHub Copilot 中的编码代理持续消除技术债务",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/25957322?v=4&s=200",
          "alt": "Brittany Ellich",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Tech debt is a big problem that no one has time to solve. GitHub Copilot coding agent can help.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-the-github-billing-team-uses-the-coding-agent-in-github-copilot-to-continuously-burn-down-technical-debt/\">How the GitHub billing team uses the coding agent in GitHub Copilot to continuously burn down technical debt</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 可用性报告：2025 年 5 月 (原标题: GitHub Availability Report: May 2025)",
      "link": "https://github.blog/news-insights/company-news/github-availability-report-may-2025/",
      "pubDate": "Wed, 11 Jun 2025 23:24:41 +0000",
      "isoDate": "2025-06-11T23:24:41.000Z",
      "creator": "Jakub Oleksy",
      "summary": "# GitHub 2025 年 5 月可用性报告\n\nGitHub 在 2025 年 5 月经历了三次导致服务性能下降的事件。\n\n## 事件回顾\n\n### 1. 5 月 1 日事件：附件上传降级\n\n*   **时间：** 2025 年 5 月 1 日 22:09 UTC 至 23:13 UTC（持续 1 小时 4 分钟）。\n*   **受影响服务：** Issues 服务。\n*   **影响：** 用户无法上传附件，估计约 13 万用户受到影响约 45 分钟。\n*   **根本原因：** 新功能在所有客户端 HTTP 请求中添加了自定义头部，导致上传附件到提供商时出现 CORS 错误。\n*   **缓解措施：** 于 22:56 UTC 回滚了添加新头部的功能标志。\n*   **预防措施：** 正在添加新的监控指标，以确保客户端请求更改的安全推出。基于此次事件的经验，已部署了增强版功能，目前在生产环境中运行良好。\n\n### 2. 5 月 28 日事件：GitHub Actions 作业启动延迟\n\n*   **时间：** 2025 年 5 月 28 日约 09:45 UTC 至 14:45 UTC（持续 5 小时）。\n*   **受影响服务：** GitHub Actions，特别是使用 Ubuntu-24 标准托管运行器的公共仓库工作流。\n*   **影响：** 公共仓库中约 19.7% 的 Ubuntu-24 托管运行器作业出现延迟。其他托管运行器、自托管运行器和私有仓库工作流未受影响。\n*   **根本原因：** 故障转移后后端缓存行为配置错误，导致重复的作业分配，降低了受影响托管运行器池的整体容量。\n*   **缓解措施：** 配置问题于 12:45 UTC 修复。同时扩大了运行器池规模，以更快地处理积压的排队作业，直到 14:45 UTC 完全缓解排队影响。\n*   **预防措施：** 正在改进故障转移的弹性和验证，以降低未来发生类似问题的可能性。\n\n### 3. 5 月 30 日事件：Microsoft Teams GitHub 集成服务中断\n\n*   **时间：** 2025 年 5 月 30 日 08:10 UTC 至 16:00 UTC（持续 7 小时 50 分钟）。\n*   **受影响服务：** Microsoft Teams GitHub 集成服务。\n*   **影响：** 除链接预览外，所有功能均出现 100% 的错误率，集成服务无法处理用户请求或发送通知。\n*   **根本原因：** 下游身份验证提供商的身份验证问题。尽管有适当的监控，但警报阈值不够灵敏，导致事件检测和响应延迟。\n*   **缓解措施：** 团队与下游提供商密切合作诊断并解决了身份验证故障，恢复了服务功能。\n*   **预防措施：** 正在迁移到更持久的身份验证方法，以降低未来发生类似问题的风险。提供商响应时间超出预期也导致了此次中断的延长。\n\n## 更多信息\n\n*   请关注 [GitHub 状态页面](https://www.githubstatus.com/) 获取实时状态更新和事件后总结。\n*   访问 [GitHub 工程博客](https://github.blog/engineering/) 了解更多正在进行的工作。\n*   文章作者： ![Jakub Oleksy](https://avatars.githubusercontent.com/u/6147691?v=4&s=200)\n\n### 相关文章\n\n*   GitHub Copilot：认识新的编码代理\n*   实现功能从未如此简单：只需将任务或问题分配给 Copilot。它在后台与 GitHub Actions 一起运行，并将其工作作为拉取请求提交。\n\n### 探索更多 GitHub 内容\n\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) **文档**\n    掌握 GitHub 所需的一切，尽在一处。前往文档\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) **GitHub**\n    在 GitHub 上构建未来，这里是任何人、任何地点构建任何东西的地方。开始构建\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) **客户案例**\n    了解使用 GitHub 进行构建的公司和工程团队。了解更多\n*   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) **企业内容**\n    为您精心策划的执行洞察。开始使用",
      "shortSummary": "GitHub 在 2025 年 5 月报告了三起服务中断事件。5 月 1 日，Issues 服务因新功能导致附件上传降级，影响约 13 万用户。5 月 28 日，GitHub Actions 因后端缓存配置错误导致公共仓库作业启动延迟。5 月 30 日，Microsoft Teams GitHub 集成服务因下游身份验证问题完全中断，持续近 8 小时。GitHub 已采取措施修复并预防类似问题，包括回滚功能、改进故障转移弹性和迁移认证方法。",
      "translated_title": "GitHub 可用性报告：2025 年 5 月",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/6147691?v=4&s=200",
          "alt": "Jakub Oleksy",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>In May, we experienced three incidents that resulted in degraded performance across GitHub services.</p>\n<p>The post <a href=\"https://github.blog/news-insights/company-news/github-availability-report-may-2025/\">GitHub Availability Report: May 2025</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub工程师如何解决平台问题 (原标题: How GitHub engineers tackle platform problems)",
      "link": "https://github.blog/engineering/infrastructure/how-github-engineers-tackle-platform-problems/",
      "pubDate": "Tue, 10 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-10T16:00:00.000Z",
      "creator": "Fabian Aguilar Gomez",
      "summary": "# GitHub工程师如何解决平台问题\n\n## 引言：产品与平台工程的类比\n*   文章通过高达模型制作类比产品工程师和平台工程师的角色：\n    *   **产品工程师**：使用工具包构建最终产品（高达模型），专注于构建可玩或收藏的工作产品。\n    *   **平台工程师**：提供构建工具（如剪钳、锉刀）并可能搭建展示平台，确保构建者拥有所需工具，即使他们不亲自构建高达模型。\n*   作者的团队一年前转入基础设施组织，职责从解决外部客户问题（如构建新的部署视图）转变为服务内部客户，成为平台工程团队。这意味着他们现在负责构建产品组件，这要求他们重新思考代码测试和问题解决方法。\n\n## 解决平台问题的最佳实践\n\n### 1. 理解你的领域\n*   **定义**：“领域”是指团队和平台组织运作的业务和技术主题区域。\n*   **如何快速掌握**：\n    *   **与同事交流**：与对主题有更多知识和经验的团队安排交接会议，询问术语并深入理解问题。\n    *   **调查旧问题**：研究积压或持续存在的问题，以更好地理解系统的当前限制和潜在改进领域。\n    *   **阅读文档**：文档是知识的宝库，有助于理解系统的工作原理。\n\n### 2. 将概念与平台特定技能相结合\n*   平台团队作为基础层，需要更深入的理解：\n    *   **网络**：理解TCP、UDP、L4负载均衡等网络基础知识，以及`dig`等调试工具，这对于理解网络流量如何影响平台至关重要。\n    *   **操作系统和硬件**：选择合适的虚拟机（VM）或物理硬件对于可扩展性和成本管理至关重要，并需选择正确的操作系统以避免漏洞或接近生命周期结束的系统。\n    *   **基础设施即代码（IaC）**：熟练使用Terraform、Ansible、Consul等自动化工具，它们能显著减少基础设施配置和修改过程中的人为错误。\n    *   **分布式系统**：处理平台问题，尤其是在分布式系统中，需要深入理解故障是不可避免的。因此，采用故障转移和恢复机制等主动解决方案对于保持系统可靠性和防止不良用户体验至关重要。\n\n### 3. 知识共享\n*   通过分享经验和想法，工程师可以引入新视角，从而带来突破和创新。\n*   **重要性**：\n    *   **团队合作**：协作通常能更快地解决问题，并促进新解决方案的创新，因为工程师有机会相互学习并扩展现有想法。\n    *   **防止知识流失**：如果不分享经验教训，信息就无法在团队或组织内传播。当工程师离职或无法联系时，这会成为问题。\n    *   **提升客户成功**：工程师的解决方案应有效地服务客户。通过分享知识和经验教训，团队可以构建可靠、可扩展、安全的平台，从而创造出满足客户需求和期望的更好产品！\n\n## 产品工程与基础设施工程的显著差异\n\n### 1. 影响范围\n*   平台作为系统的基本构建块，任何（无论大小的）变更都可能影响广泛的产品。例如，DNS服务的一个微小改动就可能对GitHub Pages到GitHub Copilot等产品造成广泛影响。\n*   **如何理解影响范围**：\n    *   **与下游团队直接沟通**：与依赖服务的团队直接沟通，提供有关拟议变更可能如何影响其他服务的宝贵见解。\n    *   **事后分析（Postmortems）**：通过查看与平台相关的过去事件，并询问“此事件的影响是什么？”，可以更深入地了解引入了什么变更或故障、平台在其中扮演的角色以及如何修复。\n    *   **监控和遥测**：将重要的监控和日志信息浓缩成小巧且易于消化的介质（例如单一可用性指标SAM），以提供系统的总体健康状况。快速浏览单个仪表盘的能力使工程师能够迅速查明问题来源，并简化调试和事件缓解过程。\n\n### 2. 测试变更\n*   在分布式环境中测试变更（特别是像DNS这样的服务）可能具有挑战性。\n*   **关键步骤**：\n    *   **利用测试站点**：将其作为“真实”机器，可以在其中实施和评估所有变更。\n    *   **基础设施即代码（IaC）测试**：使用Terraform或Ansible等工具时，测试配置和解除配置机器等基本操作至关重要。在需要重新配置机器的情况下，要确保机器不会被意外删除，并且在需要时能够创建新机器。\n    *   **端到端（E2E）测试**：开始将一些网络流量导向这些服务器。团队可以通过直接与其交互来观察主机行为，或者通过分流一小部分流量来评估功能。\n    *   **自愈能力测试**：测试平台从意外负载中恢复的能力，并在影响用户之前识别瓶颈。早期识别瓶颈或错误对于维护平台健康至关重要。\n    *   **逐主机实施**：理想情况下，测试完成后应逐主机实施变更。这种方法允许单独机器回滚，并防止变更应用于未受影响的主机。\n\n## 总结\n*   平台工程可能很困难，GitHub的系统复杂且包含许多服务和活动部件。然而，当一切顺利运行时，所有幕后努力都得到了回报。当平台平稳运行，团队能够更快、更可靠地交付产品时，GitHub就能成为所有开发者的家园。\n\n由 ![Fabian Aguilar Gomez](https://avatars.githubusercontent.com/u/27039604?v=4&s=200) Fabian Aguilar Gomez 撰写\n\n### 相关文章\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握GitHub所需的一切。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在GitHub上构建未来，这里是任何地方的任何人都可以构建任何东西的地方。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用GitHub进行构建的公司和工程团队。\n*   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) Enterprise content：专为您策划的企业洞察。",
      "shortSummary": "GitHub工程师通过高达模型类比阐述了平台工程与产品工程的区别，强调平台工程师提供基础工具和基础设施。解决平台问题需深入理解领域知识、掌握网络、操作系统、IaC和分布式系统等平台特定技能，并重视知识共享。平台工程的挑战在于其广泛的影响范围和分布式环境下的测试复杂性。通过理解依赖、事后分析、有效监控和分阶段测试，确保平台稳定运行，从而支持产品团队更快、更可靠地交付产品。",
      "translated_title": "GitHub工程师如何解决平台问题",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/gundam.jpg?resize=1024%2C840",
          "alt": "A photograph of several Gundam models on a shelf.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/27039604?v=4&s=200",
          "alt": "Fabian Aguilar Gomez",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Our best practices for quickly identifying, resolving, and preventing issues at scale.</p>\n<p>The post <a href=\"https://github.blog/engineering/infrastructure/how-github-engineers-tackle-platform-problems/\">How GitHub engineers tackle platform problems</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 初学者指南：使用 GitHub Copilot 进行代码审查和重构 (原标题: GitHub for Beginners: Code review and refactoring with GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/github-for-beginners-code-review-and-refactoring-with-github-copilot/",
      "pubDate": "Mon, 09 Jun 2025 13:00:00 +0000",
      "isoDate": "2025-06-09T13:00:00.000Z",
      "creator": "Kedasha Kerr",
      "summary": "# GitHub 初学者指南：使用 GitHub Copilot 进行代码审查和重构\n\n本篇文章是“GitHub 初学者指南”系列的第八集，也是最后一集，深入探讨了 GitHub Copilot 在代码审查和重构中的应用。在任何开发项目中，维护一个清晰高效的代码库至关重要，而 GitHub Copilot 不仅能辅助编写代码，还能使代码审查和重构过程更顺畅、更高效。\n\n## 使用 Copilot 进行代码重构\n\nGitHub Copilot 能够帮助开发者重构代码，使其更易于理解和维护。\n\n### 操作步骤与建议类型\n\n1.  **高亮代码并提问：** 在代码编辑器中高亮需要重构的函数，然后在 Copilot Chat 中发送提示，例如“`please provide refactoring suggestions`”（请提供重构建议）。\n2.  **审查建议：** Copilot 会提供多种重构建议，包括将代码拆分为更小的部分、优化逻辑以提高性能，甚至更新变量名称以符合命名规范。\n3.  **应用更改：** 审查并确认建议后，点击“`Apply in editor`”按钮即可自动更新文件。\n\n### 重构范围与具体示例\n\n*   **局部重构：** 适用于对代码特定区域的关注。\n*   **文件或项目级重构：** Copilot 也可以审查整个文件或项目。例如，对于一个仪表盘组件，可以向 Copilot Chat 提问“`How can I improve this code?`”（我如何改进这段代码？），Copilot 会给出多条改进建议，并可进一步解释。\n*   **提取逻辑：** 可以通过提问“`How can I extract the data fetching logic into a custom hook?`”（如何将数据获取逻辑提取到自定义 Hook 中？）来将特定逻辑（如数据获取）提取到可重用的组件中。操作流程包括将更改保存到新文件、导入 Hook 并删除旧代码。\n*   **识别冗余代码：** 提问“`Is there any redundant code in this file?`”（此文件中是否有任何冗余代码？），Copilot 会扫描代码并识别可纠正的冗余部分。\n*   **其他重构辅助：** Copilot 还能提供性能改进建议、帮助函数模块化、添加注释以提高可读性，以及升级语法到更现代的版本等。\n\n![一张幻灯片，解释 Copilot 可以提供性能改进建议、如何使函数更模块化、添加注释以提高可读性、升级语法等等！](https://github.blog/wp-content/uploads/2025/06/copilot_refactor_help.png?resize=1024%2C573)\n\n## 在 GitHub.com 上进行代码审查\n\nGitHub Copilot 也能直接在 GitHub.com 上进行代码审查，使流程更加无缝。\n\n### 审查流程\n\n1.  **创建拉取请求：** 打开一个拉取请求（Pull Request）。\n2.  **请求 Copilot 审查：** 在右上角的“Reviewers”（审查者）部分，会看到 Copilot 列为可能的审查者。点击“Request”（请求）即可让 Copilot 审查代码。\n\n![一张截图，显示了在右侧“审查者”列表中如何请求 Copilot 进行审查。](https://github.blog/wp-content/uploads/2025/06/code_review.png?resize=1024%2C573)\n\n3.  **查看建议：** Copilot 完成审查后，向下滚动拉取请求即可看到其提出的任何建议。\n4.  **接受建议：** Copilot 总是留下“Comment review”（评论审查），从不留下“Approve”（批准）或“Request changes”（请求更改）审查，这意味着 Copilot 的审查永远不会是必需的，也不会阻止合并。要接受 Copilot 的建议，点击特定建议底部的“`Commit suggestion`”（提交建议），然后在上下文菜单中点击“`Commit changes`”（提交更改），GitHub 会更新拉取请求。\n\n![一张截图，显示了标题为“提交建议”的下拉菜单中的“提交更改”按钮。](https://github.blog/wp-content/uploads/2025/06/commit_code_review.png?resize=1024%2C573)\n\n5.  **批量处理与重新审查：** 可以通过点击单个建议下的“`Add to batch`”（添加到批次）按钮来批量处理多个建议。在集成建议后，可以通过点击“Reviewers”框中 Copilot 名称旁边的圆形箭头来再次请求 Copilot 审查。\n\nCopilot 代码审查可以作为团队最终代码审查前的初步审查。\n\n## 关键组成部分与局限性\n\n### 关键组成部分\n\n使用 Copilot 进行代码审查和重构主要包括以下五个方面：\n\n*   **自动化建议：** 在审查代码时，Copilot 会提出改进和优化建议。\n*   **一致性检查：** 通过建议一致的命名约定和函数结构，帮助维护编码标准。\n*   **重构辅助：** 提供可操作的重构建议，无论是简化复杂函数还是重组代码库。\n*   **错误检测：** 能够发现可能遗漏的潜在错误或低效率问题。\n*   **注释支持：** 帮助生成清晰的代码注释，使其更易于他人理解。\n\n### 局限性\n\n尽管 GitHub Copilot 功能强大，但它仍是一个辅助工具，并非人类审查的替代品：\n\n*   **依赖上下文：** Copilot 的建议质量取决于所提供的上下文，不清晰或文档不完善的代码可能导致建议效果不佳。\n*   **非人类审查替代品：** Copilot 无法替代彻底的人工审查。务必仔细检查其提供的建议，确保它们符合项目目标、标准以及组织政策。\n\n![一张幻灯片，列出了 Copilot 的功能：协助代码审查和重构；帮助维护整洁、高效和一致的代码；节省时间并减少错误；让您更专注于构建。](https://github.blog/wp-content/uploads/2025/06/copilot_can_do.png?resize=1024%2C573)\n\n## 总结\n\nGitHub Copilot 是代码审查和重构的宝贵助手，它能帮助开发者维护整洁、高效且一致的代码，从而节省时间并减少错误。通过将 Copilot 整合到工作流程中，开发者可以更专注于构建出色的功能，而不是纠结于代码维护的细节。",
      "shortSummary": "GitHub Copilot 是一个强大的代码审查和重构工具。它通过 Copilot Chat 提供重构建议，如优化代码、提取逻辑和识别冗余。在 GitHub.com 上，Copilot 可作为拉取请求的初步审查者，提供评论但不阻塞合并。其核心功能包括自动化建议、一致性检查和错误检测。尽管功能强大，Copilot 仍是辅助工具，不能替代彻底的人工审查，其建议需人工复核。它旨在帮助开发者维护整洁高效的代码，节省时间并减少错误。",
      "translated_title": "GitHub 初学者指南：使用 GitHub Copilot 进行代码审查和重构",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/copilot_refactor_help.png?resize=1024%2C573",
          "alt": "A slide explaining that Copilot can help with performance improvement suggestions, how to make functions more modular, adding comments for readability, upgrading syntax, and much more!",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/code_review.png?resize=1024%2C573",
          "alt": "A screenshot shoring where to request a review from Copilot, under the 'reviewers' list on the right.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/commit_code_review.png?resize=1024%2C573",
          "alt": "A screenshot showing the 'Commit changes' button in the drop down menu titled 'Commit suggestion.'",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/copilot_can_do.png?resize=1024%2C573",
          "alt": "A slide listing items Copilot can do: Assists with code review and refactoring; helps maintain clean, efficient, and consistent code; saves you time and reduces errors; and allows you to focus more on building.",
          "title": "",
          "position": 4
        },
        {
          "url": "https://avatars.githubusercontent.com/u/47188731?v=4&s=200",
          "alt": "Kedasha Kerr",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to use GitHub Copilot to help review and polish your code.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/github-for-beginners-code-review-and-refactoring-with-github-copilot/\">GitHub for Beginners: Code review and refactoring with GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用GitHub Copilot中的编码代理分配和完成问题 (原标题: Assigning and completing issues with coding agent in GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/",
      "pubDate": "Fri, 06 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-06T16:00:00.000Z",
      "creator": "Alexandra Lietzke",
      "summary": "# GitHub Copilot 编码代理：分配与完成问题\n\nGitHub Copilot 推出了一项新的编码代理功能，旨在帮助开发者更高效地工作，通过将 GitHub 问题分配给它，从而获得经过充分测试的拉取请求。\n\n## 编码代理概述\n\n*   **功能定位**：作为一种新型的软件工程代理，它直接内置于 GitHub 中，一旦被分配 GitHub Issue 或在 VS Code 中收到提示，便会开始工作。\n*   **工作方式**：它像一位异步协作的队友，基于您分配的问题构建拉取请求。它不是简单的自动补全，而是能够异步工作，帮助您加速开发、清理技术债务并专注于更重要的工作。\n*   **核心机制**：\n    *   基于 GitHub Actions 构建，提供集成、安全、可定制的环境。\n    *   接收问题后，会规划工作、打开拉取请求、编写代码、运行测试，然后请求您的审查。\n    *   如果收到反馈，它会修改拉取请求并持续工作直到您批准。\n    *   能够整合相关问题或 PR 讨论的上下文，并遵循团队设定的自定义仓库指令。\n\n## 编码代理与代理模式的区别\n\n*   **代理模式 (Agent Mode)**：\n    *   同步协作器，在您工作时进行配对。\n    *   在 IDE（如 VS Code, JetBrains, Eclipse, Xcode）内作为实时协作器工作，迭代代码、运行测试并实时修正错误。\n*   **编码代理 (Coding Agent)**：\n    *   异步协作器，代表您像队友一样工作。\n    *   作为 SWE 代理在 GitHub Actions 内部运行，接收您分配的问题，探索仓库以获取上下文，编写代码，通过测试，并打开拉取请求供您审查。\n*   **资源消耗**：两者都使用 Copilot 高级请求，编码代理还会消耗 GitHub Actions 分钟数。\n\n## 编码代理的优势与应用场景\n\nGitHub 高级软件工程师 Brittany Ellich 指出，编码代理能帮助开发者更好地完成多项任务：\n\n*   **卸载重复性任务**：例如添加和扩展单元测试、快速修复拼写错误、进行小型重构等。\n*   **改善问题管理和文档**：通过快速修复和小型重构来维护更好的问题卫生和文档。\n*   **提升用户体验**：修复错误、更新用户界面功能和增强可访问性。\n\n通过将这些低到中等复杂度的任务分配给编码代理，开发者可以有更多精力专注于高层次的问题解决和设计、处理积压的技术债务、学习新技能等。\n\n## 使用编码代理完成问题的步骤\n\n尽管 Copilot 执行工作，但您始终掌握控制权：您决定分配什么、批准什么以及需要更改什么。Copilot 还可以通过其“创建问题流程”预览功能帮助您构建问题。\n\n1.  **编写并分配问题给 Copilot**\n    *   这是最关键的步骤，需要提供充足的上下文，如同向团队成员简要说明任务。\n    *   **包含信息**：相关背景信息、预期结果、技术细节、格式或 linting 规则。\n    *   **分配方式**：通过 github.com、GitHub 移动应用或 GitHub CLI。\n    *   **任务范围**：最适合范围明确的任务，但也能处理大型任务（可能耗时更长）。可以批量分配多个问题。\n    *   **实用技巧**：\n        *   使用问题模板（如“描述”和“验收标准”字段）提高一致性。\n        *   Copilot 会利用仓库中的自定义指令（如自动生成文件、格式化规则）。\n        *   代理能够识别分配问题中包含的图片，因此您可以分享新功能的外观图片。\n\n2.  **Copilot 规划代码**\n    *   分配后，Copilot 会添加 👀 表情符号反应，并启动 GitHub Actions 会话。\n    *   在此环境中，Copilot 会探索和分析代码库、运行测试并进行更改。\n    *   它会同时打开一个分支和一个拉取请求，并随着工作进展而演变。\n    *   Copilot 会阅读问题并将其分解为任务清单，然后更新拉取请求。\n    *   完成任务后，Copilot 会将其勾选并推送提交。您可以实时查看会话、查看日志或刷新 PR。\n\n3.  **Copilot 编写代码**\n    *   当拉取请求时间线显示“Copilot started work”事件时，表示工作已开始。\n    *   Copilot 会根据问题修改代码库，运行自动化测试和 linter（如果存在），并根据需要更新或生成测试。\n    *   它会迭代推送提交。您可以实时查看工作进展，并在必要时介入以确保方向正确。\n\n4.  **审查并合并拉取请求**\n    *   Copilot 完成工作后，会标记您进行审查。您可以：\n        *   批准拉取请求\n        *   留下评论\n        *   要求更改\n    *   Copilot 会根据仓库规则自动请求审阅者。可以进行多轮审查。\n    *   **重要提示**：问题创建者不能是最终批准者。需要由同事、经理或指定审阅者批准，以促进协作并确保代码安全。\n\n## 成功使用编码代理的建议\n\n*   **编写全面的问题**：清晰、范围明确、文档完善的问题会带来更好的结果。\n*   **从小处着手**：尝试将代理用于测试、文档或简单的重构。\n*   **故障排除**：如果 Copilot 遇到问题，在评论中标记它并添加更多上下文。迭代和完善问题要求也有帮助。\n\n## 展望\n\nAI 和 LLM 正在快速发展，编码代理已在实际工作流程中展现出实用性。鼓励开发者尝试使用编码代理，构建自己的代理工作流。",
      "shortSummary": "GitHub Copilot 推出了一项新的编码代理功能，允许开发者将 GitHub 问题分配给它。该代理作为异步队友，能自动规划、编写代码、运行测试并创建拉取请求，从而帮助开发者卸载重复性任务，专注于更复杂的开发工作。用户始终保持控制权，通过细致的问题描述和审查流程指导代理。这项功能旨在显著提升开发效率，加速软件交付。",
      "translated_title": "使用GitHub Copilot中的编码代理分配和完成问题",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Have you tried the new coding agent in GitHub Copilot? Here’s how developers are using it to work more efficiently. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/\">Assigning and completing issues with coding agent in GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-06-27T04:38:31.081Z"
}