{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "使用GitHub Models在Actions中自动化你的项目 (原标题: Automate your project with GitHub Models in Actions)",
      "link": "https://github.blog/ai-and-ml/generative-ai/automate-your-project-with-github-models-in-actions/",
      "pubDate": "Mon, 04 Aug 2025 16:00:00 +0000",
      "isoDate": "2025-08-04T16:00:00.000Z",
      "creator": "Kevin Lewis",
      "summary": "## 使用GitHub Models在Actions中自动化你的项目\n\nGitHub Models将人工智能（AI）引入GitHub Actions工作流，帮助您在项目所在位置自动化分类、总结等任务。本文探讨了三种集成和自动化使用GitHub Models的方法，从最直接到最强大。\n\n### 前置条件：添加正确的权限\n\n在使用GitHub Models之前，您的工作流需要获得访问AI模型的权限。在工作流的权限块中添加以下行即可：\n\n```yaml\npermissions:\n  contents: read\n  issues: write\n  models: read\n```\n\n这些权限允许工作流读取仓库内容、读写问题和评论，最重要的是，启用对GitHub Models的访问。\n\n### 示例一：在Bug报告中请求更多信息\n\n此示例展示了如何使用AI推理操作以及如何利用AI创建分支逻辑，以自动化处理信息不足的Bug报告。\n\n*   **目标**：自动检查新的Bug报告是否包含足够信息，并在信息不足时自动回复。\n*   **工具**：`actions/ai-inference` 操作，允许调用领先的AI模型来分析或生成文本。\n*   **工作流 (`bug-reproduction-instructions.yml`) 设置**：\n    *   **触发器**：当新问题被打开时 (`on: issues: types: [opened]`)。\n    *   **权限**：`contents: read`, `issues: write`, `models: read`。\n    *   **步骤**：\n        1.  **获取问题**：使用`actions/github-script`获取问题的标题和正文。\n        2.  **分析问题以进行复现**：\n            *   仅当问题标记为“bug”时执行 (`if: contains(..., 'bug')`)。\n            *   使用`actions/ai-inference@v1`，配置`mistral-ai/ministral-3b`模型（可替换为GitHub Models目录中的40多种模型）。\n            *   `system-prompt`定义了有效复现说明的特征（复现步骤、预期/实际行为、环境细节）。如果信息足够，AI返回“pass”；否则，返回缺失信息的简要描述。\n        3.  **评论问题**：\n            *   仅当问题标记为“bug”且AI返回的值不是“pass”时执行。\n            *   使用`actions/github-script@v7`将AI的回复作为评论发布到问题中。\n*   **核心思想**：通过提示AI模型在满足特定条件时返回固定字符串（如“pass”），可以在工作流中创建AI驱动的条件逻辑。\n\n![An issue on GitHub named \"Doesn't work on firefox\" with no description and a bug label. The github-actions bot responds asking for more information - specifically reproduction steps, expected and actual behavior, and browser and operating system details.](https://github.blog/wp-content/uploads/2025/07/image1_5f1e88.png?resize=1024%2C755)\n\n### 示例二：从合并的拉取请求创建发布说明\n\n此示例展示了如何使用`gh CLI`与`gh-models`扩展来自动化发布说明的生成。\n\n*   **目标**：当拉取请求合并时，自动汇总其内容并添加到发布说明问题中。\n*   **工具**：`gh CLI`及`gh-models`扩展。\n*   **设置**：创建一个名为“release”的标签，并创建一个名为“Publish next release changelog”的问题，并为其添加“release”标签。\n*   **工作流 (`release-notes.yml`) 设置**：\n    *   **触发器**：当拉取请求关闭时 (`on: pull_request: types: [closed]`)。\n    *   **条件**：仅当拉取请求已合并时运行 (`if: github.event.pull_request.merged == true`)。\n    *   **权限**：`pull-requests: read`, `issues: write`, `contents: read`, `models: read`。\n    *   **步骤**：\n        1.  **检出仓库**：使用`actions/checkout@v4`。\n        2.  **安装gh-models扩展**：运行`gh extension install https://github.com/github/gh-models`，需要工作流令牌。\n        3.  **汇总拉取请求并追加到发布问题**：\n            *   使用`gh pr view`获取PR的标题、正文、评论和评审信息，并保存到文件。\n            *   将PR数据通过管道传递给`gh models run xai/grok-3-mini`，并提供一个提示，要求生成一个简洁的单行变更日志条目。\n            *   获取带有“release”标签的发布问题编号和当前正文。\n            *   将AI生成的摘要（包含PR编号）追加到发布问题正文。\n            *   使用`gh issue edit`更新发布问题。\n\n![A pull request named Publish Next Release Changelog. The description has two bullet list items - each one describing a change in 8-12 words with a link to the merged pull request.](https://github.blog/wp-content/uploads/2025/07/image2_f6eb85.png?resize=1024%2C438)\n\n### 示例三：汇总和优先排序问题\n\n此示例演示了如何使用`GitHub CLI`、`gh-models`扩展和提示文件来自动化更复杂的定时工作流，以每周汇总、主题化和优先排序新问题。\n\n*   **目标**：每周生成一个问题，汇总、主题化并优先排序过去一周新打开的问题。\n*   **工具**：`gh CLI`、`gh-models`扩展和独立的提示文件。\n*   **工作流 (`weekly-issue-summary.yml`) 设置**：\n    *   **触发器**：手动触发 (`workflow_dispatch`) 或每周一上午9点定时触发 (`schedule: - cron: '0 9 * * 1'`)。\n    *   **权限**：`issues: write`, `contents: read`, `models: read`。\n    *   **步骤**：\n        1.  **检出仓库**：使用`actions/checkout@v4`。\n        2.  **安装gh-models扩展**：运行`gh extension install https://github.com/github/gh-models`。\n        3.  **获取过去一周的问题并汇总**：\n            *   使用`gh search issues`获取过去一周内创建的开放问题（标题、正文、URL），并保存到文件。\n            *   将问题数据通过管道传递给`gh models run --file prompts/issue-summary.prompt.yml`。\n        4.  **提示文件 (`prompts/issue-summary.prompt.yml`)**：\n            *   定义模型（如`openai/gpt-4.1`）、系统和用户提示。\n            *   系统提示：“你是一个有用的问题汇总器。”\n            *   用户提示：“请将以下问题总结为几个简短的要点。如果提供链接，请包含。如果可能，提取一般主题并帮助团队根据影响进行优先排序。”\n            *   使用`{{input}}`占位符接收管道数据。\n            *   优势：通过`.prompt.yml`文件，可以利用GitHub Models的仓库集成，通过丰富的UI迭代提示。\n        5.  **创建问题**：使用`gh issue create`创建新问题，标题包含日期范围，并使用AI生成的摘要作为正文。\n\n![An issue with the title \"Issue Summary - June 16 to June 23\". It has three sections - an issue summary which details and links each issue that has been opened, general themes which contains three groupings for the issues, and suggested prioritization. The top issue is on data integrity - issue 37.](https://github.blog/wp-content/uploads/2025/07/image3_6c2c47.png?resize=972%2C1024)\n\n### 总结\n\n无论是从简单的AI推理操作开始，使用带有内联提示的`gh-models CLI`，还是创建功能齐全、提示驱动的工作流，GitHub Models都使您能够轻松地通过AI扩展您的项目流程。只需添加正确的权限，选择一个上述示例，即可在您的下一个工作流中尝试GitHub Models。",
      "shortSummary": "GitHub Models将AI集成到GitHub Actions，实现项目自动化。通过设置特定权限，用户可利用AI处理任务。文章展示了三种应用：一是使用`actions/ai-inference`自动请求Bug报告补充信息；二是利用`gh CLI`和`gh-models`从PR生成发布说明；三是结合定时任务和提示文件，每周汇总并优先排序新问题。这些方法使开发者能更高效地管理项目，简化工作流程。",
      "translated_title": "使用GitHub Models在Actions中自动化你的项目",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/image1_5f1e88.png?resize=1024%2C755",
          "alt": "An issue on GitHub named \"Doesn't work on firefox\" with no description and a bug label. The github-actions bot responds asking for more information - specifically reproduction steps, expected and actual behavior, and browser and operating system details.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/image2_f6eb85.png?resize=1024%2C438",
          "alt": "A pull request named Publish Next Release Changelog. The description has two bullet list items - each one describing a change in 8-12 words with a link to the merged pull request.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/image3_6c2c47.png?resize=972%2C1024",
          "alt": "An issue with the title \"Issue Summary - June 16 to June 23\". It has three sections - an issue summary which details and links each issue that has been opened, general themes which contains three groupings for the issues, and suggested prioritization. The top issue is on data integrity - issue 37.",
          "title": "",
          "position": 3
        },
        {
          "url": "https://avatars.githubusercontent.com/u/1461554?v=4&s=200",
          "alt": "Kevin Lewis",
          "title": "",
          "position": 4
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to integrate AI features with GitHub Models directly in GitHub Actions workflows.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/automate-your-project-with-github-models-in-actions/\">Automate your project with GitHub Models in Actions</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "入职你的AI结对程序员：成功设置GitHub Copilot编码代理 (原标题: Onboarding your AI peer programmer: Setting up GitHub Copilot coding agent for success)",
      "link": "https://github.blog/ai-and-ml/github-copilot/onboarding-your-ai-peer-programmer-setting-up-github-copilot-coding-agent-for-success/",
      "pubDate": "Thu, 31 Jul 2025 17:12:43 +0000",
      "isoDate": "2025-07-31T17:12:43.000Z",
      "creator": "Christopher Harrison",
      "summary": "## 入职你的AI结对程序员：成功设置GitHub Copilot编码代理\n\nGitHub Copilot被定位为AI结对程序员或团队中的AI成员，其编码代理（coding agent）功能能够自主处理问题并提出解决方案。要确保Copilot编码代理的成功，需要进行类似于新开发人员入职的配置和优化。\n\n### GitHub Copilot中的代理工作流：编码代理 vs. 代理模式\n\nGitHub Copilot提供两种核心代理能力：\n\n*   **编码代理 (Coding Agent)**：一个自主工具。你向Copilot分配一个问题，它会在后台启动Actions容器，迭代工作，并最终返回一个拉取请求（PR）。这是一种异步的、面向拉取请求的交互模式。\n*   **代理模式 (Agent Mode)**：一个交互式助手。它在编辑器或github.com上实时执行较小的、多步骤的任务。这是一种对话式的、即时的交互模式。\n\n### Copilot编码代理的工作流程：从问题到可审查的拉取请求\n\n当一个问题被分配给Copilot时，它会遵循以下模式：\n\n1.  为将要创建的代码创建一个分支。\n2.  创建一个拉取请求来跟踪其工作并与团队沟通。\n3.  为其工作创建一个受限环境（在GitHub Actions内部运行）。\n4.  阅读问题或提示以理解请求的任务。\n5.  探索项目以确定解决问题的最佳方法。\n6.  迭代地朝着解决方案工作。\n7.  完成工作，更新拉取请求，并通知团队拉取请求已准备好审查。\n\n理解这个流程有助于我们确保Copilot的成功。\n\n### 使用GitHub Actions配置Copilot的环境\n\n为了让Copilot高效工作，它需要访问团队使用的所有工具、服务、库和框架。这可以通过自定义工作流文件来实现：\n\n*   **工作原理**：编码代理在GitHub Actions中运行的容器内工作。你可以利用Actions的YAML配置能力来确保容器正确设置。\n*   **配置步骤**：\n    *   在`.github/workflows/copilot-setup-steps.yml`路径下创建一个名为`copilot-setup-steps`的作业。\n    *   在该作业中列出安装环境所需的所有步骤（例如，安装Python和SQLite依赖）。\n    *   每次将问题分配给Copilot时，它都会运行此工作流来配置其环境。\n*   **专业提示**：可以重用现有的用于开发环境（如运行测试或验证脚本）的工作流。\n*   **重要提示**：如果某些操作应以特定方式完成，请明确告知Copilot，避免其自行推断导致意外版本或错误。\n\n### 通过精心编写的问题和提示设置Copilot的成功\n\n问题或提示是Copilot创建拉取请求的入口点。问题定义越清晰，拉取请求的质量就越高。一个好的问题应包含：\n\n*   清晰定义的问题陈述或用户故事。\n*   如果是bug，提供完整的错误信息、堆栈跟踪、输出以及重现步骤。\n*   任何相关的历史或之前尝试过的方法。\n*   关于如何处理问题的建议。\n\n**示例**：一个将测试从unittest迁移到pytest的良好问题描述，详细说明了需求、现有资源和推荐方法。\n\n### 使你的仓库受欢迎（对开发者和AI）\n\n优化项目结构和文档对Copilot和新入职的开发者同样重要。Copilot在处理问题时会探索代码库，查找README文件并阅读文档，然后进行代码库搜索。\n\n*   **优化内容**：\n    *   拥有健壮且最新的项目和服务README文件。\n    *   代码中包含描述操作的注释。\n    *   遵循良好的命名规范（类、函数、变量）。\n    *   逻辑化的项目结构，遵循文件夹名称和实体分组的最佳实践。\n*   **专业提示**：通过查看Copilot创建的PR中的“View session”按钮，你可以了解Copilot的工作方式，从而进一步优化任务分配和环境配置。\n\n### 使用Copilot自定义指令记录机构知识\n\n自定义指令是指导Copilot的最佳方式，它们可以包含代码格式规则或团队“固有”但未书面记录的机构知识。Copilot编码代理支持两种类型的指令文件：\n\n1.  **仓库级指令文件 (`copilot-instructions.md`)**：\n    *   存储在代码库的`.github/copilot-instructions.md`中。\n    *   适用于所有请求。\n    *   应包含：项目概览、构建方式、用户故事、使用的框架和库、项目结构、全局编码指南和规则。\n    *   **示例**：一个关于经典街机项目的指令文件，包含标准玩家流程、框架、编码指南和项目结构。\n\n2.  **目标指令文件 (`.instructions.md`)**：\n    *   存储在代码库的`.github/instructions/`文件夹（或其子文件夹）中。\n    *   可以通过`applyTo`部分设置glob模式，以指定规则适用的文件类型（例如，`**/games/*.py`）。\n    *   包含特定于这些文件的指令，如继承的基类和测试要求。\n    *   **示例**：一个针对游戏文件的指令文件，要求所有游戏继承自`BaseGame`，并包含单元测试要求。",
      "shortSummary": "本文介绍了如何成功设置和使用GitHub Copilot编码代理。关键在于通过GitHub Actions配置其运行环境，编写清晰详细的问题和提示以指导其工作，优化项目结构和文档以提高其理解效率。此外，利用仓库级和目标文件级的自定义指令，可以向Copilot传达编码规范和机构知识，确保其生成的代码符合团队标准，从而使其成为高效的AI结对程序员。",
      "translated_title": "入职你的AI结对程序员：成功设置GitHub Copilot编码代理",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Learn how to configure Copilot coding agent’s environment, optimize project structure, use custom instructions, and extend its capabilities with MCP servers.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/onboarding-your-ai-peer-programmer-setting-up-github-copilot-coding-agent-for-success/\">Onboarding your AI peer programmer: Setting up GitHub Copilot coding agent for success</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub MCP 服务器实用指南 (原标题: A practical guide on how to use the GitHub MCP server)",
      "link": "https://github.blog/ai-and-ml/generative-ai/a-practical-guide-on-how-to-use-the-github-mcp-server/",
      "pubDate": "Wed, 30 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-30T16:00:00.000Z",
      "creator": "Andrea Griffiths",
      "summary": "# GitHub MCP 服务器实用指南\n\n本文提供了一份关于如何从本地 Docker 镜像升级到 GitHub 托管的 Model Context Protocol (MCP) 服务器的实用指南，旨在帮助用户自动化拉取请求、持续集成和安全分类等任务，且无需令牌。\n\n## GitHub MCP 服务器简介\n\n本地运行 MCP 服务器虽然可行，但管理 Docker、轮换访问令牌和拉取更新等操作繁琐。GitHub 托管的 MCP 端点消除了这些基础设施的烦恼，让开发者能够专注于代码交付。本教程将引导用户从本地 MCP 设置升级到 GitHub 托管端点，从而获得 OAuth 认证、自动更新以及访问更丰富的 AI 工作流所需的工具集。用户还将学习如何通过只读模式自定义工具访问、通过动态工具集简化 AI 工作流，并为使用 GitHub Copilot 进行代理间协作做好准备。\n\nGitHub 远程 MCP 服务器是 GitHub 完全托管、始终保持最新状态的 MCP 实现。用户只需将 IDE 或代理主机指向 `https://api.githubcopilot.com/mcp/`，并通过 OAuth 进行一次性认证，GitHub 将处理其余所有事务。\n\n### 默认启用的工具集（可禁用）\n\n*   **代码库智能：** 无需本地克隆即可搜索代码、流式传输文件和打开拉取请求。\n*   **问题和拉取请求自动化：** 从单个代理提示中归档、分类、标记、审查甚至合并。\n*   **CI/CD 可见性：** 在聊天中检查工作流运行、获取日志并重新运行失败的作业。\n*   **安全洞察：** 发现代码扫描和 Dependabot 警报，确保在漏洞被利用前修复。\n*   **细粒度控制：** 切换特定工具集或将服务器设置为只读模式以提高安全性。\n\n## 为什么选择托管 MCP 服务器？\n\n本地开源 MCP 服务器虽然可用，但存在隐性成本。以下是切换到远程托管服务器后的变化：\n\n| 特性           | 本地 Docker 服务器          | 托管 MCP 端点                   |\n| :------------- | :-------------------------- | :------------------------------ |\n| 维护与升级     | 手动维护 Docker 镜像，手动升级 | GitHub 自动修补和升级           |\n| 认证           | 管理个人访问令牌 (PATs)     | 通过 OAuth 一次性登录，范围自动处理 |\n| 可访问性       | 仅在 localhost 上暴露服务器 | 可从任何 IDE 或远程开发环境访问   |\n| 写入权限       | 除非自定义二进制文件，否则完全写入权限 | 内置只读开关和按工具集标志控制    |\n\n对于大多数团队而言，托管服务器消除了基础设施工作，使团队能够专注于自动化。但如果需要气隙环境，仍需坚持使用本地设置。\n\n## 开始前的准备\n\n*   GitHub Copilot 或 Copilot Enterprise 席位\n*   VS Code 1.92+（或其他支持 MCP 的客户端）\n*   网络访问 `https://api.githubcopilot.com`\n*   一个用于实验的测试仓库\n\n## 步骤 1：安装远程 MCP 服务器\n\n与基于本地 Docker 的安装相比，设置 GitHub 远程 MCP 服务器非常简单。它由 GitHub 托管，无需管理 Docker 容器或手动处理更新，提供简化的云原生体验。\n\n### 在 VS Code 或 VS Code Insiders 上安装：\n\n1.  打开命令面板并运行：`> GitHub MCP: Install Remote Server`\n2.  完成 OAuth 流程以连接您的 GitHub 账户。\n3.  重启服务器以完成设置。\n\n### 对于任何其他客户端：\n\n1.  将服务器 URL 设置为：`https://api.githubcopilot.com/mcp/`\n2.  在提示时进行认证。\n\n### 验证连接：\n\n使用 `curl -I https://api.githubcopilot.com/mcp/healthz` 进行快速检查。如果看到 `HTTP/1.1 200 OK`，则表示连接成功。安装后，远程服务器将取代本地服务器，无需 Docker 或令牌，只需简单的集成。\n\n## 步骤 2：配置访问控制\n\n### 使用只读模式进行安全探索\n\n在敏感环境、生产测试或向利益相关者演示时，可以将服务器切换到只读模式：\n\n```json\n{\n  \"servers\": {\n    \"github\": {\n      \"type\": \"http\",\n      \"url\": \"https://api.githubcopilot.com/mcp/\",\n      \"mode\": \"read-only\"\n    }\n  }\n}\n```\n\n在此模式下，代理可以读取问题、拉取请求和代码，但无法推送更改。这非常适合需要上下文而无风险的代码审查。\n\n**用例：拉取请求查看器**\n无需修改任何内容即可审查拉取请求。此设置提供安全的只读访问，非常适合浏览更改、留下评论或收集上下文，而不会有更改代码的风险。\n\n1.  访问 GitHub MCP 服务器仓库。\n2.  导航到“Remote Server”部分。\n3.  选择拉取请求只读变体。\n4.  点击“Install Read Only”。\n\n您将看到 `listPullRequests`、`getPullRequest` 和 `searchPullRequests` 等工具，但没有写入权限。由于这些工具不进行更改，VS Code 会跳过权限提示，提供无缝体验。\n\n### 通过选择性工具集限制范围\n\n通过以下命令仅暴露所需的工具，使开发人员和代理都保持专注：\n\n```json\n\"toolsets\": [\"context\", \"issues\", \"pull_requests\"]\n```\n\n将此数组添加到 `mode` 字段旁边即可隐藏其他所有内容。\n\n## 步骤 3：通过三个实践示例进行尝试\n\n这些实际示例展示了 Copilot 代理模式如何在实践中处理日常开发任务，如管理拉取请求、调试工作流和分类安全警报，而无需本地设置或手动挖掘。只需提示即可。\n\n### 示例 1：添加 CODEOWNERS 文件并打开拉取请求\n\n打开您的仓库，然后询问 Copilot 代理：\n提示：“为 `/api/**` 添加一个 CODEOWNERS 文件，分配给 `@backend-team`，然后打开一个草稿拉取请求。”\n\n代理将：\n*   使用 `repos.create_file` 添加 CODEOWNERS 文件。\n*   调用 `pull_requests.open` 创建拉取请求。\n*   执行 `pull_requests.request_reviewers` 分配审阅者。\n\n无需本地克隆，无需手动创建文件。只需提示即可完成。\n\n### 示例 2：调试失败的工作流\n\n提示：“昨晚 `release.yml` 作业为什么失败了？”\n代理将使用 `actions.get_workflow_run_logs` 拉取日志，分析堆栈跟踪，并建议修复方案。这就像有一位高级工程师审查您的 CI/CD 故障。\n\n### 示例 3：分类安全警报\n\n提示：“列出我所有仓库中的关键 Dependabot 警报，并为每个警报创建问题。”\n服务器将通过 `dependabot.list_dependabot_alerts` 返回警报，然后代理仅在需要时创建有针对性的问题。\n\n## 步骤 4：GitHub 远程 MCP 服务器故障排除技巧\n\n| 症状             | 可能原因                   | 修复方法                               |\n| :--------------- | :------------------------- | :------------------------------------- |\n| 安装时 401 Unauthorized | 遗留的 `GITHUB_TOKEN` 环境变量 | 取消设置该变量并重新运行 OAuth 流程    |\n| 工具不显示       | 企业代理阻止 `api.githubcopilot.com` | 添加代理设置或将该域列入白名单         |\n| 模型超时         | 启用了大型工具集           | 仅限于所需的工具集                     |\n\n## 步骤 5：使用动态工具集简化工作流\n\n完整的 MCP 服务器包含 70 多个工具，虽然功能强大，但这可能会让您和 AI 模型感到不知所措。这就是动态工具集的用武之地。\n\n**工作原理：**\n大型语言模型 (LLM) 最初只包含少量元工具：`listAvailableToolsets`、`enableToolset` 和 `getToolsetTools`。它会根据手头的任务（例如“处理拉取请求”）确定所需工具，然后仅获取并启用这些工具。VS Code 会通过工具更改通知自动加载它们。这使得您的界面（和您的 AI）保持专注和高效。\n\n## 步骤 6：安全和代理工作流的下一步发展\n\nGitHub MCP 服务器正在积极发展。以下是即将推出的功能：\n\n### MCP 中的秘密扫描\n\n很快，MCP 服务器将能够检测并阻止 AI 生成的秘密，就像 GitHub 阻止您在拉取请求中推送秘密一样。如果需要，您可以覆盖，但默认设置会保护您的数据，无论是来自提示注入还是意外情况。\n\n### 将问题分配给 Copilot\n\n与 Copilot 编码代理的直接集成意味着您将能够：\n*   将问题直接分配给 Copilot。\n*   从 VS Code 触发完成。\n*   观察代理间工作流在不同工具之间展开。\n\n未来是代理与代理之间的协作，而 GitHub MCP 是其基础。\n\n## 贡献与总结\n\nGitHub MCP 项目是完全开源的，并且发展迅速。欢迎：\n*   **探索仓库：** 了解工具的构建方式并贡献您自己的工具。\n*   **提交问题：** 帮助塑造协议和工具。\n*   **加入讨论：** 在 GitHub 和 Discord 上与其他构建者联系。\n\n无论您是构建工具、提供反馈还是探索 AI 驱动的开发，MCP 生态系统都有您的位置。\n\nGitHub 远程 MCP 服务器消除了基础设施开销，让您能够专注于构建更好的自动化。不再需要管理 Docker，不再需要轮换令牌，只需一次 OAuth 认证即可开始交付。记住：最好的基础设施是您无需管理的基础设施。\n\n阅读完整的文档以开始使用，或深入研究上述示例并立即开始实验。",
      "shortSummary": "GitHub MCP 服务器提供托管服务，简化AI工作流。它替代了本地Docker设置，消除了令牌管理和手动更新的繁琐。通过OAuth认证，用户可获得自动更新和丰富的AI工具集，支持代码库智能、PR自动化、CI/CD可见性及安全洞察。该服务提供只读模式和动态工具集等细粒度控制。未来将集成AI生成秘密扫描和Copilot代理间协作，旨在实现代理间的无缝协作，让开发者专注于代码交付。",
      "translated_title": "GitHub MCP 服务器实用指南",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Upgrade from a local MCP Docker image to GitHub’s hosted server and automate pull requests, continuous integration, and security triage in minutes — no tokens required.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/a-practical-guide-on-how-to-use-the-github-mcp-server/\">A practical guide on how to use the GitHub MCP server</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "从首次提交到大型项目：收听我们的全新开源播客 (原标题: From first commits to big ships: Tune into our new open source podcast)",
      "link": "https://github.blog/open-source/maintainers/from-first-commits-to-big-ships-tune-into-our-new-open-source-podcast/",
      "pubDate": "Tue, 29 Jul 2025 16:31:29 +0000",
      "isoDate": "2025-07-29T16:31:29.000Z",
      "creator": "Abigail Cabunoc Mayes",
      "summary": "# GitHub推出全新开源播客：从首次提交到大型项目\n\nGitHub隆重推出全新播客，旨在深入探讨开源世界的运作机制，以及为何如此多的人持续投入其中共同建设。播客将深入挖掘代码背后的故事：塑造开源生态系统的项目、人物和理念。\n\n## 播客宗旨与GitHub愿景\nGitHub认为开源一直是未来创新的启动平台。尤其在2025年，软件领域的一切新事物，从AI代理到边缘运行时再到气候技术仪表板，都始于公共仓库，任何人都可以轻松地进行分叉、重混和改进。投资开源公共领域，不仅是赞助代码，更是为全球的研发引擎提供支持。播客将围绕这一核心理念，探索构成当今开源的一切要素。\n\n## 核心贡献者团队\n播客由一支由资深开源贡献者组成的轮值主持团队共同呈现，包括：\n*   **Cassidy Williams**\n*   **Kedasha Kerr**\n*   **Andrea Griffiths**\n*   **Abby Cabunoc Mayes** (本文作者)\n\n他们都对开源世界的不同领域做出了长期贡献。团队将共同探讨当前开源领域中令人兴奋、充满挑战和不断演变的话题，涵盖社区建设、开放科学、开发者教育以及公开构建等。每位主持人都会为对话带来独特的视角。\n\n## 首期节目亮点\n在首期节目中，主持人团队进行了自我介绍，分享了他们如何参与到开源中，以及是什么让他们坚持不懈。\n*   Kedasha讨论了在看似充斥着初学者开发者内容的今天，创建初学者内容的重要性。\n*   Cassidy分享了她十几岁时偶然听到的一段对话如何激发了她对代码的热爱。\n\n节目还特别介绍了本周引起他们关注的一些优秀开源项目：\n*   **Anime.JS**：一个视觉效果惊艳的JavaScript动画库，激发创造力。\n*   **Docs**：由法国和德国政府开发的协作式开源文档编辑器。\n*   **CSS Zero**：一个无需构建的前端启动套件，简化了Web开发。\n\n## 播客内容与未来展望\n播客将每两周更新一期，分享来自开源生态系统中的维护者、贡献者和构建者的故事。内容将涵盖工具、标准以及那些带来乐趣（有时也带来混乱）的副项目。\n\n听众还将听到特邀嘉宾的分享，例如：\n*   **Jason Lengstorf**：为开发者制作电视节目。\n*   **Keeley Hammond**：Electron的核心维护者。\n\n他们将分享各自的旅程和见解。无论您是刚刚入门，还是已经维护项目多年，播客都将为您提供有价值的内容。\n\n## 即将推出\n下一期节目将深入探讨**模型上下文协议（Model Context Protocol, MCP）**：\n*   它是什么？\n*   为什么它很重要？\n*   它如何帮助提高AI工具的透明度和互操作性？\n\n节目将探索MCP如何建立在开放标准的悠久历史之上，以及它为当今开发者解锁了哪些可能性。\n\n## 作者与相关资源\n本文由 **Abigail Cabunoc Mayes** 撰写。\n![Abigail Cabunoc Mayes](https://avatars.githubusercontent.com/u/617994?v=4&s=200)\nAbigail Cabunoc Mayes 在 GitHub 工作，致力于帮助开源生态系统在当下和未来蓬勃发展。\n\n**相关文章与资源：**\n*   **我们需要一个欧洲主权技术基金**：探讨开源软件作为关键基础设施却资金不足的问题，以及GitHub开发者政策团队如何建立联盟以弥补维护资金缺口。\n*   **Docs**：掌握GitHub所需的一切，一站式获取。\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n    [前往Docs](https://docs.github.com/)\n*   **GitHub**：在GitHub上构建未来，这里是任何人、任何地点、构建任何事物的平台。\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n    [开始构建](https://github.com/)\n*   **客户案例**：了解使用GitHub进行构建的公司和工程团队。\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n    [了解更多](https://github.com/customer-stories)\n*   **GitHub Universe 2025**：最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山加入我们。\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)\n    [立即注册](https://github.com/universe)",
      "shortSummary": "GitHub推出全新开源播客，探讨开源生态系统的故事、人物和理念。播客由多位资深开源贡献者轮流主持，每两周更新一期。内容涵盖社区建设、开发者教育和精选开源项目（如Anime.JS、Docs、CSS Zero）。未来将邀请特邀嘉宾并深入探讨Model Context Protocol等前沿话题。播客旨在为开源社区提供洞察和灵感，无论初学者还是资深维护者都能从中受益。",
      "translated_title": "从首次提交到大型项目：收听我们的全新开源播客",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/617994?v=4&s=200",
          "alt": "Abigail Cabunoc Mayes",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Introducing the brand new GitHub Podcast: A show dedicated to the topics, trends, stories, and culture in and around the open source developer community on GitHub.</p>\n<p>The post <a href=\"https://github.blog/open-source/maintainers/from-first-commits-to-big-ships-tune-into-our-new-open-source-podcast/\">From first commits to big ships: Tune into our new open source podcast</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "扩大影响力：GitHub Copilot 如何赋能小农户 (原标题: Scaling for impact: How GitHub Copilot supercharges smallholder farmers)",
      "link": "https://github.blog/open-source/social-impact/scaling-for-impact-how-github-copilot-supercharges-smallholder-farmers/",
      "pubDate": "Mon, 28 Jul 2025 19:53:32 +0000",
      "isoDate": "2025-07-28T19:53:32.000Z",
      "creator": "Paull Young",
      "summary": "## One Acre Fund 简介与使命\n\nOne Acre Fund 始于 2006 年肯尼亚西部的 40 个农户家庭，现已发展成为一项强大的运动。如今，该组织在东非和南部非洲的十个国家为 500 万农户家庭提供服务。他们的宏伟目标是到 2030 年每年支持 1000 万农户家庭，并通过利用开源技术和人工智能，为这些社区创造惊人的 10 亿美元新收入。\n\n### 科技赋能农业\n\n对于小农户（通常耕作一英亩或更少土地的农民）而言，集约化农业对其繁荣至关重要。这种在相同土地上生产更多食物的过程，不仅能带来更高的作物产量，还能刺激经济、加强社区并帮助农民扩大规模。One Acre Fund 的核心使命是赋能这些农民，为他们提供一条摆脱贫困的直接途径。与传统小额信贷不同，他们不只提供现金贷款，而是直接提供重要的农业资源，如化肥和种子，以及培训和服务，为农民提供成功所需的工具。他们还帮助农民改善土壤健康和种植树木，不仅提高产量，还能帮助农民更好地应对气候变化带来的天气变化。\n\n> “过去，农民害怕使用技术。但随着我们为他们提供培训，他们现在渴望使用它。”\n> — Blaise Murame，One Acre Fund 区域负责人\n\n技术是 One Acre Fund 快速增长的核心。他们已从完全模拟的方法（在田间使用纸质记录与农民会面）转变为高度数字化的系统。这一转变彻底改变了他们的运营，使从物流和交付到农民注册以及培训材料开发的一切都变得更加高效。农民最初犹豫不决，但在及时获得资源和工具并比以往更快地实现目标后，现在渴望拥抱这项技术。\n\n## GitHub Copilot 的赋能作用\n\nOne Acre Fund 技术飞跃的一个重要部分来自于他们对 GitHub Copilot 的采用。\n\n> “自从 GitHub Copilot 问世以来，我们过去需要三周的开发工作现在可以在一周内完成。这影响了我们的目标——我们能够设定比去年更多的目标。”\n> — Yididiya Gebredingel，One Acre Fund 开发人员\n\n通过引入 GitHub Copilot，One Acre Fund 能够更快地推进开发，并专注于真正在实地产生影响的部分。这种加速使他们能够设定并实现更多目标，开发人员完成项目的速度提高了三倍，超过 30% 的工作由 AI 辅助完成。\n\n## 开源技术的重要性\n\n作为一个非营利组织，与世界上最贫困的人群打交道意味着在微薄的利润下运营。这使得其解决方案的成本效益至关重要。开源技术提供了理想的平衡，既提供了“解决方案的成熟度，又提供了解决方案的灵活性”，同时避免了随着规模扩大而呈指数级增长的许可费用负担。拥抱开源社区是 One Acre Fund 的一项战略举措，他们已将其大部分核心运营系统迁移到开源，以利用协作开发和社区支持。\n\n> “作为一个非营利组织，我们无法承受随着规模扩大而呈指数级增长的许可费用。开源为我们提供了解决方案成熟度和解决方案灵活性之间的正确平衡。”\n> — Sarah Hylden，One Acre Fund 全球运营总监\n\n## 总结与展望\n\n最终，One Acre Fund 相信，如果你有一个行之有效的干预措施，可以为农民创造可持续的脱贫之路，并且你知道它有效，那么你就有道德义务去扩大它的规模。在 GitHub Copilot 的帮助下，他们正在这样做——更快地行动，对数百万农户家庭的生活产生更大的影响。\n\n### 相关资源\n\n*   ![Paull Young](https://avatars.githubusercontent.com/u/157849754?v=4&s=200)\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切，尽在一处。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来，这里是任何人、任何地方构建任何东西的平台。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) 客户案例：了解使用 GitHub 进行构建的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：最后机会：节省 700 美元购买 Universe 现场通行证，于 10 月 28-29 日在旧金山与我们相聚。",
      "shortSummary": "One Acre Fund 是一家非营利组织，通过提供农资、培训和技术，帮助非洲小农户摆脱贫困。他们采用 GitHub Copilot 和开源技术，显著加速了软件开发，将项目完成速度提升三倍，并有效控制了成本。这使得组织能更快地扩大规模，目标是到 2030 年每年支持 1000 万农户，为他们创造 10 亿美元新收入，从而对数百万农户的生活产生深远影响。",
      "translated_title": "扩大影响力：GitHub Copilot 如何赋能小农户",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/157849754?v=4&s=200",
          "alt": "Paull Young",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Empowering 10 million farm families by 2030 to generate $1 billion in new revenue. How GitHub helps One Acre Fund’s mission — driving real impact across Africa.</p>\n<p>The post <a href=\"https://github.blog/open-source/social-impact/scaling-for-impact-how-github-copilot-supercharges-smallholder-farmers/\">Scaling for impact: How GitHub Copilot supercharges smallholder farmers</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何构建安全且可扩展的远程MCP服务器 (原标题: How to build secure and scalable remote MCP servers)",
      "link": "https://github.blog/ai-and-ml/generative-ai/how-to-build-secure-and-scalable-remote-mcp-servers/",
      "pubDate": "Fri, 25 Jul 2025 17:12:02 +0000",
      "isoDate": "2025-07-25T17:12:02.000Z",
      "creator": "Den Delimarsky",
      "summary": "## 如何构建安全且可扩展的远程MCP服务器\n\n本文探讨了构建安全且可扩展的远程模型上下文协议（MCP）服务器的关键方面。MCP允许AI代理连接到外部工具和数据源，而无需实现特定的API连接器，为大型语言模型（LLM）提供所需的上下文。\n\n### 为什么MCP的安全性至关重要\n\n与传统API不同，MCP服务器充当AI代理与无限数据源（包括敏感企业资源）之间的桥梁。安全漏洞不仅会危及数据，还可能使恶意行为者操纵AI行为并访问连接的系统。为了应对常见的攻击向量（如困惑代理问题、令牌传递漏洞和会话劫持），最新的MCP规范包含了安全指南和最佳实践。\n\n### 理解MCP授权\n\nMCP规范采用OAuth 2.1进行安全授权，利用了现代安全能力：\n\n*   **授权服务器发现**：MCP服务器实现OAuth 2.0受保护资源元数据（PRM）（RFC 9728），以公布其支持的授权服务器。\n*   **动态客户端注册**：使用OAuth 2.0动态客户端注册协议（RFC 7591）实现自动客户端注册，消除了AI代理动态连接时的手动设置需求。\n*   **资源指示符**：规范强制要求RFC 8707资源指示符，确保令牌绑定到特定的MCP服务器，防止令牌重用攻击。\n\n开发者可以利用现有的OAuth库和现成的授权服务器/身份提供商，无需从头开始构建安全基础设施。\n\n### 完整的授权流程\n\n连接到受保护的MCP服务器的流程遵循标准的OAuth模式：\n\n1.  **发现阶段**：MCP客户端尝试在没有凭据的情况下访问MCP服务器。\n2.  **服务器响应**：MCP服务器返回HTTP 401 Unauthorized响应，并在WWW-Authenticate头中包含元数据URL。\n3.  **元数据检索**：MCP客户端获取并解析受保护资源元数据，获取授权服务器端点。\n4.  **客户端注册**：MCP客户端自动向授权服务器注册（如果支持）。\n5.  **授权请求**：MCP客户端使用PKCE（Proof Key for Code Exchange）和资源参数启动OAuth流程。\n6.  **用户同意**：用户通过授权服务器授权访问。\n7.  **令牌交换**：MCP客户端交换授权码以获取访问令牌。\n8.  **认证请求**：MCP客户端向MCP服务器发出的所有后续请求都包含Bearer令牌。\n\n### 在MCP中实现授权\n\n大多数OAuth提供商无需额外配置即可用于MCP服务器授权。在实现授权时，需要考虑以下关键组件和行为：\n\n*   **PRM端点**：MCP服务器必须实现`/.well-known/oauth-protected-resource`端点以公布支持的授权服务器范围。MCP TypeScript SDK已原生集成此功能。\n*   **令牌验证中间件**：确保MCP服务器只接受为其签发的令牌，通过以下方式：\n    *   从授权头中提取Bearer令牌。\n    *   使用OAuth提供商的JWKS（JSON Web Key Sets）端点验证令牌签名。\n    *   检查令牌过期和受众声明。\n    *   确保令牌是专门为您的MCP服务器签发的。\n*   **错误处理**：MCP服务器需要返回正确的HTTP状态码（例如，缺少/无效令牌返回HTTP 401 Unauthorized，权限不足返回HTTP 403 Forbidden），并附带适当的WWW-Authenticate头。\n\nAnthropic和MCP社区正在将这些功能直接集成到MCP SDK中，以简化开发。\n\n### 处理多用户场景\n\nMCP服务器中的多租户引入了独特的安全挑战，需要强制执行严格的边界以防止未经授权的访问和数据泄露，解决“困惑代理”问题。\n\n*   **用户身份验证和验证**：OAuth令牌是安全识别用户的基础，其声明（如`sub`）包含用户信息，但必须严格验证。\n*   **强制授权策略**：将用户标识符映射到内部用户配置文件以确定其特定权限，并确保令牌的受众（`aud`）正确，防止令牌被用于其他MCP服务器。\n*   **数据隔离**：每个数据库查询、下游API请求、缓存查找和日志条目都必须限定在当前用户范围内，遵循最小权限原则。\n\n强烈建议使用现有、经过充分测试的库和框架来处理用户会话和数据范围限定。\n\n### 使用AI网关进行扩展\n\nAI网关位于MCP客户端和MCP服务器之间，充当防护罩和流量导向器，集中处理交叉关注点：\n\n*   **速率限制**：防止失控AI代理的资源耗尽。\n*   **JWT令牌验证**：在请求到达服务器前进行验证。\n*   **安全头注入**：保护免受常见Web漏洞侵害。\n*   **请求/响应转换**：优雅地处理协议演变。\n*   **缓存**：针对不经常变化的昂贵操作。\n*   **熔断器**：当下游服务出现问题时快速失败。\n\n这种关注点分离提高了可维护性和诊断效率。\n\n### 生产就绪模式\n\n部署MCP服务器到生产环境时，应采纳以下最佳实践：\n\n*   **更好的秘密管理**：\n    *   MCP服务器需要处理自身的一系列秘密来与各种服务、数据库或API通信。\n    *   生产环境中，环境变量是安全反模式。\n    *   现代方法是使用专用的秘密管理服务（如Azure Key Vault、AWS Secrets Manager或HashiCorp Vault）。\n    *   最安全的方式是使用**工作负载身份**（“无秘密”或“无密钥”），应用程序由云平台分配安全身份，在运行时检索所需秘密，无需在配置中处理长期凭据。\n    *   这支持动态、短生命周期的秘密，实现启动验证和运行时秘密轮换。\n    *   最小权限原则：每个MCP服务器实例只访问其任务绝对需要的秘密。\n*   **可观测性和监控**：\n    *   通过日志、指标和跟踪实现对操作的全面可见性。\n    *   **结构化日志**：跨请求边界保持一致性，使用唯一的关联ID追踪请求的完整旅程。\n    *   **分布式跟踪**：使用OpenTelemetry等标准，提供请求生命周期的详细视图，帮助识别性能瓶颈。\n    *   **安全事件日志**：捕获每次认证尝试、授权失败和异常访问模式，因为MCP服务器是高价值目标。",
      "shortSummary": "本文详细介绍了如何构建安全且可扩展的远程模型上下文协议（MCP）服务器。MCP使AI代理能连接外部数据源。安全性至关重要，规范采用OAuth 2.1进行授权，并强调了授权流程、令牌验证和多用户场景下的数据隔离。为实现可扩展性，建议使用AI网关集中处理流量和安全策略。生产实践包括采用工作负载身份进行高级秘密管理，以及通过结构化日志、分布式跟踪和安全事件日志实现全面的可观测性。",
      "translated_title": "如何构建安全且可扩展的远程MCP服务器",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>More context can mean more attack surfaces for your projects. Be prepared for what lies ahead with this guide.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/how-to-build-secure-and-scalable-remote-mcp-servers/\">How to build secure and scalable remote MCP servers</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何在 Azure Pipelines 中简化 GitHub API 调用 (原标题: How to streamline GitHub API calls in Azure Pipelines)",
      "link": "https://github.blog/enterprise-software/ci-cd/how-to-streamline-github-api-calls-in-azure-pipelines/",
      "pubDate": "Thu, 24 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-24T16:00:00.000Z",
      "creator": "Tiago Pascoal",
      "summary": "## Azure Pipelines 中简化 GitHub API 调用\n\n本文探讨了如何在 Azure Pipelines 中通过构建自定义 Azure DevOps 扩展来简化 GitHub API 调用，从而消除 JWT 生成和令牌管理的复杂性，实现强大的自动化和增强的安全控制。\n\n### Azure Pipelines 与 GitHub 的集成\n\nAzure Pipelines 是一个基于云的持续集成/持续交付 (CI/CD) 服务，与 GitHub 深度集成。它能够响应 GitHub 仓库的推送或拉取请求触发管道，并将执行结果通过 GitHub 状态检查报告回 GitHub，帮助开发者监控代码健康状况并强制执行规则集。\n\n### 常见用例和场景\n\n在 Azure Pipelines 中调用 GitHub API 的常见场景包括：\n\n*   **设置提交或拉取请求的状态检查：** 报告管道步骤（如测试、构建、安全扫描）的成功或失败，以强制执行策略并提供反馈。\n*   **向拉取请求添加评论：** 自动发布管道结果、测试覆盖率报告或部署信息。\n*   **更新仓库中的文件：** 自动更新文档、配置文件或版本号（如 `CHANGELOG.md`）。\n*   **管理 GitHub Issues：** 根据管道结果自动创建、更新或关闭问题（如测试失败时创建 Bug 报告）。\n*   **与 GitHub Advanced Security 集成：** 将代码扫描结果发送到 GitHub 的代码扫描功能，实现集中式漏洞管理。\n*   **管理发布和资产：** 成功部署后自动创建 GitHub 发布并上传构建产物。\n*   **使用 GitHub 部署跟踪部署：** 在 GitHub 界面中提供部署历史和状态的可视性。\n*   **触发 GitHub Actions 工作流：** 编排混合 CI/CD 场景，由 Azure Pipelines 处理部分任务，然后触发 GitHub Actions 进行后续处理。\n\n### 理解 GitHub API：REST 与 GraphQL\n\nGitHub API 提供两种主要的接口：\n\n*   **REST API：** 遵循 RESTful 原则，提供直接的 HTTP 端点，适用于管理仓库、问题、拉取请求等常见操作。易于上手，支持个人访问令牌、GitHub Apps 或 OAuth 令牌认证。\n*   **GraphQL API：** 提供更灵活高效的数据检索方式。允许在单个请求中精确指定所需数据，减少数据过度获取或不足，特别适用于检索复杂、嵌套的数据结构。\n\n### 如何选择正确的认证方法\n\nGitHub 提供三种主要的 API 认证方法：\n\n1.  **个人访问令牌 (PATs)：**\n    *   **优点：** 创建和使用简单，快速上手，适用于个人自动化，可配置权限和过期日期。\n    *   **缺点：** 与用户账户生命周期绑定，权限可能粗粒度（经典 PATs），需要手动轮换，一旦泄露可能暴露所有可访问的组织/仓库。\n2.  **OAuth 令牌：**\n    *   **优点：** 标准 OAuth 2.0 流程，适用于需要代表不同用户操作的第三方应用，用户批准权限。\n    *   **缺点：** 需要安全存储刷新令牌，需要服务器基础设施，比 PATs 更复杂，仍与用户账户绑定。\n3.  **GitHub Apps：**\n    *   **优点：** 作为独立实体运行，具有细粒度、仓库级别的权限，基于安装的访问控制，短生命周期令牌（最长 1 小时），更高的速率限制，提供最佳安全模型，不依赖用户账户，有审计跟踪。\n    *   **缺点：** 初始设置更复杂，需要实现 JWT，可能不适用于简单场景，需要私钥管理。\n\n**结论：** 鉴于其细粒度权限、安全特性和更高的速率限制，GitHub Apps 是 Azure Pipelines 中机器到机器集成的理想选择。其短生命周期令牌和基于安装的访问模型提供了比 PATs 和 OAuth 令牌更好的安全控制，特别适合 CI/CD 场景中的自动化。\n\n### 注册和安装 GitHub App\n\n使用 GitHub App 进行认证需要以下步骤：\n\n1.  **注册 GitHub App：** 在 GitHub Enterprise、组织或账户中注册应用，并选择适当的权限。权限决定了应用在企业、组织和仓库中的操作能力。请注意，权限更改可能需要所有者管理员重新授权。通常建议将应用设置为私有。\n2.  **保存私钥：** 如果生成了私钥，请将其安全保存。私钥用于向 GitHub 认证以生成安装令牌。\n3.  **安装 GitHub App：** 将应用安装到将与之交互的账户或组织上，并选择应用可以访问的仓库（所有仓库或特定仓库）。\n\n### GitHub App 认证流程\n\nGitHub Apps 使用两步认证过程访问 GitHub API：\n\n1.  **应用认证：** 应用首先使用其私钥签名的 JSON Web Token (JWT) 进行自我认证。此 JWT 仅证明应用的身份，不提供对 GitHub 资源的直接访问。\n2.  **获取安装令牌：** 为了调用 GitHub API，应用需要获取一个安装令牌。安装令牌是使用应用的 JWT 认证生成的、具有作用域（企业、组织或账户）的访问令牌。这些令牌生命周期短（有效一小时），并且只能访问其安装范围内的资源，并使用安装时授予的最大权限。\n\n获取安装令牌有两种方法：使用已知的安装 ID，或通过调用安装 API 来检索 ID。一旦应用获得安装 ID，它就使用该 ID 请求新的令牌。生成的安装令牌继承了应用的权限和该安装的仓库访问权限，也可以选择请求具有更低权限或仅限于特定仓库的令牌。\n\n### 在 Azure Pipelines 中生成安装令牌\n\n管道作者在 Azure Pipelines 中生成安装令牌有三种主要选项：\n\n1.  **使用命令行工具：** 例如，`gh-token` 是一个流行的开源工具，可以处理整个令牌生成过程。\n2.  **编写自定义脚本：** 使用 `bash/curl` 或 PowerShell 脚本实现令牌生成过程，提供完全控制但需要更多实现工作。\n3.  **使用 Azure Pipeline 任务：** 可以从 Azure DevOps 市场寻找合适的任务，或创建自定义任务来实现 GitHub App 认证流。\n\n### 用于 GitHub App 认证的 Azure DevOps 扩展\n\n在 Azure Pipelines 和 GitHub 之间创建集成时，应用私钥的安全性至关重要。在 Azure Pipelines 中，有多种存储敏感数据的选项：\n\n*   Azure Pipeline 秘密存储（通过秘密变量访问）\n*   Azure Pipelines 安全文件\n*   Azure Pipelines 服务连接\n\n**服务连接的优势：**\n\n服务连接为管理外部服务认证提供了多项关键优势，包括：\n\n*   集中式访问控制\n*   支持多种认证方案\n*   可在项目内的多个管道之间共享连接\n*   内置安全控制，用于管理谁可以查看或修改连接详细信息\n*   将敏感凭据对管道作者隐藏，同时仍允许使用\n*   跨多个项目共享连接，减少重复和管理开销\n\n对于 GitHub App 认证，服务连接尤为重要，因为它们可以安全地存储应用的私钥，允许管理员配置和强制连接行为，并提供比直接在管道或变量组中存储秘密更好的安全性。\n\n### 创建自定义 Azure DevOps 扩展\n\nAzure DevOps 扩展是为 Azure DevOps 服务添加新功能的包。本例中，需要创建一个提供两个关键组件的扩展：\n\n1.  **自定义服务连接类型：** 用于安全存储 GitHub App 凭据和其他设置。\n2.  **自定义任务：** 使用这些凭据生成安装令牌。\n\n一个扩展由描述其功能的清单文件和实际实现代码组成。",
      "shortSummary": "本文介绍如何在 Azure Pipelines 中通过自定义 Azure DevOps 扩展简化 GitHub API 调用。核心在于利用 GitHub Apps 进行身份验证，以消除 JWT 生成和令牌管理的复杂性。GitHub Apps 提供细粒度权限、短生命期令牌和更高安全性，是 CI/CD 场景下机器到机器集成的理想选择。该方法通过集中式凭据管理、标准化集成和跨项目重用，增强了安全性、可维护性并节省了时间。",
      "translated_title": "如何在 Azure Pipelines 中简化 GitHub API 调用",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Build a custom Azure DevOps extension that eliminates the complexity of JWT generation and token management, enabling powerful automation and enhanced security controls.</p>\n<p>The post <a href=\"https://github.blog/enterprise-software/ci-cd/how-to-streamline-github-api-calls-in-azure-pipelines/\">How to streamline GitHub API calls in Azure Pipelines</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用 GitHub Models 解决开源 AI 项目的推理问题 (原标题: Solving the inference problem for open source AI projects with GitHub Models)",
      "link": "https://github.blog/ai-and-ml/llms/solving-the-inference-problem-for-open-source-ai-projects-with-github-models/",
      "pubDate": "Wed, 23 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-23T16:00:00.000Z",
      "creator": "Sean Goedecke",
      "summary": "## 使用 GitHub Models 解决开源 AI 项目的推理问题\n\n本文介绍了 GitHub Models，一个旨在解决开源 AI 项目中 AI 推理（inference）难题的免费、兼容 OpenAI 的 API。\n\n### 现有问题与挑战\n在开源项目中集成 AI 功能时，开发者和用户常面临以下障碍：\n*   **付费 API 密钥：** 要求用户提供 OpenAI 或 Anthropic 等付费 API 密钥，对许多业余爱好者和学生来说成本过高，阻碍了项目采用。\n*   **本地模型运行：** 运行大型语言模型（LLM）需要大量内存，普通笔记本电脑或 GitHub Actions runner（14 GB 容器）难以承受。\n*   **模型分发：** 捆绑多 GB 的模型权重会显著增加安装包大小，并拖慢持续集成（CI）流程。\n这些额外的要求都会筛选掉潜在用户和贡献者。\n\n### GitHub Models 解决方案\nGitHub Models 提供了一个免费的、与 OpenAI 兼容的推理 API，每个 GitHub 账户都可以使用，无需新的密钥、控制台或 SDK。\n\n*   **核心功能：**\n    *   一个 REST 端点，遵循 OpenAI 已知的 `chat/completions` 规范。\n    *   提供 GitHub 托管的一系列精选模型，包括 GPT-4o、DeepSeek-R1、Llama 3 等。\n    *   任何拥有 GitHub 个人访问令牌（PAT）的用户，或在仓库中通过权限选择启用的内置 `GITHUB_TOKEN`，都可以调用。\n    *   **成本：** 个人账户和开源组织提供免费层级；付费层级提供更高的吞吐量和更大的上下文窗口。\n*   **兼容性：** 由于 API 镜像了 OpenAI，任何接受 `baseURL` 参数的客户端（如 OpenAI-JS、OpenAI Python、LangChain、llamaccp 或自定义 curl 脚本）都可以无缝使用。\n\n### 如何开始使用 GitHub Models\nGitHub Models 与 OpenAI `chat/completions` API 兼容，因此几乎所有推理 SDK 都能使用。\n\n*   **通过 OpenAI SDK 示例：**\n    ```javascript\n    import OpenAI from \"openai\";\n    const openai = new OpenAI({\n      baseURL: \"https://models.github.ai/inference/chat/completions\",\n      apiKey: process.env.GITHUB_TOKEN // 或任何带有 models:read 权限的 PAT\n    });\n    const res = await openai.chat.completions.create({\n      model: \"openai/gpt-4o\",\n      messages: [{ role: \"user\", content: \"Hi!\" }]\n    });\n    console.log(res.choices[0].message.content);\n    ```\n*   **GitHub Actions 中的零配置 CI：**\n    *   在工作流文件中请求 `models:read` 权限，内置的 `GITHUB_TOKEN` 将自动获得调用 GitHub Models 的权限。\n    *   这使得开发者可以构建一键安装的 AI 驱动型 Actions，例如：\n        *   代码审查或 PR 分类机器人\n        *   智能问题标签工作流\n        *   每周仓库活动报告生成器\n    *   示例 `.github/workflows/triage.yml` 配置：\n        ```yaml\n        permissions:\n          contents: read\n          issues: write\n          models: read # 👈 为 GITHUB_TOKEN 解锁 GitHub Models\n        jobs:\n          triage:\n            runs-on: ubuntu-latest\n            steps:\n              - uses: actions/checkout@v4\n              - name: Smart issue triage\n                run: node scripts/triage.js\n        ```\n\n### 优势与扩展性\n*   **降低门槛：** 任何拥有 GitHub 账户的用户都可以运行 AI 驱动的代码，无需提供付费 API 密钥，极大地降低了用户和贡献者的入门障碍。\n*   **促进贡献：** 更容易的设置意味着更广泛的 GitHub 用户群体可以参与贡献。\n*   **项目扩展：**\n    *   GitHub Models 推理 API 对所有人免费。\n    *   如果需要更高的推理量，用户可以在设置中开启付费使用，以获得显著更大的上下文窗口和更高的每分钟请求数（RPM）。\n    *   付费层级提供更高的 RPM、支持 128k token 的上下文窗口，并在独立部署中运行以降低延迟。\n    *   可在“设置 > 模型”中为组织或企业启用付费使用。\n\n### 总结\nLLM 正在改变软件开发和交付方式，但要求用户提供付费 API 密钥是一个主要障碍。GitHub Models 通过为 GitHub 上的每位开发者提供免费的高质量 AI 推理，消除了开源 AI 采用的最大障碍。这为更多的贡献、更快的上手和更满意的用户打开了大门。\n\n### 相关资源\n*   GitHub Models 文档\n*   API 参考\n\n### 作者\n*   ![Sean Goedecke](https://avatars.githubusercontent.com/u/19204567?v=4&s=200) Sean Goedecke，GitHub 软件工程师，GitHub Models 团队成员。\n\n### 相关文章\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：参加旧金山大会。",
      "shortSummary": "GitHub Models 提供了一个免费、兼容 OpenAI 的推理 API，旨在解决开源 AI 项目中因付费 API 密钥或本地模型部署造成的障碍。它允许任何 GitHub 用户通过 PAT 或 `GITHUB_TOKEN` 访问 GitHub 托管的精选模型，无需额外配置。这降低了用户和贡献者的门槛，尤其在 GitHub Actions 中可实现零配置 AI 功能。项目可根据需求升级到付费层级以获得更高性能。GitHub Models 极大地促进了开源 AI 项目的普及和协作。",
      "translated_title": "使用 GitHub Models 解决开源 AI 项目的推理问题",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/19204567?v=4&s=200",
          "alt": "Sean Goedecke",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>How using GitHub’s free inference API can make your AI-powered open source software more accessible.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/llms/solving-the-inference-problem-for-open-source-ai-projects-with-github-models/\">Solving the inference problem for open source AI projects with GitHub Models</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "我们需要一个欧洲主权技术基金 (原标题: We need a European Sovereign Tech Fund)",
      "link": "https://github.blog/open-source/maintainers/we-need-a-european-sovereign-tech-fund/",
      "pubDate": "Wed, 23 Jul 2025 07:01:00 +0000",
      "isoDate": "2025-07-23T07:01:00.000Z",
      "creator": "Felix Reda",
      "summary": "开源软件（OSS）是全球经济和社会赖以生存的关键数字基础设施，然而其维护工作却长期资金不足，远低于对实体基础设施的投入。为了解决这一问题，GitHub的开发者政策团队委托Open Forum Europe、Fraunhofer ISI和欧洲大学学院进行了一项研究，探讨如何将德国成功的“主权技术局”模式推广至欧盟层面，从而建立一个“欧盟主权技术基金”（EU-STF）。\n\n**开源软件的重要性与维护挑战**\n\n*   **巨大价值：** 开源软件对全球经济的价值估计高达8.8万亿美元，对欧盟经济每年贡献至少650-950亿欧元。基础开源技术广泛应用于经济、社会和公共管理部门。\n*   **普遍存在：** 96%的代码库包含开源软件，77%的代码库由开源软件组成。\n*   **资金不足：** 尽管其价值巨大，但开源维护却严重缺乏资金。对500多名开源维护者的调查显示，三分之一的维护者无偿工作，另有三分之一收入微薄无法维持生计。更令人担忧的是，三分之一的受访者是独立维护者，近四分之三的项目由三人或更少的人维护。这导致了如xz后门和Log4Shell等严重安全事件的发生，凸显了过度依赖小型、过劳且未受重视团队的风险。\n\n**设计一个有影响力的基金**\n\n借鉴德国主权技术局在两年内（2022-2024年）向60个开源项目投资超过2300万欧元的成功经验，欧盟主权技术基金应具备以下五个主要活动领域：\n\n1.  识别欧盟最关键的开源依赖项。\n2.  投资于维护工作。\n3.  投资于安全加固。\n4.  投资于改进和创新。\n5.  加强整个开源生态系统。\n\n**机构设置与资金需求**\n\n研究提出了两种机构设置方案：\n\n*   **“登月计划”模式：** 设立一个集中的欧盟机构。\n*   **“务实”模式：** 由欧盟成员国组成联盟，提供初始资金并申请欧盟预算的额外资源。\n\n无论哪种模式，为确保基金成功，即将到来的欧盟多年期预算（2028-2035年）应至少贡献3.5亿欧元。这笔资金虽不足以完全满足开源维护需求，但可作为杠杆，吸引行业和国家政府的共同出资，从而产生持久影响。\n\n**欧盟主权技术基金的七项设计标准**\n\n借鉴德国主权技术局和美国开放技术基金等项目的经验，研究确定了EU-STF必须满足的七项设计标准：\n\n1.  **集中融资：** 行业、国家政府和欧盟应将资金汇集到同一基金中，以简化维护者的申请流程。例如：\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)\n2.  **低官僚化：** 采用轻量级申请流程，主动识别关键项目，并限制受资助者的报告要求，确保他们能专注于项目改进。\n3.  **政治独立性：** 基金应足够独立，避免受制于区块链、量子计算或人工智能等短期技术趋势，从而专注于保障和维护公共软件基础设施的核心使命。\n4.  **灵活资助：** 能够资助个人、非营利组织或公司进行开源维护工作，且不应限制受资助者的居住地（如德国主权技术局不限制德国人）。关键在于“开源制造”，而非“欧盟制造”。\n5.  **社区聚焦：** 与开源社区合作，共同定义资助优先事项和设计资助流程，以建立专业知识和信任。\n6.  **战略对齐：** 基金需证明其对欧盟战略目标（如经济竞争力、数字主权和网络安全，包括帮助企业遵守《网络弹性法案》下的供应链安全义务）的积极影响。\n7.  **透明度：** 基金在治理和资助决策方面必须达到最高透明度标准，以赢得开源社区和决策者的信任。\n\n**促成欧盟主权技术基金的实现**\n\n目前，欧盟正在就2028-2035年的新多年期预算（多年度财政框架）进行谈判。GitHub的开发者政策团队正在向欧盟立法者介绍这项研究成果，并动员行业合作伙伴（如梅赛德斯-奔驰）支持，以证明建立一个公私部门合作保障开源基础设施的新型工具的必要性。文章呼吁个人、开源组织和公司向欧盟委员会、欧洲议会代表和本国政府表达对EU-STF成立的支持。作者为GitHub开发者政策总监Felix Reda。\n\n![Felix Reda](https://avatars.githubusercontent.com/u/161162366?v=4&s=200)",
      "shortSummary": "开源软件是全球关键数字基础设施，但其维护长期资金不足。为解决此问题，文章呼吁建立一个欧洲主权技术基金（EU-STF），借鉴德国成功经验。该基金旨在识别并资助欧盟最关键的开源依赖项，加强维护、安全和生态系统。提议至少3.5亿欧元的初始资金，并强调集中融资、低官僚化、政治独立和社区合作等设计原则。呼吁各方支持，以确保欧洲数字基础设施的安全与可持续性。",
      "translated_title": "我们需要一个欧洲主权技术基金",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/161162366?v=4&s=200",
          "alt": "Felix Reda",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Open source software is critical infrastructure, but it’s underfunded. With a new feasibility study, GitHub’s developer policy team is building a coalition of policymakers and industry to close the maintenance funding gap.</p>\n<p>The post <a href=\"https://github.blog/open-source/maintainers/we-need-a-european-sovereign-tech-fund/\">We need a European Sovereign Tech Fund</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用AI调试UI：GitHub Copilot代理模式与MCP服务器的结合 (原标题: Debugging UI with AI: GitHub Copilot agent mode meets MCP servers)",
      "link": "https://github.blog/ai-and-ml/github-copilot/debugging-ui-with-ai-github-copilot-agent-mode-meets-mcp-servers/",
      "pubDate": "Tue, 22 Jul 2025 21:58:35 +0000",
      "isoDate": "2025-07-22T21:58:35.000Z",
      "creator": "Chris Reddington",
      "summary": "本文探讨了如何利用GitHub Copilot代理模式和Playwright MCP服务器来加速UI问题的排查与调试，并强调了明确需求的重要性。\n\n### 项目背景与问题\n\n*   **项目：** 作者的OctoArcade Next.js应用，一个GitHub主题的迷你游戏集合。\n*   **发现的问题：**\n    *   导航栏与游戏内容重叠。\n    *   游戏画布与页脚之间存在意外间隙。\n*   **解决方案：** 借助GitHub Copilot代理模式和Playwright MCP服务器进行视觉检查，识别并修复了这些UI问题，包括全局头部修复。\n*   **结果：** 实现了自动化（“hands-off”）调试，解决了之前耗费精力的问题。\n\n### Copilot自定义指令设置\n\n*   **重要性：** 自定义指令文件（如`.github/copilot-instructions.md`）为Copilot提供了关于期望、编码风格和工作实践的重要上下文。\n*   **维护：** 务必保持指令文件最新，包含仓库结构、构建/测试步骤和提交期望等信息。\n*   **更新指令：** 可以通过向Copilot代理模式提问来更新指令文件，例如：“Based on the #codebase, please can you update the custom instructions file for accuracy? Please make sure to keep the structure (i.e. headings etc.) as-is. Thanks!”\n\n### 使用Playwright MCP进行代理式UI调试\n\n*   **Playwright MCP服务器：** 一个强大的端到端测试和UI自动化工具，支持模型上下文协议（MCP）。\n*   **与Copilot集成：** Copilot代理模式和Copilot编码代理可以通过Playwright MCP访问结构化工具。\n*   **Copilot能力：**\n    *   加载网页。\n    *   模拟用户操作（点击、导航）。\n    *   检查渲染布局，无需视觉模型。\n    *   发现布局问题并提出CSS或组件修复建议。\n*   **设置：** 在VS Code的MCP配置中添加Playwright。\n*   **可用工具示例：** `browser_snapshot`（捕获可访问性快照）、`browser_navigate`（导航到URL）、`browser_click`、`browser_type`、`browser_hover`（与元素交互）、`browser_resize`（测试不同视口大小）、`browser_take_screenshot`（视觉文档）。\n\n### 调试过程与经验教训\n\n1.  **描述问题并让代理模式工作：**\n    *   **初始问题：** 页面主内容被导航栏遮挡，游戏页面间距不一致。\n    *   **初始提示：** 尽可能明确地描述UI错误，并要求Copilot使用Playwright进行调查。\n    *   **迭代：** Copilot最初未能加载实际游戏，需要后续提示提供更多上下文。\n    *   **经验：** 提供越多的上下文和具体信息，Copilot的表现越好，就像与团队成员协作一样。\n    *   **Copilot的行动：** 启动浏览器，导航应用页面，诊断问题，并建议改进导航栏的渲染方式（使用根布局的导航栏）。\n    *   **自动化调试：** Copilot尝试修复、重新运行应用并进行视觉检查，甚至迭代修复了linting错误。\n\n2.  **迭代UI需求：**\n    *   **新问题：** OctoPong游戏板与页脚之间存在小间隙。\n    *   **挑战：** 作者最初的需求不明确，导致Copilot的修复引入了新的副作用（如游戏组件消失、游戏超出视口）。\n    *   **关键洞察：** 上下文至关重要，清晰地表达需求是关键。正确定义需求通常需要多次尝试和反馈。\n\n### 实用技巧\n\n*   **保持Copilot自定义指令最新：** 代理依赖这些文件获取仓库上下文和最佳实践。\n*   **利用MCP增强Copilot能力：** Playwright MCP实现真正的端到端测试和UI检查，对调试复杂Web应用至关重要。\n*   **明确需求：** 像任何协作者一样，Copilot只知道你告诉它的信息。列出你的“必须实现”项、预期行为和边缘情况。\n*   **小步迭代：** 频繁提交更改，以便回溯和诊断问题。\n\n### 结论与后续步骤\n\n*   **总结：** 代理工具（如Copilot和Playwright MCP）在提供正确上下文时能显著加速故障排除。描述需求很困难，但迭代、反馈和一些失误都是学习和解决bug过程的一部分。\n*   **行动建议：**\n    *   更新仓库的Copilot自定义指令文件。\n    *   在VS Code中安装并启动Playwright MCP服务器，为Copilot提供浏览器访问权限进行UI测试。\n    *   在Copilot代理模式的新聊天中清晰描述bug或功能。\n    *   让Copilot提出并应用修复，但始终审查代码更改和测试结果。\n    *   根据观察迭代需求，并根据需要进行澄清。\n    *   频繁提交代码，在分支中工作并保存每一步的进度。\n\n文章鼓励读者分享使用Playwright MCP或其他MCP服务器的经验，并关注GitHub的后续直播和学习资源。",
      "shortSummary": "本文探讨了如何利用GitHub Copilot代理模式和Playwright MCP服务器加速UI调试。作者通过修复其OctoArcade应用中的界面问题，展示了这些AI工具如何进行视觉检查和自动修复。核心经验是，向AI工具提供清晰、详细的需求至关重要，调试过程常需迭代细化需求。Playwright MCP赋予Copilot模拟用户交互和检查UI的能力，实现高效的自动化调试。",
      "translated_title": "使用AI调试UI：GitHub Copilot代理模式与MCP服务器的结合",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Explore how I use agentic tools like GitHub Copilot agent mode and the Playwright MCP server to accelerate troubleshooting and debugging of UI issues, while revisiting the importance of clear requirements.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/debugging-ui-with-ai-github-copilot-agent-mode-meets-mcp-servers/\">Debugging UI with AI: GitHub Copilot agent mode meets MCP servers</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-08-07T04:53:43.898Z"
}