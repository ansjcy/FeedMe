{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "GitHub Universe 2025 指南：日程已发布！ (原标题: Your guide to GitHub Universe 2025: The schedule just launched!)",
      "link": "https://github.blog/news-insights/company-news/your-guide-to-github-universe-2025-the-schedule-just-launched/",
      "pubDate": "Wed, 10 Sep 2025 20:52:28 +0000",
      "isoDate": "2025-09-10T20:52:28.000Z",
      "creator": "GitHub Staff",
      "summary": "# GitHub Universe 2025：日程已发布，探索AI驱动的开发未来\n\nGitHub Universe 2025 的完整日程现已发布，活动将涵盖AI驱动开发的无限潜力，包括超过100场精彩的会议、演示和小组讨论。如果您尚未注册，以下是您需要了解的关键信息。\n\n## 活动概览\n\n*   **日期与地点**：活动将于 **10月28日至29日** 在加利福尼亚州旧金山的 **Fort Mason Center** 举行。\n*   **主要亮点**：为期两天的活动将汇聚科技界顶尖人才，包括来自 Red Hat、HubSpot、CVS、General Motors 等公司的专家。今年还设有两个演示舞台，其中一个提供甜甜圈，另一个则有无声迪斯科。\n*   **演讲嘉宾与主题**：会议内容丰富，涵盖从“氛围编程”和大规模自动化到AI驱动的安全等各个方面。\n*   **特别体验**：参会者有机会与 GitHub 团队进行一对一交流，解答疑问，甚至获得职业建议。\n\n## 票务与优惠\n\n*   **早鸟优惠**：早鸟票折扣已延长至 **9月17日（星期三）**，这是节省400美元现场门票的最后机会。\n*   **团体折扣**：购买3张或更多门票可享25%折扣，购买8张或更多门票可享35%折扣。早鸟优惠可与团体折扣叠加使用。\n\n## 日程预览\n\n以下是部分精选会议的概览，您可以在[完整日程](https://github.blog/2024-09-04-your-guide-to-github-universe-2025-the-schedule-just-launched/)中标记您感兴趣的会议，创建个人日程。\n\n### 更快构建，保持流畅\n\n*   ![如何在代码审查中实践同情（而非批评）](https://github.blog/wp-content/uploads/2025/09/table1-1.png?resize=1024%2C538)\n    *   **如何在代码审查中实践同情（而非批评）**\n*   ![使用 Copilot 编码代理解决技术债务](https://github.blog/wp-content/uploads/2025/09/table1-2.png?resize=1024%2C538)\n    *   **使用 Copilot 编码代理解决技术债务**\n*   ![与 GitHub Copilot 合作：更智能地构建游戏](https://github.blog/wp-content/uploads/2025/09/table1-4.png?resize=1024%2C538)\n    *   **与 GitHub Copilot 合作：更智能地构建游戏**\n*   ![使用 Copilot 构建 GitHub：我们的工程师如何倍增影响力并可靠地发布功能](https://github.blog/wp-content/uploads/2025/09/table1-3.png?resize=1024%2C538)\n    *   **使用 Copilot 构建 GitHub：我们的工程师如何倍增影响力并可靠地发布功能**\n\n### 自信地自动化和扩展\n\n*   ![代理的黎明：利用AI驱动工具加速软件开发](https://github.blog/wp-content/uploads/2025/09/table2-1.png?resize=1024%2C538)\n    *   **代理的黎明：利用AI驱动工具加速软件开发**\n*   ![与AI共飞：国泰航空如何转型软件开发](https://github.blog/wp-content/uploads/2025/09/table2-2.png?resize=1024%2C538)\n    *   **与AI共飞：国泰航空如何转型软件开发**\n*   ![从倦怠到突破：构建节省数百万的代理工作流](https://github.blog/wp-content/uploads/2025/09/table-2-4.png?resize=1024%2C538)\n    *   **从倦怠到突破：构建节省数百万的代理工作流**\n*   ![使用 GitHub Actions 自动化日常工作流的5种方法](https://github.blog/wp-content/uploads/2025/09/table-2-3.png?resize=1024%2C538)\n    *   **使用 GitHub Actions 自动化日常工作流的5种方法**\n\n### 确保每次提交的安全\n\n*   ![图片 9](https://github.blog/wp-content/uploads/2025/09/table3-1.png?resize=1024%2C538)\n*   ![图片 10](https://github.blog/wp-content/uploads/2025/09/table3-2.png?resize=1024%2C538)\n*   ![图片 11](https://github.blog/wp-content/uploads/2025/09/table-3-4.png?resize=1024%2C538)\n*   ![图片 12](https://github.blog/wp-content/uploads/2025/09/table3-3.png?resize=1024%2C538)\n\n*   **定制化日程**：除了完整日程，大会还提供针对特定目标、角色（如开发者、金融服务从业者）或行业（如AI时代新趋势）的定制化日程。\n\n## 会前、会中、会后学习机会\n\n### GitHub 总部学习日与认证 (10月30日)\n\n*   **新亮点**：今年新增的 GitHub 总部学习日体验，您的 GitHub Universe 普通门票包含一次 GitHub 或 Microsoft 认证考试。名额有限，先到先得。\n*   **认证考试**：可获得官方 GitHub 或 Microsoft Learn 证书（需提前注册），包括 GitHub Actions、GitHub Administration、GitHub Advanced Security、GitHub Foundations 和 GitHub Copilot 等。此外，还提供 Microsoft DevOps Engineer Expert、Microsoft Azure Administrator Associate 和 Microsoft Azure Developer Associate 认证。如果无法在总部参加考试，可在 Universe 结束后90天内远程参加。\n*   **应用技能实验室**：通过实际、互动挑战测试您的知识。\n*   **总部参观**：难得的机会参观 GitHub 旧金山总部，了解幕后运作。\n*   **社区与庆祝**：享受周边礼品、抽奖活动，并与 GitHub 领导和同行建立联系。\n\n### 一对一会谈\n\n已注册的参会者可报名参加一对一会谈：\n\n*   **职业角 (Career Corner)**：寻求职业建议。\n*   **GitHub 专家中心 (GitHub Expert Center)**：获取其他方面的帮助。\n\n### 现场探索区\n\n会议间隙有丰富的活动：\n\n*   **开源区 (Open Source Zone)**：与贡献者、维护者和社区领袖交流。\n*   **商店 (The Shop)**：购买最新的 Copilot 周边产品。\n*   **休息区 (Recess)**：结识与您有共同非开发兴趣的参会者。\n*   **创客空间 (Makerspace)**：重新构想代码的可能性。\n\n### 学生虚拟微辅导项目\n\n作为社会影响力项目的一部分，GitHub 为在校学生提供与 GitHub 员工进行虚拟微辅导的机会。这些30分钟的一对一会谈将于10月20日至10月31日举行，提供简历反馈、职业建议和技能发展技巧。名额有限，请务必在 **9月19日** 前申请。\n\n## 更多资源\n\n*   了解更多 GitHub Universe 的信息。\n*   使用可定制的电子邮件模板说服您的经理。\n*   查看常见问题解答 (FAQ)。",
      "shortSummary": "GitHub Universe 2025 的日程已发布，活动将于10月28-29日在旧金山举行。大会将聚焦AI驱动的开发，提供超过100场会议，涵盖构建、自动化和安全等主题。参会者可与专家交流，参加GitHub总部学习日及认证考试。早鸟票优惠延长至9月17日，并可叠加团体折扣。此外，还设有学生虚拟微辅导项目。",
      "translated_title": "GitHub Universe 2025 指南：日程已发布！",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table1-1.png?resize=1024%2C538",
          "alt": "How to practice compassion (not criticism) during code reviews",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table1-2.png?resize=1024%2C538",
          "alt": "Tackling your tech debt with Copilot coding agent",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table1-4.png?resize=1024%2C538",
          "alt": "Co-op with GitHub Copilot: Building games the smarter way",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table1-3.png?resize=1024%2C538",
          "alt": "Building GitHub with Copilot: How our engineers multiply their impact and reliably ship features",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table2-1.png?resize=1024%2C538",
          "alt": "Dawn of the agents: Leveraging AI-powered tools to accelerate software development",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table2-2.png?resize=1024%2C538",
          "alt": "Flying high with AI: Cathay Pacific on transforming software development",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table-2-4.png?resize=1024%2C538",
          "alt": "From burnout to breakthrough: Building agentic workflows that save millions",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/table-2-3.png?resize=1024%2C538",
          "alt": "5 ways to automate everyday workflows with GitHub Actions",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Create your own agenda of favorites, sign up for one-on-on mentoring sessions, and register if you haven’t already. We’ll see you there!</p>\n<p>The post <a href=\"https://github.blog/news-insights/company-news/your-guide-to-github-universe-2025-the-schedule-just-launched/\">Your guide to GitHub Universe 2025: The schedule just launched!</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何使用GitHub和JFrog集成实现从代码提交到生产环境的安全可追溯构建 (原标题: How to use the GitHub and JFrog integration for secure, traceable builds from commit to production)",
      "link": "https://github.blog/enterprise-software/devsecops/how-to-use-the-github-and-jfrog-integration-for-secure-traceable-builds-from-commit-to-production/",
      "pubDate": "Tue, 09 Sep 2025 22:00:00 +0000",
      "isoDate": "2025-09-09T22:00:00.000Z",
      "creator": "April Yoho",
      "summary": "## GitHub与JFrog集成：实现从代码提交到生产环境的安全可追溯构建\n\n### 概述\nGitHub与JFrog推出了一项新集成，旨在连接源代码和经证明的二进制文件，创建一个安全、可追溯的统一工作流。此举旨在帮助开发者摆脱在多个工具间切换以追踪构建产物或手动整合安全扫描结果的困境，从而节省时间和精力，将所需的一切集中在一个地方。\n\n### 集成的重要性\n现代软件交付被视为一个供应链，其中源代码、构建管道和生产产物都是重要环节，每个环节都必须安全、可追溯且自动化。任何薄弱环节都可能成为恶意攻击者获取敏感数据的入口。开发者在维护完整供应链安全方面面临诸多挑战，常见痛点包括：\n*   构建离开GitHub后，可追溯性丧失。\n*   安全扫描分散在多个系统，需要手动协调结果。\n*   CI/CD管道感觉是拼凑而非无缝连接。\n\n为解决这些问题，GitHub与JFrog工程师紧密合作，设计了一个工作流，其核心目标是：\n*   将触发构建的代码提交与生成的制品进行加密链接。\n*   自动进行上下文相关的安全扫描，并将漏洞扫描证明（attestations）存储在JFrog Evidence中。\n*   将符合组织策略的制品发布和推广作为GitHub Actions工作流的一部分，而非独立流程。\n\n最终目标是减少摩擦、降低风险，并让开发者有更多时间专注于功能开发，而非管理交接。\n\n### 集成带来的无缝体验\n此次集成解锁了以下无缝体验：\n*   **统一安全扫描**：根据JFrog提供的生产上下文，优先处理Dependabot警报。\n*   **策略驱动的制品推广**：通过基于策略的门控机制发布和推广制品。\n*   **自动证明摄取**：自动将GitHub上创建的所有证明（如来源证明、SBOM、自定义证明）摄取到JFrog Evidence中，并与构建制品关联。\n\n### 工作原理\n该集成通过安全认证和构建元数据，连接GitHub的开发者平台与JFrog的软件供应链平台。其流程如下：\n1.  将代码推送到GitHub。\n2.  使用GitHub Actions进行构建和测试。\n3.  链接提交、构建和制品，实现完整的生命周期可见性。\n4.  自动将制品发布到Artifactory。\n5.  使用GitHub Advanced Security扫描代码，使用JFrog Xray扫描制品。\n\n![GitHub和JFrog集成示意图](https://github.blog/wp-content/uploads/2025/09/jfrog1.png?resize=1024%2C658)\n\n### 设置步骤\n1.  **在JFrog Artifactory中启用GitHub集成**：导航至 `Administration → General Management → Manage Integrations → GitHub`。\n2.  切换“Enable GitHub Actions”并验证您的GitHub组织。\n3.  选择令牌类型，然后创建拉取请求。\n\n![JFrog Artifactory集成界面](https://github.blog/wp-content/uploads/2025/09/jfrog2.jpg?resize=1024%2C576)\n\n### 触发构建并生成证明\n确保您的GitHub Actions工作流使用 `jfrog/jfrog-setup-cli` 和 `actions/attest-build-provenance` 动作。文章提供了一个示例工作流，用于生成证明并将其推送到Artifactory。\n\n### 制品验证与推广\n构建运行并生成证明后，制品将被推送到JFrog Artifactory的暂存仓库。制品此时已准备好进行验证。一旦制品经过验证，确认有效的GitHub签名来源证明与受信任条件（例如发行者、仓库、工作流、分支）匹配，并且策略通过，JFrog可以自动将证明从开发环境推广到生产环境。\n\n![Artifactory中开发环境的证明视图](https://github.blog/wp-content/uploads/2025/09/jfrog3.png?resize=1024%2C310)\n\n### 推广后的安全监控\n制品推广到生产环境后，Dependabot会继续扫描其源仓库，查找依赖项和漏洞。当发现关键CVE时，管理员将收到安全威胁警报。\n\n![关键Dependabot警报视图](https://github.blog/wp-content/uploads/2025/09/jfrog4.jpg?resize=1024%2C692)\n\n为了查找已进入生产环境的制品的警报和漏洞，可以使用标签 `artifact-registry:jfrog-artifactory` 进行过滤。启用此集成后，制品生命周期数据会通过GitHub新的制品元数据API自动从JFrog推送到GitHub。当制品在JFrog Artifactory中推广到生产环境时，JFrog会自动通知GitHub，以便Dependabot使用新的过滤器捕获该制品。\n\n![JFrog的Dependabot过滤器](https://github.blog/wp-content/uploads/2025/09/jfrog5.jpg?resize=1024%2C387)\n\n### 漏洞修复\n一旦识别出警报，可以通过建议的依赖项更新进行修复，然后使用新的来源证明重新构建和重新部署。\n\n### 最佳实践\n为了充分利用GitHub和JFrog Artifactory的集成，建议遵循以下最佳实践：\n*   使用OIDC避免在工作流中使用长期凭据。\n*   在Artifactory中自动化推广流程，将制品从开发环境推向暂存环境再到生产环境。\n*   尽早设置安全门控，确保未经证明或存在漏洞的构建不会进入生产环境。\n*   利用JFrog Evidence中的来源证明实现即时可追溯性。\n\n### 展望\n您可以立即启用GitHub和JFrog集成，开始构建更安全、自动化和可追溯的软件供应链。",
      "shortSummary": "GitHub与JFrog推出新集成，旨在实现从代码提交到生产环境的安全、可追溯构建。该集成将源代码与经证明的二进制文件连接起来，通过统一工作流解决多工具切换、安全扫描碎片化等痛点。它提供统一安全扫描、基于策略的制品推广，并自动将GitHub的证明（如来源、SBOM）导入JFrog Evidence。这简化了CI/CD流程，增强了整个软件供应链的安全性、可追溯性和自动化，帮助开发者专注于功能开发，减少风险。",
      "translated_title": "如何使用GitHub和JFrog集成实现从代码提交到生产环境的安全可追溯构建",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/jfrog1.png?resize=1024%2C658",
          "alt": "Diagram showing the GitHub and JFrog integration.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/jfrog2.jpg?resize=1024%2C576",
          "alt": "JFrog Artifactory integration screen.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/jfrog3.png?resize=1024%2C310",
          "alt": "Artifactory view of the attestation in the dev environment.",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/jfrog4.jpg?resize=1024%2C692",
          "alt": "View of critical Dependabot alerts.",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/jfrog5.jpg?resize=1024%2C387",
          "alt": "Dependabot filter for JFrog.",
          "title": "",
          "position": 5
        },
        {
          "url": "https://avatars.githubusercontent.com/u/26086919?v=4&s=200",
          "alt": "April Yoho",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Connect commits to artifacts without switching tools.</p>\n<p>The post <a href=\"https://github.blog/enterprise-software/devsecops/how-to-use-the-github-and-jfrog-integration-for-secure-traceable-builds-from-commit-to-production/\">How to use the GitHub and JFrog integration for secure, traceable builds from commit to production</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何使用 Playwright MCP 和 GitHub Copilot 调试 Web 应用 (原标题: How to debug a web app with Playwright MCP and GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-to-debug-a-web-app-with-playwright-mcp-and-github-copilot/",
      "pubDate": "Fri, 05 Sep 2025 16:00:00 +0000",
      "isoDate": "2025-09-05T16:00:00.000Z",
      "creator": "Christopher Harrison",
      "summary": "## 如何使用 Playwright MCP 和 GitHub Copilot 调试 Web 应用\n\n### 引言：自动化调试的挑战与解决方案\n\n传统的 bug 报告通常包含复现步骤，但手动验证这些步骤既耗时又繁琐。许多项目缺乏健壮的端到端测试来自动化此过程。本文介绍了一种解决方案：利用 GitHub Copilot 代理模式结合 Playwright 模型上下文协议（MCP）服务器，实现 Web 应用 bug 的自动化复现、追踪和解决。\n\n### Playwright 与 MCP 概述\n\n*   **Playwright**：一个用于 Web 应用的端到端测试框架。它允许开发者创建脚本来模拟用户行为，验证应用程序的功能集，并确保产品质量。例如，在购物应用中，Playwright 可以自动化搜索产品、添加到购物车和完成购买的整个流程。\n*   **MCP (Model Context Protocol)**：由 Anthropic 开发的开放且开源的协议，旨在向 AI 代理暴露工具。这些工具可以提供额外的上下文信息，或允许 AI 代理执行特定操作。\n*   **Playwright MCP 服务器**：将 Playwright 的功能作为工具提供给 AI 代理（如 GitHub Copilot）。这使得 Copilot 能够创建测试脚本并直接执行 Playwright 操作，从而自动化地执行 bug 复现步骤。\n\n### 在 VS Code 中配置 Playwright MCP 服务器\n\n要在 VS Code 中使用 Playwright MCP 服务器，需要进行以下配置：\n\n1.  **安装或配置**：可以在 VS Code 中全局安装 Playwright MCP 服务器，或者在项目的 `.vscode` 文件夹中创建一个名为 `mcp.json` 的文件，并添加以下配置：\n    ```json\n    {\n      \"servers\": {\n        \"playwright\": {\n          \"command\": \"npx",
      "shortSummary": "本文介绍了如何利用 GitHub Copilot 代理模式和 Playwright 模型上下文协议 (MCP) 服务器自动化 Web 应用的 bug 调试。Playwright 作为端到端测试框架，通过 MCP 协议将工具暴露给 AI 代理。开发者可在 VS Code 中配置 Playwright MCP 服务器，然后指示 Copilot 自动执行 bug 复现步骤，确认问题，追踪代码（包括前端、API 调用和后端），并定位错误。Copilot 甚至能在提出修复方案后，利用 Playwright 验证其有效性，显著提升调试效率，让 AI 能够“看到”代码更改对网站的实际影响。",
      "translated_title": "如何使用 Playwright MCP 和 GitHub Copilot 调试 Web 应用",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/image.png?resize=1024%2C816",
          "alt": "A screenshot showing the play button below \"servers\", just above \"playwright\", in a VS Code window.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/6109729?v=4&s=200",
          "alt": "Christopher Harrison",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Reproduce and debug web app issues with ease using the Playwright MCP server and GitHub Copilot.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-to-debug-a-web-app-with-playwright-mcp-and-github-copilot/\">How to debug a web app with Playwright MCP and GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 在新的政府贸易规则下为叙利亚开发者提供更广泛的访问权限 (原标题: GitHub is enabling broader access for developers in Syria following new government trade rules)",
      "link": "https://github.blog/company/github-is-enabling-broader-access-for-developers-in-syria-following-new-government-trade-rules/",
      "pubDate": "Fri, 05 Sep 2025 06:00:00 +0000",
      "isoDate": "2025-09-05T06:00:00.000Z",
      "creator": "Mike Linksvayer",
      "summary": "# GitHub 在新的政府贸易规则下为叙利亚开发者提供更广泛的访问权限\n\n## 引言\nGitHub 宣布，随着对叙利亚的制裁和出口管制放松，将为叙利亚开发者提供更广泛的访问权限。这一举措是 GitHub 长期以来坚持的“所有开发者都应自由使用 GitHub，无论他们身在何处”这一核心立场的又一重要里程碑。\n\n## 主要变化与影响\n*   **服务恢复**：GitHub.com 上的私人和付费功能将再次广泛向叙利亚的开发者开放，覆盖阿勒颇、霍姆斯、大马士革以及全国各地。\n*   **持续可用性**：在此之前，开源项目和其他公共仓库的协作功能一直保持可用，这在 GitHub Innovation Graph（一个提供叙利亚公共仓库贡献汇总数据的开放数据集）中有所体现。\n*   **感谢与欢迎**：GitHub 对那些为促成这一改变而持续发声并寻求更新的开发者表达了诚挚的感谢。GitHub 欢迎叙利亚开发者将他们的项目贡献给全球开发者社区，无论项目大小。\n\n## GitHub 的承诺与具体行动\nGitHub 承诺将继续致力于在法律允许的范围内，让尽可能多的开发者使用其平台。为此，GitHub 正在迅速采取以下措施：\n*   **解除限制**：解除对叙利亚开发者的限制。\n*   **恢复功能**：恢复账户的正常功能。\n*   **提供 Copilot**：提供 GitHub Copilot 的访问权限。\n\n这些更改目前正在进行中，预计将在未来一周内对相关账户生效。\n\n## 作者信息\n本文由开发者政策主管 Mike Linksvayer 撰写。\n\n![Mike Linksvayer](https://secure.gravatar.com/avatar/8cc1e22f2b79ef8eb4c53537d6ba5ac6ae3cf311c9eef3006657ebe8be0551ce?s=200&d=mm&r=g)\n\n## 相关内容\n*   **Docs**：掌握 GitHub 所需的一切，尽在一个地方。\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n*   **GitHub**：在 GitHub 上构建未来，这里是任何地方的任何人都可以构建任何东西的地方。\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n*   **客户案例**：了解使用 GitHub 进行构建的公司和工程团队。\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n*   **GitHub Universe 2025**：最后机会：节省 700 美元购买 Universe 现场通行证，于 10 月 28-29 日在旧金山与我们相聚。\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)",
      "shortSummary": "由于对叙利亚的制裁和出口管制放松，GitHub 正在恢复叙利亚开发者的全面访问权限。这意味着 GitHub.com 上的私人和付费功能将再次广泛可用，包括正常的账户功能和 GitHub Copilot。此前，开源项目协作一直保持开放。GitHub 感谢为这一改变发声的开发者，并重申其致力于在法律允许范围内，让所有开发者自由使用 GitHub 的承诺。相关更改预计将在下周内生效。",
      "translated_title": "GitHub 在新的政府贸易规则下为叙利亚开发者提供更广泛的访问权限",
      "images": [
        {
          "url": "https://secure.gravatar.com/avatar/8cc1e22f2b79ef8eb4c53537d6ba5ac6ae3cf311c9eef3006657ebe8be0551ce?s=200&d=mm&r=g",
          "alt": "Mike Linksvayer",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>With the relaxation of sanctions and export controls on Syria, GitHub will once again be broadly available to Syrian developers.</p>\n<p>The post <a href=\"https://github.blog/company/github-is-enabling-broader-access-for-developers-in-syria-following-new-government-trade-rules/\">GitHub is enabling broader access for developers in Syria following new government trade rules</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "通过MCP启发构建更智能的交互：从笨拙的工具调用到无缝的用户体验 (原标题: Building smarter interactions with MCP elicitation: From clunky tool calls to seamless user experiences)",
      "link": "https://github.blog/ai-and-ml/github-copilot/building-smarter-interactions-with-mcp-elicitation-from-clunky-tool-calls-to-seamless-user-experiences/",
      "pubDate": "Thu, 04 Sep 2025 16:00:00 +0000",
      "isoDate": "2025-09-04T16:00:00.000Z",
      "creator": "Chris Reddington",
      "summary": "## 通过MCP启发构建更智能的交互：从笨拙的工具调用到无缝的用户体验\n\n本文深入探讨了如何利用模型上下文协议（MCP）中的“启发”（Elicitation）机制，显著提升软件的用户体验，特别是针对AI驱动的交互。作者以一个回合制游戏（如井字棋、石头剪刀布）的MCP服务器为例，展示了如何从最初存在诸多“痛点”的交互方式，演变为更加自然和无缝的用户体验。\n\n### 什么是启发（Elicitation）？\n\n启发机制的核心思想是“如果缺少所需信息，就主动去获取”。它超越了简单的信息收集，旨在创建直观的交互：AI（通过MCP服务器）能够在任务执行过程中暂停，主动询问并获取所需信息，然后继续任务，从而避免了依赖硬编码的默认假设。\n\n**注意**：启发功能是MCP规范中的一个相对较新的特性（于2025年6月修订中添加），目前并非所有AI应用宿主都支持（例如，Visual Studio Code中的GitHub Copilot支持此功能）。\n\n### 实施过程中的挑战与改进\n\n作者在回合制游戏MCP服务器中实施启发功能时，遇到了以下挑战并进行了改进：\n\n1.  **初始实现与工具蔓延**：\n    *   最初，作者为新游戏创建（如难度、玩家姓名、先手顺序、游戏轮数）实现了基本的启发功能。\n    *   为了比较新旧方法，启发功能被实现为新的独立工具（例如 `create-tic-tac-toe-game-interactive`），导致服务器中出现大量功能重叠的工具（如 `create-tic-tac-toe-game` 和 `create-tic-tac-toe-game-interactive`）。\n    *   **问题**：AI代理（如Copilot）在面对名称和描述相似的工具时，难以选择正确的工具，导致行为不可预测。\n\n2.  **解决方案：工具整合与DRY原则**：\n    *   通过大量重构和整合，作者将工具数量从八个减少到四个，遵循“不要重复自己”（DRY）原则。\n    *   现在，当用户提示“我们玩一局井字棋”时，工具调用会识别出需要更多信息，从而触发启发机制，确保用户做出明确选择，而非使用预设的默认值。\n\n    ![GitHub Copilot Chat在Visual Studio Code中触发启发体验，请求用户提供额外偏好以自定义体验的截图](https://github.blog/wp-content/uploads/2025/09/image1.png?resize=1024%2C576)\n\n3.  **处理部分信息与实时调试**：\n    *   在直播中发现一个bug：无论用户是否已提供所需信息，启发步骤都会被触发。\n    *   **修复**：直播后，作者添加了检查机制，在工具调用后判断哪些信息已提供，只请求缺失的信息。同时，统一了工具和启发模式之间的属性名称，提高了清晰度。\n    *   例如，如果用户说“我们玩井字棋，我先走”，系统只会询问游戏难度和玩家姓名。\n\n### 启发机制在MCP服务器中的工作原理\n\n当MCP服务器调用 `create_game` 工具时，其内部流程如下：\n\n*   **检查必要参数**：判断用户是否指定了游戏类型或ID。\n*   **传递可选参数**：将已识别的参数传递给独立方法，检查是否缺少难度、玩家姓名或回合顺序等信息。\n*   **启动启发**：如果信息缺失，暂停工具执行，并仅从用户处收集缺失信息（这是直播后添加的改进）。\n*   **呈现模式驱动的提示**：用户会看到针对每个缺失参数格式化的问题。\n*   **收集响应**：MCP客户端（本例中为VS Code）负责处理UI交互。\n*   **完成原始请求**：一旦服务器收集到所有信息，工具将使用用户的偏好执行 `createGame` 方法。\n\n    ![GitHub Copilot Chat在Visual Studio Code中出现新的UI模态框，提示用户选择偏好，本例中用户选择难度为“困难”的截图](https://github.blog/wp-content/uploads/2025/09/image2.png?resize=1024%2C576)\n\n**结果**：用户可以获得个性化的游戏设置，例如“Chris vs AI (Hard)”，并由AI先手，而不是默认的“Player vs AI (Medium)”。\n\n### 关键经验教训\n\n1.  **用户体验至关重要**：启发机制虽然增加了复杂性，但通过主动询问用户偏好，提供了比强制使用默认值更好的体验。\n2.  **工具命名比想象中更重要**：在构建和使用MCP服务器中的工具时，清晰的命名和描述至关重要，模糊的名称会导致AI行为不可预测。\n3.  **迭代开发制胜**：先构建基本功能，在使用中识别痛点，然后通过添加启发等功能来改进用户体验，并利用AI编码代理进行清理。\n\n### 总结\n\n构建更好的AI工具不仅仅关乎底层模型，更在于创造能够解释上下文、提出好问题并准确满足用户需求的体验。启发机制是朝着这个方向迈出的重要一步，预示着MCP生态系统将支持更丰富、更智能的交互。",
      "shortSummary": "本文探讨了如何通过MCP启发（elicitation）机制提升AI交互的用户体验。该机制使AI在信息不足时能主动暂停并向用户请求必要数据，从而避免了僵硬的默认设置和笨拙的工具调用。作者通过一个回合制游戏MCP服务器的开发实践，解决了工具命名混淆和重复请求等问题，实现了工具整合与仅请求缺失信息。文章强调了用户体验、清晰的工具命名和迭代开发的重要性，旨在构建更智能、个性化的AI交互，让用户体验更自然、无缝。",
      "translated_title": "通过MCP启发构建更智能的交互：从笨拙的工具调用到无缝的用户体验",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/image1.png?resize=1024%2C576",
          "alt": "A screenshot of GitHub Copilot Chat in Visual Studio Code where the user has asked \"Let's play a game of tictactoe\". Copilot has triggered the elicitation experience, requesting additional preferences to customize the experience.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/09/image2.png?resize=1024%2C576",
          "alt": "A screenshot of GitHub Copilot Chat in Visual Studio Code where a new UI modal appears, prompting the user for their preferences. This example shows the user selecting the Difficulty as hard.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://avatars.githubusercontent.com/u/791642?v=4&s=200",
          "alt": "Chris Reddington",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 7
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Explore how MCP elicitation transforms AI tool interactions by gathering missing information upfront. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/building-smarter-interactions-with-mcp-elicitation-from-clunky-tool-calls-to-seamless-user-experiences/\">Building smarter interactions with MCP elicitation: From clunky tool calls to seamless user experiences</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "为 Copilot 编写更优自定义指令的 5 个技巧 (原标题: 5 tips for writing better custom instructions for Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/5-tips-for-writing-better-custom-instructions-for-copilot/",
      "pubDate": "Wed, 03 Sep 2025 16:00:00 +0000",
      "isoDate": "2025-09-03T16:00:00.000Z",
      "creator": "Christopher Harrison",
      "summary": "# 为 Copilot 编写更优自定义指令的 5 个技巧\n\n本文旨在提供五个关键技巧，帮助开发者为 GitHub Copilot 编写更有效的自定义指令，从而获得更优质的代码建议。核心理念是，Copilot 就像一位新加入的团队成员，需要充分的上下文信息才能高效工作。`copilot-instructions.md` 文件是 Copilot 聊天或代理请求的中心，用于提供项目背景和团队经验。\n\n作者强调，不必过度追求完美，因为生成式 AI 具有概率性。目标是尽可能地引导 Copilot 找到期望的答案。以下建议并非强制要求，而是基于经验的推荐，旨在显著提高 Copilot 建议的质量。\n\n## 1. 提供项目概览\n\n为 Copilot 提供一个项目的“电梯演讲”至关重要。指令文件的开头应简要说明应用是什么、目标受众以及主要功能。这有助于为 Copilot 设定高层次的项目背景。\n\n*   **示例：Contoso Companions**\n    *   一个支持宠物领养机构的网站。\n    *   机构可以管理地点、可用宠物和宣传活动。\n    *   潜在领养者可以搜索宠物、发现机构并提交领养申请。\n\n## 2. 明确项目使用的技术栈\n\n在明确项目目标后，下一步是详细列出用于构建项目的技术。这包括后端和前端技术、调用的 API 以及目标测试套件。建议使用列表形式突出显示所使用的技术，并可添加关于其使用方式的简短说明，帮助 Copilot 理解代码创建的环境。\n\n*   **示例技术栈：**\n    *   **后端：** Flask (API), Postgres (数据存储), SQLAlchemy (ORM)。开发、预发布和生产环境使用独立数据库。端到端测试会创建、填充并移除新数据库。\n    *   **前端：** Astro (核心站点和路由), Svelte (交互性), TypeScript (所有前端代码)。\n    *   **测试：** Python 使用 Unittest，TypeScript 使用 Vitest，端到端测试使用 Playwright。\n\n## 3. 阐明编码规范\n\n清晰的编码规范指导 Copilot 如何编写代码，例如 JavaScript/TypeScript 是否使用分号、Python 是否使用类型提示、使用制表符还是空格。作者倾向于将规范单独列为一个部分，因为许多规范适用于所有使用的语言，且更具可读性。也可以使用 `.instructions` 文件为特定类型的文件或单元测试提供指导。\n\n*   **专业提示：** “不完美”的指令文件也比什么都没有强得多。指令文件应随时间演进。\n*   **示例项目和代码规范：**\n    *   支持类型提示的语言始终使用类型提示。\n    *   JavaScript/TypeScript 使用分号。\n    *   单元测试和端到端测试是必需的，且在 PR 前必须通过，并应关注核心功能和可访问性。\n    *   始终遵循良好的安全实践和 RESTful API 设计原则。\n    *   可用时使用脚本执行操作。\n\n## 4. 解释项目结构\n\n项目结构多种多样，在自定义指令文件中列出项目结构，不仅可以节省 Copilot 的工作，还能提供关于文件夹内容的更多上下文。\n\n*   **示例项目结构：**\n    *   `server/`：Flask 后端代码\n    *   `models/`：SQLAlchemy ORM 模型\n    *   `routes/`：按资源组织的 API 端点\n    *   `tests/`：API 的单元测试\n    *   `utils/`：实用函数和辅助工具，包括数据库调用\n    *   `client/`：Astro/Svelte 前端代码\n    *   `src/components/`：可重用 Svelte 组件\n    *   `src/layouts/`：Astro 布局模板\n    *   `src/pages/`：Astro 页面和路由\n    *   `src/styles/`：CSS 样式表\n    *   `scripts/`：开发、部署和测试脚本\n    *   `docs/`：项目文档，需始终保持同步\n\n## 5. 指明可用的资源\n\n几乎每个项目都有辅助开发的脚本或资源。在自定义指令文件中提供这些资源的指针，可以提高 Copilot 的准确性和速度。\n\n*   **示例资源：**\n    *   `scripts` 文件夹：`start-app.sh` (安装库并启动应用), `setup-env.sh` (安装库), `test-project.sh` (安装库，运行单元和端到端测试)。\n    *   MCP 服务器：Playwright (用于生成 Playwright 测试或与站点交互), GitHub (用于与仓库和待办事项列表交互)。\n\n## 额外提示：让 GitHub Copilot 帮助你创建自定义指令文件\n\nCopilot 可以帮助你生成初始的 `copilot-instructions.md` 文件。文章提供了一个详细的提示示例，用于指导 Copilot 创建该文件，包括目标、限制、指导和遵循的步骤。使用此提示不仅可以节省时间，还可以帮助你理清项目思路和目标。\n\n## 总结\n\n拥有一个良好的指令文件是提高 Copilot 代码建议质量的重要第一步。`copilot-instructions.md` 文件应被视为任何使用 Copilot 的项目的必需品。从项目概览、技术栈、编码规范、项目结构和可用资源这几个基本部分开始，然后可以进一步探索更具体的 `.instructions` 文件。",
      "shortSummary": "为 GitHub Copilot 编写有效的自定义指令能显著提升代码建议质量。核心在于通过 `copilot-instructions.md` 文件提供清晰的上下文。关键技巧包括：提供项目概览、明确技术栈、阐明编码规范、解释项目结构，以及指明可用资源。这些指导帮助 Copilot 更好地理解项目，生成更准确的代码。即使不完美，一个指令文件也远胜于无。Copilot 甚至可以协助生成这些指令文件。",
      "translated_title": "为 Copilot 编写更优自定义指令的 5 个技巧",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>This guide offers five essential tips for writing effective GitHub Copilot custom instructions, covering project overview, tech stack, coding guidelines, structure, and resources, to help developers get better code suggestions.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/5-tips-for-writing-better-custom-instructions-for-copilot/\">5 tips for writing better custom instructions for Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "AI驱动的规范开发：从新的开源工具包开始 (原标题: Spec-driven development with AI: Get started with a new open source toolkit)",
      "link": "https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/",
      "pubDate": "Tue, 02 Sep 2025 16:48:03 +0000",
      "isoDate": "2025-09-02T16:48:03.000Z",
      "creator": "Den Delimarsky",
      "summary": "## AI驱动的规范开发：从新的开源工具包开始\n\n### 引言：AI编码的挑战与规范的重要性\n当前，AI编码代理日益强大，但普遍存在一个问题：生成的代码看似正确，却往往无法正常工作。这种“凭感觉编码”的方式适用于快速原型，但在构建关键任务应用或处理现有代码库时并不可靠。问题不在于AI的编码能力，而在于我们的方法。我们常常将AI编码代理视为搜索引擎，但它们更像是需要明确指令的、字面意义上的结对程序员。它们擅长模式识别，但仍需要清晰无歧义的指示。\n\n为此，我们正在重新思考规范——不再是静态文档，而是随项目演进的、活的、可执行的工件。规范成为共享的真理来源：当出现不明确之处时，回到规范；当项目变得复杂时，完善规范；当任务过于庞大时，将其分解。\n\n### Spec Kit：AI驱动规范开发的新工具包\nSpec Kit是我们新推出的开源工具包，旨在通过结构化的流程，将规范驱动开发引入您的AI编码工作流，支持GitHub Copilot、Claude Code和Gemini CLI等工具。\n\n### Spec Kit的四阶段规范驱动流程\nSpec Kit将您的规范置于工程流程的中心。其核心洞察在于：每个阶段都有特定的任务，并且只有当前任务得到充分验证后，才能进入下一阶段。您的主要角色是引导，而编码代理则负责大部分的编写工作。该流程分为四个阶段，并设有清晰的检查点：\n\n1.  **规定（Specify）**\n    *   **目标：** 您提供关于要构建什么以及为什么构建的高层描述，编码代理将生成详细的规范。\n    *   **内容：** 关注用户旅程、用户体验以及成功的定义。例如，谁将使用它？它为用户解决了什么问题？他们将如何与它互动？哪些结果是重要的？\n    *   **特点：** 这不是关于技术栈或应用设计，而是关于映射您希望创建的用户体验。它是一个活的工件，会随着您对用户及其需求的了解而演进。\n\n2.  **规划（Plan）**\n    *   **目标：** 您提供所需的技术栈、架构和约束，编码代理将生成全面的技术计划。\n    *   **内容：** 包括公司标准技术、与遗留系统的集成、合规性要求或性能目标等。您可以要求生成多个计划变体进行比较。\n    *   **优势：** 如果将内部文档提供给编码代理，它能将您的架构模式和标准直接整合到计划中，确保AI在开始工作前理解“游戏规则”。\n\n3.  **任务（Tasks）**\n    *   **目标：** 编码代理根据规范和计划，将其分解为实际的工作。\n    *   **内容：** 生成小而可审查的任务块，每个任务解决一个特定的问题。每个任务都应能独立实现和测试，这为AI提供了一种验证工作和保持进度的机制，类似于AI代理的测试驱动开发过程。\n    *   **示例：** 任务不再是“构建身份验证”，而是具体的“创建验证电子邮件格式的用户注册端点”。\n\n4.  **实施（Implement）**\n    *   **目标：** 您的编码代理逐一（或并行）处理任务。\n    *   **开发者角色：** 您作为开发者，审查聚焦于解决特定问题的代码变更，而不是数千行的代码转储。编码代理知道要构建什么（因为规范告诉它），知道如何构建（因为计划告诉它），也知道具体要做什么（因为任务告诉它）。\n    *   **关键：** 您的角色不仅是引导，更是验证。在每个阶段，您都需要反思和完善：规范是否捕捉了您真正想构建的内容？计划是否考虑了实际约束？AI是否遗漏了什么或错过了边缘情况？该流程内置了明确的检查点，供您批判生成的内容、发现差距并在继续前进之前进行纠正。AI生成工件，您确保它们是正确的。\n\n### 为何此方法有效？\n这种方法之所以成功，是因为语言模型的工作原理：它们擅长模式补全，但不擅长“读心术”。像“为我的应用添加照片分享功能”这样模糊的提示，会迫使模型猜测数千个未说明的需求，导致AI做出不准确的假设。相比之下，预先提供清晰的规范、技术计划和聚焦的任务，能为编码代理提供更高的清晰度，从而提高其整体效率。它不再猜测您的需求，而是知道要构建什么、如何构建以及按什么顺序构建。\n\n此方法适用于不同的技术栈（Python、JavaScript、Go等），因为核心挑战都是将意图转化为可工作的代码。规范清晰地捕捉意图，计划将其转化为技术决策，任务将其分解为可实现的部分，而AI编码代理则负责实际编码。\n\n对于大型组织，此方法解决了另一个关键问题：如何管理安全策略、合规规则、设计系统约束和集成需求？这些信息往往分散在各处。通过Spec Kit，所有这些内容都整合到规范和计划中，AI可以实际使用它们。安全要求不再是事后考虑，而是从第一天起就融入规范；设计系统也不再是后期附加，而是指导实施的技术计划的一部分。\n\n这种方法的迭代性赋予了它力量。传统开发可能使您早期决策受限，而规范驱动开发则使改变方向变得简单：只需更新规范，重新生成计划，然后让编码代理处理其余部分。\n\n### 适用场景\n规范驱动开发在以下三种场景中特别有效：\n\n1.  **全新项目（Greenfield，从零到一）：** 在启动新项目时，虽然直接开始编码很诱人，但前期投入少量工作创建规范和计划，能确保AI构建出您真正想要的东西，而非基于常见模式的通用解决方案。\n2.  **现有系统功能开发（Feature work，从N到N+1）：** 这是规范驱动开发最强大的应用场景。在复杂现有代码库中添加功能非常困难。通过为新功能创建规范，可以明确其与现有系统的交互方式。计划随后编码架构约束，确保新代码与项目原生融合，而非附加物。这使得持续开发更快、更安全。\n3.  **遗留系统现代化（Legacy modernization）：** 当需要重建遗留系统时，原始意图往往已随时间流逝。通过Spec Kit提供的规范驱动开发流程，您可以将核心业务逻辑捕获到现代规范中，在计划中设计全新的架构，然后让AI从头开始重建系统，而无需继承技术债务。核心优势在于将稳定的“是什么”与灵活的“如何做”分离，从而实现迭代开发而无需昂贵的重写。\n\n### 未来展望\n我们正在从“代码是真理来源”转向“意图是真理来源”。有了AI，规范成为真理来源，并决定了构建什么。这并非因为文档变得更重要，而是因为AI使规范变得可执行。当您的规范自动转化为可工作的代码时，它就决定了构建什么。Spec Kit是我们使这一转变成为现实的实验。我们将其开源，因为这种方法超越了任何单一工具或公司，真正的创新在于流程。未来我们将探讨如何将规范驱动开发实践与上下文工程相结合，以构建更高级的AI工具。\n\n我们期待听到您的使用体验和改进建议！如果您正在使用规范驱动模式进行开发，请与我们分享您的经验。我们特别关注：\n*   使工作流更具吸引力和可用性。\n*   可能的VS Code集成。\n*   比较和差异化多个实现。\n*   在组织中大规模管理规范和任务。\n\n我们很高兴看到您利用AI找到更好的方法，将人类的创造力转化为可工作的软件。\n\n### 作者信息\n由 ![Den Delimarsky](https://avatars.githubusercontent.com/u/53200638?v=4&s=200) 首席产品经理 Den Delimarsky 撰写。\n\n### 更多来自GitHub的探索\n*   **文档：** ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) 掌握GitHub所需的一切，尽在一个地方。前往文档\n*   **GitHub：** ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) 在GitHub上构建未来，这里是任何人、任何地方构建任何东西的平台。开始构建\n*   **客户案例：** ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) 了解使用GitHub进行构建的公司和工程团队。了解更多\n*   **GitHub Universe 2025：** ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) 最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山与我们相聚。立即注册",
      "shortSummary": "AI编码常因指令模糊而失败。Spec Kit是一个开源工具包，通过将规范作为核心，实现AI驱动的规范开发。它包含“规定、规划、任务、实施”四个阶段，确保AI在明确的意图、技术计划和细化任务指导下生成高质量代码。开发者在每个阶段验证和完善，将“意图”而非“代码”作为真理来源。此方法适用于新项目、功能开发和遗留系统现代化，解决了AI“凭感觉编码”的问题，提高了开发效率和准确性。",
      "translated_title": "AI驱动的规范开发：从新的开源工具包开始",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/53200638?v=4&s=200",
          "alt": "Den Delimarsky",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Developers can use their AI tool of choice for spec-driven development with this open source toolkit.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/spec-driven-development-with-ai-get-started-with-a-new-open-source-toolkit/\">Spec-driven development with AI: Get started with a new open source toolkit</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "揭秘：探索驱动 GitHub Copilot 的 AI 模型 (原标题: Under the hood: Exploring the AI models powering GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/under-the-hood-exploring-the-ai-models-powering-github-copilot/",
      "pubDate": "Fri, 29 Aug 2025 16:14:42 +0000",
      "isoDate": "2025-08-29T16:14:42.000Z",
      "creator": "Alexandra Lietzke",
      "summary": "## 揭秘：探索驱动 GitHub Copilot 的 AI 模型\n\n自2021年首次发布以来，GitHub Copilot 及其背后的 AI 模型经历了显著演进，从单一模型发展为多模型架构，始终以开发者为中心，旨在提升工作效率和流程顺畅度。\n\n### GitHub Copilot 的演进：从 Codex 到多模型架构\n\n*   **早期阶段**：GitHub Copilot 于2021年推出时，由 **Codex**（GPT-3 的衍生模型）提供支持。Codex 在理解和生成代码方面的能力在当时是革命性的，证明了 AI 作为开发者工具的巨大潜力。\n*   **当前发展**：Copilot 已从 Codex 转型，现在默认使用最新的前沿模型，并允许开发者选择多种高级模型。其功能也从最初的 IDE 内自动补全和代码生成，扩展到回答问题、生成测试、调试代码、分配任务、生成拉取请求、协助代码审查、分析代码库，甚至修复安全漏洞等。\n\n### 为何提供多模型？\n\n转向多模型架构不仅是为了跟上 AI 技术的进步，更重要的是为了赋予开发者选择权，让他们可以根据手头的任务选择最适合的 LLM。不同的模型擅长不同的任务，集成多样化的模型使 GitHub Copilot 能够通过以下功能提供更定制化、更强大的体验：\n\n*   **基础智能**：GitHub Copilot 现在默认在聊天、代理模式和代码补全中使用 **GPT-4.1**。该模型针对开发者工作流进行了优化，兼顾速度、推理能力和上下文处理，支持30多种编程语言。\n*   **前沿模型访问**：在 Pro+、Business 和 Enterprise 订阅层级中，开发者可以通过模型选择器访问一系列高级模型，包括：\n    *   **Anthropic**：Claude Sonnet 3.5, Claude Sonnet 3.7, Claude Sonnet 3.7 Thinking, Claude Sonnet 4, Claude Opus 4 (预览), Claude Opus 4.1 (预览)\n    *   **OpenAI**：GPT-4.1, GPT-5 (预览), GPT-5 mini (预览), o3 (预览), o3-mini, o4-mini (预览)\n    *   **Google**：Gemini 2.0 Flash, Gemini 2.5 Pro\n    每个选项在速度、推理深度和多模态能力之间提供不同的权衡。\n\n### 代理工作流中的开发者选择\n\nCopilot 对多模型的支持，赋予了开发者自主选择构建方式的权力，无论是优先考虑速度、精确性还是创造力。这种灵活性使得开发者能够根据个人偏好定制体验，从而转化为实际的生产力提升。Copilot 的代理能力意味着：\n\n*   开发者无需切换编辑器或离开 GitHub，Copilot 作为 GitHub 原生工具，直接在 IDE 和 GitHub 中运行，便于在不中断流程的情况下委派任务。\n*   开发者可以根据自己的偏好工作，无论是通过 Copilot 自动化任务、接受建议修复，还是让编码代理接管。\n*   Copilot 能够全面理解代码库上下文，分析和索引代码，尊重分支保护，并无缝融入现有审查流程。\n*   Copilot 处理繁琐工作，如分类评论、修补漏洞或解决跨代码库的阻塞问题，让开发者专注于核心任务。\n\n### Copilot 如何选择模型\n\nGitHub Copilot 不仅仅是一个单一的 AI 模型，它是一个动态平台，能够智能地将正确的模型与正确的任务匹配。这种灵活性是提供无缝开发者体验的核心，并基于对开发者工作方式、需求和时机的深刻理解。\n\n#### 模型与功能的匹配\n\n每个 Copilot 功能都由一个专门选择的模型提供支持，以满足其独特需求：\n\n*   **代码补全**：现在默认使用 GPT-4.1，针对30多种编程语言的速度、准确性和相关性进行了优化。\n*   **代理模式**：专为更复杂的、多步骤任务设计，利用具有高级推理和规划能力的模型。默认使用 GPT-4.1，但开发者可以根据专业需求选择其他高级模型，如 Anthropic 的 Claude Sonnet 系列、Google 的 Gemini 2.0 Flash 或 OpenAI 的推理模型（o1, o3-mini）。\n*   **Copilot 聊天**：对于关于代码和开发概念的自然语言查询，Copilot 聊天依赖于具有强大语言理解和生成能力的模型。默认运行在 GPT-4.1 上，并可选择 Claude 3.5/3.7 Sonnet、Claude 3.7 Sonnet Thinking、Gemini 2.0 Flash、o1 和 o3-mini 等模型。\n*   **编码代理 (新)**：当开发者委派任务（如分类问题、生成拉取请求或修补漏洞）时，Copilot 编码代理可以作为一个有用的工具，将 Copilot 变成一个可以交接任务的“同事”。\n*   **代码审查 (新)**：代码审查是 GitHub Copilot 功能集的新增部分，由 GPT-4.1 提供支持，因为它在准确性和响应速度之间取得了平衡。对于大型代码库的深度推理，开发者可以选择 Claude 3.7 Sonnet 或 Claude 3.7 Sonnet Thinking 等模型。\n\n#### 针对不同任务选择模型\n\n开发任务的复杂性和上下文各不相同。因此，GitHub Copilot 允许用户选择最适合其需求的模型，尤其是在聊天和代理模式下：\n\n*   **o4-mini (OpenAI)**：速度快，低延迟补全。\n*   **GPT-4.1 (OpenAI)**：平衡性能和多模态支持。\n*   **GPT-5 mini (OpenAI)**：轻量级推理。\n*   **GPT-5 (OpenAI)**：用于复杂任务的高端推理。\n*   **o3 (OpenAI)**：高级规划和多步骤推理。\n*   **Claude Sonnet 3.5**：可靠的日常编码任务。\n*   **Claude Sonnet 3.7**：大型代码库的深度推理。\n*   **Claude Sonnet 3.7 Thinking**：长周期、结构化问题解决。\n*   **Claude Sonnet 4**：更高的推理深度。\n*   **Claude Opus 4**：高级推理能力。\n*   **Claude Opus 4.1**：最先进的 Anthropic 选项。\n*   **Gemini 2.0 Flash (Google)**：快速、多模态能力。\n*   **Gemini 2.5 Pro (Google)**：高级多模态推理。\n\n### 近期升级：全面采用 GPT-4.1\n\nCopilot 聊天、代码补全和拉取请求摘要现在均运行在 OpenAI 的 GPT-4.1 上。此次升级带来了：\n\n*   **更快的响应**：响应生成速度比 GPT-4o 快约40%。\n*   **增加的上下文窗口**：支持比以前默认模型显著更多的上下文。\n\nPro+、Business 和 Enterprise 计划的高级模型访问权限已扩展，包括 Anthropic、Google 和 OpenAI 的广泛强大 AI 选项。新的 Pro+ 层级使个人开发者也能解锁这些高级模型的全部潜力。\n\n### 总结\n\n随着 AI 世界的不断发展，驱动 GitHub Copilot 的模型也将持续演进。GitHub 致力于不断完善和更新其 AI 基础设施，以提供最佳的开发者体验。鼓励开发者探索 Copilot 中可用的不同模型，发现它们如何增强编码旅程。",
      "shortSummary": "GitHub Copilot 已从单一的 Codex 模型演变为多模型架构，目前默认使用 GPT-4.1，并为高级订阅用户提供 Anthropic、OpenAI 和 Google 的多种前沿模型选择。这种多模型策略赋予开发者根据任务需求（如速度、推理深度）进行选择的灵活性。Copilot 的代理能力深度集成到 GitHub 工作流中，能处理复杂任务和重复性工作，显著提升了开发者体验和生产力。近期升级使 Copilot 聊天、代码补全和拉取请求摘要响应速度更快，上下文窗口更大。",
      "translated_title": "揭秘：探索驱动 GitHub Copilot 的 AI 模型",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Learn how GitHub Copilot’s evolving models and infrastructure center developer choice and power agentic workflows.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/under-the-hood-exploring-the-ai-models-powering-github-copilot/\">Under the hood: Exploring the AI models powering GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 模型如何帮助开源维护者专注于重要事项 (原标题: How GitHub Models can help open source maintainers focus on what matters)",
      "link": "https://github.blog/open-source/maintainers/how-github-models-can-help-open-source-maintainers-focus-on-what-matters/",
      "pubDate": "Thu, 28 Aug 2025 19:02:44 +0000",
      "isoDate": "2025-08-28T19:02:44.000Z",
      "creator": "Ashley Wolf",
      "summary": "## GitHub 模型如何帮助开源维护者专注于重要事项\n\n### 引言：开源维护者的挑战与 GitHub Models 的诞生\n\n开源项目的发展离不开维护者的热情与坚持。然而，维护者常常被大量重复性任务所困扰，例如问题分类、审查贡献、管理重复项和手动标记等。这些必要但繁琐的工作占据了他们大量时间，使其无法专注于项目最初吸引他们的核心开发工作。为了解决这一痛点，GitHub 推出了 GitHub Models，旨在利用 AI 自动化这些重复性的项目管理任务，将 AI 直接融入代码和工作流中，从而让维护者能够重新聚焦于项目的核心价值。\n\n### 维护者对 AI 需求调查结果\n\nGitHub 对 500 多名领先开源项目的维护者进行了调查，以了解他们对 AI 的具体需求：\n\n*   **60%** 的维护者希望在问题分类（包括标记、归类和管理流程）方面获得帮助。\n*   **30%** 的维护者需要重复问题检测，即自动查找和链接相似问题。\n*   **10%** 的维护者寻求垃圾信息保护，以过滤低质量的贡献。\n*   **5%** 的维护者需要“低质量拉取请求”（“slop”）检测，以识别那些增加噪音的低质量贡献。\n\n调查还显示，维护者希望 AI 充当“第二双眼睛”，除非明确要求，否则不应主动干预。他们最关注的需求包括问题分类、查找相似问题以及帮助编写最小复现步骤。此外，根据主题或功能对问题进行聚类也被一些维护者认为是至关重要的。\n\n### GitHub Models + GitHub Actions = 持续维护者支持 (Continuous AI)\n\nGitHub 将这种模式称为“持续 AI”，它通过自动化的 AI 工作流来增强协作，其变革性作用类似于 CI/CD 对测试和部署的影响。通过结合 GitHub Models 和 GitHub Actions，维护者可以立即开始应用这一模式。要启用此功能，只需在仓库或组织中启用 GitHub Models，并将提供的 YAML 配置复制到项目的 `.github/workflows` 目录中。在工作流 YAML 中添加 `permissions: models: read` 即可让 Action 使用内置的 `GITHUB_TOKEN` 调用模型，无需特殊设置或外部密钥。\n\n### 核心应用场景与示例\n\n以下是 GitHub Models 结合 GitHub Actions 帮助维护者管理项目的具体示例：\n\n1.  **自动问题去重 (Automatic Issue Deduplication)**\n    *   **问题：** 维护者经常收到多个描述相同 bug 的问题报告。\n    *   **解决方案：** 实现 GitHub Models 工作流，自动检查新问题是否与现有问题相似，并发布包含链接的评论。\n    *   **示例工作流：** 使用 `pelikhan/action-genai-issue-dedup@v0`，可调整标签、检查数量和回溯时间窗。\n\n2.  **问题完整性检查 (Issue Completeness)**\n    *   **问题：** Bug 报告常缺少关键信息，如版本号、复现步骤或预期/实际行为。\n    *   **解决方案：** 自动检测不完整问题，并友好地请求缺失的详细信息。\n    *   **示例工作流：** 使用 `actions/ai-inference@v1` 结合特定提示，机器人会根据分析结果评论请求补充信息。\n\n3.  **垃圾信息和“低质量”内容检测 (Spam and “slop” detection)**\n    *   **问题：** 维护者会收到垃圾拉取请求或低质量的“修复拼写错误”等贡献。\n    *   **解决方案：** 使用 AI 自动标记可疑或低质量的贡献（如“spam”、“ai-generated”、“needs-review”）。\n    *   **示例工作流：** 使用 `actions/ai-inference@v1` 进行检测，然后 `actions/github-script@v7` 根据 AI 判断自动添加标签。\n\n4.  **持续问题解决器 (Continuous Resolver)**\n    *   **问题：** 仓库中积累了数百个开放问题，其中许多可能已解决或过时，手动关闭耗时耗力。\n    *   **解决方案：** 运行一个定期调度的工作流，识别已解决或不再相关的问题和拉取请求，并自动评论或关闭它们。\n    *   **示例工作流：** 使用 `ashleywolf/continuous-ai-resolver@main`，有助于贡献者找到活跃且相关的工作，避免“问题堆积”。\n\n5.  **新贡献者引导 (New contributor onboarding)**\n    *   **问题：** 首次贡献者提交拉取请求时，可能遗漏了 `CONTRIBUTING.md` 中的关键步骤。\n    *   **解决方案：** 发送 AI 生成的友好欢迎消息，其中包含指南链接和有益建议。\n    *   **示例工作流：** 使用 `actions/ai-inference@v1` 生成欢迎消息，然后 `actions/github-script@v7` 发布评论，帮助新贡献者成功融入。\n\n### 最佳实践\n\n*   从小处着手，逐步扩展自动化。\n*   在完全信任自动化之前，让维护者了解其运作情况。\n*   自定义 AI 提示，使其与项目语调和风格保持一致。\n*   持续监控结果并根据需要进行调整。\n*   避免一刀切的自动化、未经审查的更改或任何可能骚扰贡献者的行为。\n\n### 如何开始\n\n如果您准备尝试使用 AI：\n\n1.  在仓库设置中启用 GitHub Models。\n2.  使用 Playground 测试提示和模型。\n3.  将有效的提示保存为 `.prompt.yml` 文件。\n4.  使用上述示例构建您的第一个 Action。\n5.  与社区分享您的经验，共同学习和改进这些工具。\n\n### 相关资源\n\n*   文章作者：Ashley Wolf\n    ![Ashley Wolf](https://avatars.githubusercontent.com/u/10735907?v=4&s=200)\n*   探索更多来自 GitHub 的资源：\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) **文档：** 掌握 GitHub 所需的一切。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) **GitHub：** 在 GitHub 上构建未来。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) **客户案例：** 了解使用 GitHub 的公司和工程团队。\n    *   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) **GitHub Universe 2025：** 注册参加即将举行的活动。",
      "shortSummary": "GitHub Models 利用 AI 自动化开源项目维护中的重复性任务，帮助维护者专注于核心开发。通过与 GitHub Actions 结合，实现“持续 AI”工作流，解决问题分类、重复检测、垃圾信息过滤、问题清理和新贡献者引导等痛点。调查显示，维护者最需要 AI 协助处理问题分类和重复问题。文章提供了具体的工作流示例和最佳实践，旨在提高效率并改善社区体验，让维护者能够更有效地管理项目。",
      "translated_title": "GitHub 模型如何帮助开源维护者专注于重要事项",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/10735907?v=4&s=200",
          "alt": "Ashley Wolf",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how GitHub Models helps open source maintainers automate repetitive tasks like issue triage, duplicate detection, and contributor onboarding — saving hours each week.</p>\n<p>The post <a href=\"https://github.blog/open-source/maintainers/how-github-models-can-help-open-source-maintainers-focus-on-what-matters/\">How GitHub Models can help open source maintainers focus on what matters</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "我们如何使用 Copilot 加速秘密保护工程 (原标题: How we accelerated Secret Protection engineering with Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-we-accelerated-secret-protection-engineering-with-copilot/",
      "pubDate": "Thu, 28 Aug 2025 17:08:51 +0000",
      "isoDate": "2025-08-28T17:08:51.000Z",
      "creator": "Parth Sehgal",
      "summary": "GitHub Secret Protection 旨在帮助开发团队在凭据造成损害之前捕获暴露的凭据。它通过为代码中发现的敏感凭据创建警报来工作，并提供多种功能来进一步缓解泄露：\n\n*   **推送保护**：在泄露发生前阻止包含敏感数据的提交。\n*   **有效性检查**：通过指示哪些秘密是活跃的并需要立即关注来帮助用户分类警报。这是通过针对与令牌提供商关联的非侵入性 API 端点进行测试来计算凭据的有效性。\n*   **合作伙伴计划**：允许提供商收到公共存储库中某些令牌类型泄露的通知。\n*   **Copilot 秘密扫描**：检测通用秘密，如密码或连接字符串。\n*   **自定义模式**：定义用于检测项目或组织特定秘密的表达式。\n\nGitHub 的 Aaron 和 Parth 在有效性检查方面投入了大量工作，该功能于 2023 年发布，最初支持最常见的令牌类型（如 AWS 密钥、GCP 凭据、Slack 令牌），并能验证大约 80% 的新创建警报。然而，对于不那么常见的令牌类型，扩展支持的速度较慢。\n\n### 利用智能代理加速工作流\n\n随着 2024 年底到 2025 年智能 AI 和编码代理的兴起，团队开始探索使用编码代理来弥补这一差距。他们审视了现有添加新令牌类型验证支持的框架驱动工作流：\n\n1.  研究提供商以确定合适的令牌验证端点。\n2.  编写代码（验证器）。\n3.  暗发布（darkship）验证器，观察错误。\n4.  完全发布验证器。\n\n![一个图表展示了研究、编码、暗发布（观察）和发布的框架驱动工作流。根据需要，工作流可以在“暗发布”之后重复“编码”步骤。](https://github.blog/wp-content/uploads/2025/08/validation_copilot_workflow.png?resize=1024%2C294)\n\n编码和发布步骤（第二和第四步）被确定为自动化的首选目标。研究步骤（第一步）仍需人工干预，因为 Copilot 在可靠地找到最不具侵入性的端点、创建和测试实时令牌以及解释细微的 API 变化方面存在困难。\n\n### Copilot 的实施与效果\n\n*   **集成方式**：人工驱动的研究任务的输出被输入到一个手动调度的 GitHub 工作流中，该工作流创建一个详细的问题，可分配给编码代理。该问题作为全面的提示，包含项目背景、API 文档链接和示例。为了解决 Copilot 有时难以遵循链接的问题，还添加了额外的备注字段。\n\n![GitHub Actions“运行工作流”表单的屏幕截图，用于创建新的验证器。表单显示了分支的下拉菜单，以及令牌类型、令牌名称、提供商、文档 URL、端点 URL、验证器的其他备注的文本字段，所有这些都使用来自 Example.com 的 PAT 作为演示的示例输入。](https://github.blog/wp-content/uploads/2025/08/482245106-12fa681b-7c3e-4660-9b12-6a08ce4ade5e.png?resize=1371%2C718)\n\n*   **代理输出**：Copilot 自动生成拉取请求，将研究和规划转化为可操作的代码。这些代码经过自动化测试、人工审查，并最终由工程师部署。\n*   **局限性**：Copilot 并非完美无缺，有时会遗漏细节或未能按预期遵循文档。\n*   **暗发布阶段**：工程师利用暗发布阶段来安全地修复 API 文档与实际行为之间的任何差异。\n*   **成果**：在引入 AI 之前，团队花费数月时间验证了 32 种合作伙伴令牌类型。而通过 Copilot，工程实习生在短短几周内指导 Copilot 增加了近 90 种新类型。Copilot 显著提高了速度和规模，成为一个“倍增器”，能够并行处理多个研究任务的输出。\n\n### 经验与启示\n\n*   **自动化放大可重复性**：对于定义明确的流程，编码代理可以扩展工作并倍增影响力。\n*   **将 Copilot 视为团队成员**：其贡献需要与人类代码相同的仔细审查、测试和反馈。\n*   **提示质量决定结果**：详细、示例丰富的提示（有时需要额外备注）有助于 Copilot 交付高质量的拉取请求。\n*   **迭代优化流程**：提示和工作流需要不断完善和调整。\n*   **并行化是超能力**：通过适当的设置，可以同时分配多项任务，解除原本会排队等待单个工程师处理的工作。\n\n团队认为，在任何存在可重复工程任务的地方，编码代理都具有巨大潜力。他们鼓励其他团队利用可重复性、投资高质量提示，并始终将协作和审查置于核心地位。",
      "shortSummary": "GitHub Secret Protection 旨在防止凭据泄露，其中有效性检查是核心功能。为加速对不常见令牌类型的支持，团队引入了 Copilot 编码代理。通过将 Copilot 整合到验证工作流的编码和发布阶段，团队在数周内增加了近 90 种令牌类型，而此前数月仅增加了 32 种。Copilot 显著提升了效率和规模，但人类的判断、代码审查和高质量的提示仍然至关重要。",
      "translated_title": "我们如何使用 Copilot 加速秘密保护工程",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/validation_copilot_workflow.png?resize=1024%2C294",
          "alt": "A diagram showing the framework-driven workflow of research, code, darkship (observe), and release. As needed, the workflow can repeat the \"code\" step after \"darkship.\"",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/482245106-12fa681b-7c3e-4660-9b12-6a08ce4ade5e.png?resize=1371%2C718",
          "alt": "Screenshot of the GitHub Actions “Run workflow” form to create a new validator. Form shows a dropdown for branch, and text fields for Token Type, Token Name, Provider, Documentation URL, Endpoint URL, Other Notes for Validator all with sample input using a PAT from Example.comas demonstration.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://avatars.githubusercontent.com/u/3690636?v=4&s=200",
          "alt": "Parth Sehgal",
          "title": "",
          "position": 3
        },
        {
          "url": "https://avatars.githubusercontent.com/u/73763104?v=4&s=200",
          "alt": "Aaron Waggener",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how the Secret Protection engineering team collaborated with GitHub Copilot coding agent to expand validity check coverage.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-we-accelerated-secret-protection-engineering-with-copilot/\">How we accelerated Secret Protection engineering with Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-09-11T04:32:48.594Z"
}