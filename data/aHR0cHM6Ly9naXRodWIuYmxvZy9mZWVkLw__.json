{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "AI时代的代码审查：为什么开发者将永远掌握合并按钮 (原标题: Code review in the age of AI: Why developers will always own the merge button)",
      "link": "https://github.blog/ai-and-ml/generative-ai/code-review-in-the-age-of-ai-why-developers-will-always-own-the-merge-button/",
      "pubDate": "Mon, 14 Jul 2025 16:38:03 +0000",
      "isoDate": "2025-07-14T16:38:03.000Z",
      "creator": "Elle Shwer",
      "summary": "## AI时代的开发者与代码审查\n\n在软件开发中，GitHub于2008年推出的拉取请求（PR）通过将纯文本差异与社交工作流（评论、批准和合并按钮）相结合，将问责制融入现代软件开发。即使在大型语言模型（LLM）能够生成代码、提交PR并回复审查评论的今天，GitHub认为最终的合并决定权和代码责任仍属于开发者。AI改变的是合并前的一切，本文探讨了GitHub如何重新思考AI辅助下的代码审查。\n\n### 代码审查的（不变）目的\n\n代码审查远不止是发现错误。一个好的审查能够：\n*   发现缺陷和安全问题\n*   确保高代码质量\n*   在团队间分享知识，并保持与代码库模式和标准的一致性\n*   保障长期可维护性\n\nAI并不能改变这些核心目的，它只是转移了瓶颈。AI可以快速发现未使用的导入，但无法决定新端点是否损害隐私或何时处理复杂的抽象。合并按钮仍然需要（并将永远需要）开发者的“指纹”。\n\n### 从GitHub Copilot代码审查能力中获得的经验\n\nGitHub Copilot代码审查团队通过深入访谈，发现了三个一致的模式：\n*   **对AI无特殊待遇**：审查者对模型生成的差异与对其他开发者生成的差异一样严格。\n*   **自我审查提升了质量**：在提交PR前使用Copilot进行自我审查的开发者，通常能消除一整类琐碎的细节问题（如修剪导入、缺少测试），从而减少了约三分之一的来回沟通。\n*   **AI不能替代人类判断**：编程常涉及权衡，LLM可以提供信息，但最终决策需由人根据组织目标和标准做出。\n\n核心原则是：AI增强开发者的判断力，而非取代它。这些发现正在指导Copilot代码审查功能的构建。\n\n### GitHub Copilot代码审查普遍可用\n\nGitHub Copilot的代码审查代理现已面向所有Copilot计划普遍可用。它能在人类打开差异文件前，发现错误、性能问题，甚至建议修复方案。用户可以在仓库规则中启用自动审查，或在GitHub、GitHub Mobile或VS Code中按需请求Copilot审查。\n\n### AI当前能（和不能）处理什么\n\nLLM在审查的“繁琐”层面表现出色：\n*   **机械扫描**：检查拼写错误、参数使用情况。\n*   **模式匹配**：识别SQL注入、遗漏的await。\n*   **死板的一致性**：变量命名规范（snake_case vs. camelCase）。\n\n未来它们还能理解产品和领域上下文。但它们在以下方面仍有不足：\n*   **架构和权衡**：是否拆分服务？本地缓存？何时偿还技术债务？\n*   **指导**：解释模式的重要性以及何时打破规则。\n*   **价值观**：是否应该构建此功能？\n\n这些差距确保了开发者始终处于核心控制地位。\n\n### 现代代码审查的行动指南\n\n最有效的AI辅助代码审查方法始于提交拉取请求之前，遵循“己所不欲，勿施于人”的黄金法则。\n\n**1. 在IDE中使用AI进行代码自我审查**\n*   在推送代码前，运行GitHub Copilot代码审查，捕获明显问题，让队友专注于需要开发者洞察力的细微问题。\n*   Copilot可以检查暂存的差异，建议文档字符串，并标记空指针解引用。\n*   在提交PR前修复所有发现的问题，减少队友看到的“噪音”。\n\n**2. 对代码负责**\n*   即使代码由AI生成，一旦提交，开发者仍需对其负责。\n*   这意味着理解代码功能，确保其符合团队标准，并与现有代码库良好集成。\n\n**3. 通过自动化CI门禁运行代码**\n*   持续集成（CI）流水线应已运行单元测试、秘密扫描、CodeQL、依赖检查和风格检查器。\n*   实践个人代码卫生小贴士：在IDE中审查自己的代码，确保变量命名、注释和结构符合团队约定，彻底测试AI生成的代码。\n\n**4. 利用AI专注于判断力至关重要的领域**\n*   AI的真正力量在于处理常规工作，让开发者专注于最有价值的判断。\n*   AI不替代现有自动化检查，确保测试通过、覆盖率达标、静态分析工具完成工作。\n*   LLM擅长发现语法问题、模式、潜在错误和风格不一致，尤其擅长发现LLM自身可能犯的错误。\n\n**5. 明确定义角色**\n*   明确AI反馈何时应被考虑，以及何时人类判断优先。\n*   开发者应负责代码架构、业务目标和组织价值观的一致性。\n*   AI特别适用于审查冗长重复的PR，因为这些PR容易遗漏细节。\n\n### 构建可持续AI辅助审查流程的实施建议\n\n*   **文档化明确指南**：规定何时使用AI进行代码审查，信任哪种反馈，以及开发者与AI审查意见不一致时如何升级。例如，GitHub Copilot允许使用自定义指令设置其与代码交互的规则。\n*   **定期更新指南**：根据团队反馈和不断发展的AI能力进行调整。\n*   **鼓励开放团队讨论**：分享AI辅助审查的积极和消极经验，帮助团队学习和改进。\n*   **持续完善自动化**：利用审查者的反馈改进自动化测试策略，识别可自动化的重复问题解决方案。\n\n### 开发者判断力依然至关重要\n\n尽管AI可以处理代码审查中的大部分常规工作，但开发者的判断力在以下方面仍然不可替代：\n*   **架构权衡**：是否拆分服务？本地缓存？何时偿还技术债务？\n*   **指导和文化**：PR线程是团队的课堂，机器人无法讲述复杂代码背后的故事。\n*   **伦理和产品价值观**：“我们是否应该构建这个功能？”是AI无法回答的问题。\n\n目标是让开发者更高效，让他们专注于自己最擅长的领域。",
      "shortSummary": "在AI时代，开发者将始终掌握代码合并的最终决定权。GitHub Copilot等AI工具旨在增强而非取代人类在代码审查中的判断力。AI能处理语法、风格和常见缺陷等重复性任务，从而让开发者专注于架构决策、权衡取舍、知识共享和业务价值等更复杂的方面。通过AI进行自我审查可提高代码质量，减少琐碎修改。最终，代码的责任仍归属于点击“合并”的开发者。",
      "translated_title": "AI时代的代码审查：为什么开发者将永远掌握合并按钮",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>When it comes to merging code, developers will always make the final decision. But we’re rethinking how tools like GitHub Copilot can help. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/code-review-in-the-age-of-ai-why-developers-will-always-own-the-merge-button/\">Code review in the age of AI: Why developers will always own the merge button</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用 CodeQL 建模 CORS 框架以发现安全漏洞 (原标题: Modeling CORS frameworks with CodeQL to find security vulnerabilities)",
      "link": "https://github.blog/security/application-security/modeling-cors-frameworks-with-codeql-to-find-security-vulnerabilities/",
      "pubDate": "Thu, 10 Jul 2025 17:38:14 +0000",
      "isoDate": "2025-07-10T17:38:14.000Z",
      "creator": "Kevin Stubbings",
      "summary": "## 使用 CodeQL 建模 CORS 框架以发现安全漏洞\n\n本文探讨了如何利用 CodeQL 建模 CORS 框架和开发者头部，以提高 CORS 安全覆盖范围并发现潜在漏洞。不安全的 CORS 框架使用或自定义 CORS 实现中的逻辑错误可能导致严重的认证绕过和内网服务访问等安全问题。\n\n### CodeQL 的优势\n\n*   **详细信息获取能力**：CodeQL 等静态分析器能够获取关于结构、函数和导入库的详细信息，使其比 `grep` 等简单工具更具通用性。\n*   **易于发现错误配置**：CORS 框架通常通过特定结构和函数设置配置，CodeQL 是发现代码库中错误配置的有效方式。\n\n### CodeQL 中的头部建模\n\n在向 CodeQL 添加代码时，最佳实践是检查现有查询和框架，避免重复造轮子。CodeQL 通常已为大多数语言提供了覆盖默认情况的 CORS 查询。\n\n1.  **手动设置头部**：最简单的 CORS 实现方式是手动设置 `Access-Control-Allow-Origin` 和 `Access-Control-Allow-Credentials` 响应头部。\n2.  **识别和检查**：通过建模语言框架（如 Django、FastAPI、Flask），CodeQL 可以识别代码中设置这些头部的位置，并检查它们是否匹配易受攻击的值。\n    *   **示例**：Go 语言中将 `Access-Control-Allow-Origin` 设置为 `*`，可能导致未认证资源被任意网站访问。\n    ```go\n    func saveHandler(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n    }\n    ```\n    *   **更严重错误配置**：反射请求源头部并允许凭证，可能导致攻击网站以当前登录用户身份发起请求，从而危及整个 Web 应用程序。\n    ```go\n    func saveHandler(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Access-Control-Allow-Origin\", r.Header.Get(\"Origin\"))\n        w.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n    }\n    ```\n3.  **CodeQL 建模头部写入**：\n    *   `HTTP.qll` 中的 `HeaderWrite` 类用于建模 HTTP 头部写入，其他模块和类可扩展它以查找所有头部写入。\n    *   `AllowCredentialsHeaderWrite` 类扩展 `Http::HeaderWrite`，用于查找 `Access-Control-Allow-Credentials` 设置为 `true` 的所有头部写入。\n    *   通过创建扩展更通用超类的类（如 `HTTP::HeaderWrite`），可以使模型的影响力在所有需要它们的 CodeQL 安全查询中得到利用。\n\n### CodeQL 中的框架建模\n\n许多开发者使用 CORS 框架而非手动设置头部。CORS 框架通常使用 Web 框架中的中间件为每个响应添加头部。\n\n1.  **建模目标**：在 CodeQL 中建模 CORS 框架时，通常是建模表示 CORS 策略的相关结构和方法。\n2.  **验证使用**：一旦建模的结构或方法具有正确的值，查询应检查该结构是否实际在代码库中使用。\n3.  **Go 语言示例 (Gin CORS)**：\n    *   Gin CORS 是一个用于 Gin Web 框架的 CORS 中间件框架。\n    *   **配置示例**：\n    ```go\n    router.Use(cors.New(cors.Config{\n        AllowOrigins: []string{\"https://foo.com\"},\n        AllowMethods: []string{\"PUT\", \"PATCH\"},\n        AllowHeaders: []string{\"Origin\"},\n        ExposeHeaders: []string{\"Content-Length\"},\n        AllowCredentials: true,\n        AllowOriginFunc: func(origin string) bool {\n            return origin == \"https://github.com\"\n        }\n    }))\n    ```\n    *   **建模 `Config` 类型**：使用 `SSAWithFields`（带有字段的单静态赋值）来建模 `Config` 类型，以跟踪包含 CORS 配置结构的变量。\n    *   **建模字段写入**：查找 `AllowOrigins`、`AllowCredentials`、`AllowOriginFunc` 等相关头部字段的所有写入实例。\n    *   `getConfig` 函数用于验证对相关头部的任何写入都影响相同的配置结构。\n    *   通过让来自不同框架的 CORS 相关头部写入都扩展 `UniversalOriginWrite` 和 `UniversalCredentialsWrite`，可以在 CORS 错误配置查询中使用它们。\n\n### 编写 CodeQL CORS 错误配置查询\n\nCORS 问题分为两类：\n\n*   **无凭证**：查找 `*` 或 `null`。\n*   **有凭证**：查找源反射或 `null`。\n\nCodeQL 的 Go 语言查询目前主要关注“带凭证的 CORS”类型，因为它适用于所有应用程序，且通常代表更严重的漏洞。\n\n1.  **查询逻辑**：查询关注关键漏洞，检查是否允许凭证，以及允许的源是来自不受信任的远程源还是硬编码为 `null`。\n2.  **谓词使用**：\n    *   `allowCredentialsIsSetToTrue` 谓词用于检查是否设置了凭证，它使用 `AllowCredentialsHeaderWrite`（针对手动头部）或 `UniversalAllowCredentialsWrite`（针对框架）。\n    *   `flowsFromUntrustedToAllowOrigin` 和 `allowOriginIsNull` 确保最终的头部写入是易受攻击的。\n3.  **避免误报**：查询会检查是否存在字符串比较等防护措施，以防止远程源到达源之前产生误报。\n\n### 额外提示\n\n*   **定制化查询**：CodeQL 查询需要针对每个 Web 框架进行定制，因为每个框架实现 CORS 策略的方式不同，且漏洞模式取决于框架行为。\n*   **示例**：Gin CORS 的 `AllowOriginFunc` 可能覆盖 `AllowOrigins`。可以编写 CodeQL 查询来查找始终返回 `true` 的 `AllowOriginFunc`，如果与凭证结合，这将导致高严重性漏洞。\n\n### 总结\n\n理解 Web 框架和头部与 CodeQL 的行为后，可以轻松发现代码中的安全问题，减少漏洞进入工作的机会。CodeQL 支持 CORS 错误配置查询的语言数量仍在增长，社区仍有改进空间。GitHub Code Security 也能通过检测和建议修复 CORS 错误配置等缺陷来帮助保护项目。",
      "shortSummary": "本文介绍了如何使用 CodeQL 建模 CORS 框架和开发者头部，以发现 Web 应用程序中的安全漏洞。通过 CodeQL 的静态分析能力，可以识别手动设置的易受攻击的 CORS 头部（如 `Access-Control-Allow-Origin: *` 或源反射与凭证结合），以及框架（如 Go 的 Gin CORS）中的错误配置。文章详细阐述了如何在 CodeQL 中建模头部写入和框架结构，并编写针对“带凭证的 CORS”等关键漏洞的查询，帮助开发者和安全研究人员提高代码安全性。",
      "translated_title": "使用 CodeQL 建模 CORS 框架以发现安全漏洞",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Discover how to increase the coverage of your CodeQL CORS security by modeling developer headers and frameworks.</p>\n<p>The post <a href=\"https://github.blog/security/application-security/modeling-cors-frameworks-with-codeql-to-find-security-vulnerabilities/\">Modeling CORS frameworks with CodeQL to find security vulnerabilities</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "超越提示词编写：如何成为你AI结对编程伙伴的更好搭档 (原标题: Beyond prompt crafting: How to be a better partner for your AI pair programmer)",
      "link": "https://github.blog/ai-and-ml/github-copilot/beyond-prompt-crafting-how-to-be-a-better-partner-for-your-ai-pair-programmer/",
      "pubDate": "Wed, 09 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-09T16:00:00.000Z",
      "creator": "Christopher Harrison",
      "summary": "# 超越提示词编写：如何成为你AI结对编程伙伴的更好搭档\n\n本文探讨了如何通过提供更丰富的上下文信息，而非仅仅依赖精心设计的提示词，来提升GitHub Copilot的代码建议质量。\n\n## 上下文是成功的关键\n\n文章通过一个寻找早午餐地点的故事类比，强调了上下文的重要性。就像人类对话一样，AI工具（如Copilot）需要持续的、迭代的上下文信息才能给出符合预期的结果。如果Copilot未能提供预期的建议，很可能是因为它缺乏必要的上下文，就像故事中最初缺乏“想吃华夫饼”这一关键信息一样。\n\n## GitHub Copilot 如何处理代码\n\n理解Copilot的工作方式对于提供有效上下文至关重要：\n\n*   **阅读代码和注释**：Copilot像人类开发者一样“阅读”它被指向的文件中的代码和注释。\n*   **不运行代码**：除了代理模式（agent mode），Copilot在生成代码建议时不会构建或运行代码。\n*   **缺乏“机构知识”**：Copilot不具备人类开发者所拥有的经验背景信息，例如代码的历史原因、内部库的使用规范或必须遵循的模式。\n*   **需要结构化上下文**：如果缺乏这些背景信息，Copilot可能会生成语法正确但与项目特定格式或结构不符的代码（例如，生成原始SQL而非使用数据抽象层）。\n\n## 提升 Copilot 建议质量的方法\n\n文章提出了几种超越提示词编写，为Copilot提供更好上下文的方法：\n\n### 1. 使用代码注释改进上下文\n\n*   **破除误解**：打破“高质量代码不需要注释”的普遍观念。即使代码对一位开发者可读，也可能对所有开发者并非如此。\n*   **提升可读性**：少量注释能大大提高代码可读性，这同样适用于Copilot。\n*   **Copilot 的“阅读”方式**：Copilot通过阅读注释来更好地理解代码的功能和实现方式，从而生成遵循现有模式和实践的高质量建议。\n*   **专业提示**：在打开文件时，养成添加注释的习惯，甚至可以请Copilot生成注释初稿，再进行补充。\n\n### 2. 利用自定义指令文件 (`copilot-instructions.md`)\n\n*   **项目级背景信息**：自定义指令文件用于提供项目层面的背景信息，如使用的技术栈、框架、编码标准以及项目构建的背景。\n*   **文件位置与格式**：将此文件放置在 `.github/copilot-instructions.md`，使用 Markdown 格式，可以创建如“项目结构”、“技术”、“编码标准”等章节。\n*   **全局性应用**：这些指令会随每个聊天请求发送给Copilot，因此应仅限于项目整体相关的信息，避免过于详细，以免干扰Copilot判断重点。\n*   **示例结构**：文章提供了一个单体仓库的示例大纲，包含后端、前端、代码标准和项目结构等部分，指导Copilot理解工作环境。\n\n### 3. 为特定任务提供具体指令 (`.instructions.md`)\n\n*   **任务特定性**：除了项目级指令，还可以创建针对特定任务类型的指令文件（例如，Flask 路由的创建、单元测试的编写）。\n*   **文件位置**：这些文件通常放置在 `.github/instructions/` 目录下。\n*   **链接与模式匹配**：指令文件可以包含指向项目内其他文件（作为示例原型）或其它指令文件的超链接。此外，还可以通过文件模式（如 `applyTo: server/tests/test_*.py`）将指令隐式应用于特定类型的文件。\n*   **长期投资**：构建这些指令文件虽然需要时间，但能带来更高质量的代码和更高的生产力。\n\n### 4. 完全可复用的提示文件 (实验性功能)\n\n*   **脚本化提示**：VS Code团队正在开发一项实验性功能——提示文件（prompt files），允许创建脚本化的Copilot提示。\n*   **可配置性**：可以配置这些提示适用的Copilot模式（ask, edit, agent）、调用的工具以及向开发者提出的问题。\n*   **团队协作**：团队可以创建这些文件以提高提示的复用性和一致性。\n\n### 5. 通过模型上下文协议 (MCP) 扩展 Copilot 能力\n\n*   **开放协议**：MCP（Model Context Protocol）是一个开源协议，允许组织将其服务或数据暴露给生成式AI工具。\n*   **“求助”功能**：将MCP服务器添加到IDE后，Copilot可以“求助”这些服务器来查找信息或执行任务。\n*   **权威来源**：例如，Playwright MCP服务器可以帮助创建端到端测试，GitHub MCP服务器提供对GitHub服务（仓库、问题、拉取请求）的访问。\n*   **自定义 MCP 服务器**：组织可以创建自己的MCP服务器，让Copilot查询内部代码库或库套件，从而根据内部环境提供代码建议。MCP确保了信息的准确性、相关性和时效性。\n\n## 总结\n\n提示词编写固然重要，是开发者使用GitHub Copilot应学习的首要技能。但它只是Copilot生成高质量答案的一部分。通过采纳上述最佳实践——包括良好的代码注释、自定义指令文件以及利用MCP服务器——开发者可以帮助Copilot更好地理解其意图和期望的实现方式，从而确保获得“华夫饼”而非“煎蛋卷”般的代码建议。",
      "shortSummary": "超越提示词编写，为AI结对编程伙伴（如GitHub Copilot）提供丰富上下文至关重要。这包括通过代码注释提升可读性，利用项目级自定义指令（`copilot-instructions.md`）和特定任务指令（`.instructions.md`）提供背景信息和规范。此外，通过模型上下文协议（MCP）可让Copilot访问外部服务或内部知识库，确保其建议准确且符合项目需求。这些方法共同帮助Copilot理解你的真正意图，从而生成更高质量的代码。",
      "translated_title": "超越提示词编写：如何成为你AI结对编程伙伴的更好搭档",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Ensuring quality code suggestions from Copilot goes beyond the perfect prompt. Context is key to success when working with your AI pair programmer.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/beyond-prompt-crafting-how-to-be-a-better-partner-for-your-ai-pair-programmer/\">Beyond prompt crafting: How to be a better partner for your AI pair programmer</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "Git 安全漏洞公告 (原标题: Git security vulnerabilities announced)",
      "link": "https://github.blog/open-source/git/git-security-vulnerabilities-announced-6/",
      "pubDate": "Tue, 08 Jul 2025 17:02:11 +0000",
      "isoDate": "2025-07-08T17:02:11.000Z",
      "creator": "Taylor Blau",
      "summary": "# Git 安全漏洞公告\n\nGit 项目今日发布新版本，旨在解决影响所有先前 Git 版本的七个安全漏洞。\n\n## 漏洞详情\n\n### Git 核心漏洞\n\n*   **CVE-2025-48384 (配置值处理)**\n    *   **问题描述：** Git 在读取配置值时会去除末尾的回车符 (CR) 和换行符 (LF)，但在写入时不会引用末尾的 CR，导致其丢失。当初始化路径包含末尾 CR 的子模块时，会使用被去除 CR 的路径，导致子模块被检出到错误的位置。\n    *   **潜在风险：** 如果被去除 CR 的路径与子模块的 hooks 目录之间存在符号链接，攻击者可通过子模块的 `post-checkout` 钩子执行任意代码。\n    *   **发现者/修复者：** David Leadbeater 发现，Justin Tobler 和 Patrick Steinhardt 修复。\n\n*   **CVE-2025-48385 (克隆时的捆绑包获取)**\n    *   **问题描述：** Git 客户端在克隆时可选地从服务器获取捆绑包。客户端未正确验证广告的捆绑包，允许远程端执行协议注入。\n    *   **潜在风险：** 当广告特制的捆绑包时，远程端可导致客户端将捆绑包写入任意位置，可能导致类似前一个 CVE 的代码执行。\n    *   **发现者/修复者：** David Leadbeater 发现，Patrick Steinhardt 修复。\n\n*   **CVE-2025-48386 (仅限 Windows，凭据助手)**\n    *   **问题描述：** Git 在从经过身份验证的远程克隆时使用凭据助手，其中 Wincred 助手使用静态缓冲区内容作为唯一密钥来存储和检索凭据。但它未正确检查缓冲区剩余空间。\n    *   **潜在风险：** 可能导致缓冲区溢出。\n    *   **发现者/修复者：** David Leadbeater 发现，Taylor Blau 和 Jeff King 共同修复。\n\n### Git GUI 和 Gitk 漏洞\n\n本次发布解决了与 Gitk 和 Git GUI 相关的四个新 CVE。这两个工具都是基于 Tcl/Tk 的图形界面。\n\n*   **CVE-2025-27613 (Gitk，任意文件写入/截断)**\n    *   **问题描述：** 在特制仓库中运行 Gitk 且不带额外命令行参数时，Gitk 可写入和截断任意可写文件。\n    *   **影响范围：** “支持每文件编码”选项必须启用，但“显示此行来源”操作无论如何都会受影响。\n    *   **发现者/修复者：** Avi Halachmi 发现，Johannes Sixt 修复。\n\n*   **CVE-2025-27614 (Gitk，任意脚本执行)**\n    *   **问题描述：** 如果用户被诱骗运行 `gitk filename`（其中 filename 具有特定结构），他们可能运行攻击者提供的任意脚本。\n    *   **潜在风险：** 导致任意代码执行。\n    *   **发现者/修复者：** Avi Halachmi 发现并修复。\n\n*   **CVE-2025-46334 (Git GUI，仅限 Windows，路径查找)**\n    *   **问题描述：** 如果恶意仓库包含可执行文件 `sh.exe` 或常见文本转换程序（如 `astextplain`、`exif` 或 `ps2ascii`），Windows 上的路径查找可能会在工作树中找到这些可执行文件。\n    *   **潜在风险：** 如果用户在此类仓库中运行 Git GUI 并从菜单中选择“Git Bash”或“浏览文件”，这些程序可能被调用，导致任意代码执行。\n    *   **发现者/修复者：** Mark Levedahl 发现并修复。\n\n*   **CVE-2025-46335 (Git GUI，任意文件创建/覆盖)**\n    *   **问题描述：** 当用户被诱骗在不受信任的仓库中编辑特命名目录中的文件时，Git GUI 可创建和覆盖任意可写文件。\n    *   **发现者/修复者：** Johannes Sixt 发现并修复。\n\n## 升级建议与缓解措施\n\n保护自己免受这些漏洞影响的最有效方法是升级到 **Git 2.50.1**，这是包含上述漏洞修复的最新版本。\n\n如果无法立即升级，可以通过以下措施降低风险：\n\n*   避免对不受信任的仓库运行 `git clone --recurse-submodules`。\n*   通过将 `transfer.bundleURI` 配置值设置为“false”来禁用自动获取捆绑包 URI。\n*   在 Windows 上避免使用 `wincred` 凭据助手。\n*   避免在不受信任的仓库中运行 Gitk 和 Git GUI。\n\n## GitHub 的应对措施\n\n为了保护用户免受这些漏洞相关的攻击，GitHub 已采取积极措施：\n\n*   已安排发布 GitHub Desktop 的更新版本。\n*   GitHub Codespaces 和 GitHub Actions 将很快更新其 Git 版本。\n*   GitHub 本身，包括 Enterprise Server，不受这些漏洞影响。\n\n## 作者与相关信息\n\n本文由 GitHub 软件工程师 Taylor Blau 撰写。\n\n![Taylor Blau](https://avatars.githubusercontent.com/u/443245?v=4&s=200)\n\n### 相关文章\n\n*   **Git 2.50 亮点**\n*   **聚焦您的开源项目**\n*   **探索更多来自 GitHub**\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) 客户案例：了解使用 GitHub 进行构建的公司和工程团队。\n*   ![Git Merge 2025](https://github.blog/wp-content/uploads/2025/05/git-merge-24-Orange.svg) Git Merge 2025：在 Git 20 周年之际，探索其影响、演变和未来。",
      "shortSummary": "Git 项目发布新版本，修复了影响所有先前 Git 版本的七个安全漏洞。这些漏洞涵盖 Git 核心（如配置处理、捆绑包获取、Windows凭据助手）以及 Git GUI 和 Gitk 工具（涉及任意文件操作、脚本执行和路径查找）。最有效的防护是升级到 Git 2.50.1。若无法立即升级，建议避免对不受信任的仓库使用特定Git功能，并谨慎运行Git GUI/Gitk。GitHub 已采取措施保护用户，其自身服务不受影响。",
      "translated_title": "Git 安全漏洞公告",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/443245?v=4&s=200",
          "alt": "Taylor Blau",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/05/git-merge-24-Orange.svg",
          "alt": "Git Merge 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Today, the Git project released new versions to address seven security vulnerabilities that affect all prior versions of Git.</p>\n<p>The post <a href=\"https://github.blog/open-source/git/git-security-vulnerabilities-announced-6/\">Git security vulnerabilities announced</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "CVE-2025-53367: DjVuLibre中一个可利用的越界写入漏洞 (原标题: CVE-2025-53367: An exploitable out-of-bounds write in DjVuLibre)",
      "link": "https://github.blog/security/vulnerability-research/cve-2025-53367-an-exploitable-out-of-bounds-write-in-djvulibre/",
      "pubDate": "Thu, 03 Jul 2025 20:52:20 +0000",
      "isoDate": "2025-07-03T20:52:20.000Z",
      "creator": "Kevin Backhouse",
      "summary": "## CVE-2025-53367：DjVuLibre中的越界写入漏洞\n\n### 概述\n\nDjVuLibre 3.5.29 版本已发布，修复了编号为 **CVE-2025-53367 (GHSL-2025-055)** 的越界写入（OOB）漏洞。该漏洞位于 `MMRDecoder::scanruns` 方法中，可能导致用户在 Linux 桌面系统上打开特制文档时，攻击者获得代码执行权限。\n\nDjVu 是一种文档文件格式，功能类似于 PDF，并受许多 Linux 发行版上的默认文档查看器（如 Evince 和 Papers）支持。即使 DjVu 文件被命名为 `.pdf` 扩展名，Evince/Papers 也能自动检测其为 DjVu 文档并调用 DjVuLibre 进行解码。\n\n### 漏洞发现与利用\n\n*   **发现者**：Antonio 在研究 Evince 文档阅读器时通过模糊测试发现了此漏洞。\n*   **概念验证 (POC)**：Kev 已为此漏洞开发了一个概念验证攻击代码。该 POC 可以在完全更新的 Ubuntu 25.04 (x86_64) 系统上运行，并绕过所有标准安全防护（包括 ASLR）。\n*   **攻击演示**：在演示中，Kev 点击了一个恶意 DjVu 文档（文件名为 `poc.pdf`，但实际是 DjVu 格式）。默认文档查看器 `/usr/bin/papers` 加载文档，检测到 DjVu 格式，并使用 DjVuLibre 进行解码。该文件利用越界写入漏洞，触发了 `system(\"google-chrome https://www.youtube.com/…\")` 的调用。\n*   **可靠性**：尽管 POC 能够绕过 ASLR，但其可靠性尚有待提高（有时会连续工作十次，然后突然停止工作几分钟）。研究人员认为可以开发出更可靠的利用方式。\n*   **AppArmor 限制**：POC 触发的是打开 YouTube 视频而非计算器，是因为 `/usr/bin/papers` 在 AppArmor 配置文件下运行。该配置文件禁止启动任意进程，但对 `google-chrome` 做了例外处理。然而，此 AppArmor 配置文件并非特别严格，例如，它允许向用户主目录写入任意文件（除了少数明显的文件如 `~/.bashrc`），因此无法阻止有决心的攻击者获得代码执行。\n\n### 漏洞技术细节\n\n`MMRDecoder::scanruns` 方法受越界写入漏洞影响，因为它未检查 `xr` 指针是否保持在分配缓冲区的边界内。在解码过程中，行程编码数据被写入 `lineruns` 和 `prevruns` 两个缓冲区：\n\n```cpp\n//libdjvu/MMRDecoder.h\nclass DJVUAPI MMRDecoder : public GPEnabled {\n...\npublic:\n  unsigned short *lineruns;\n...\n  unsigned short *prevruns;\n...\n}\n```\n\n变量 `pr` 和 `xr` 指向这些缓冲区中的当前位置。`scanruns` 函数未检查这些指针是否保持在分配缓冲区的边界内：\n\n```cpp\n//libdjvu/MMRDecoder.cpp\nconst unsigned short * MMRDecoder::scanruns(const unsigned short **endptr) {\n...\n  // Swap run buffers\n  unsigned short *pr = lineruns;\n  unsigned short *xr = prevruns;\n  prevruns = pr;\n  lineruns = xr;\n...\n  for(a0=0,rle=0,b1=*pr++;a0 < width;) {\n...\n    *xr = rle; xr++; rle = 0;\n...\n    *xr = rle; xr++; rle = 0;\n...\n    *xr = inc+rle-a0; xr++;\n  }\n```\n\n这可能导致写入超出分配内存的范围，从而引发堆损坏。同样的原因也可能导致 `pr` 发生越界读取。\n\n概念验证攻击代码的源代码将在几周内发布到 GitHub Security Lab 仓库。\n\n### 致谢\n\n感谢 Léon Bottou 和 Bill Riemers 在收到报告后不到两天内迅速响应并发布了修复。\n\n### 时间线\n\n*   **2025-07-01**：通过电子邮件向作者（Léon Bottou, Bill Riemers, Yann LeCun）报告。\n*   **2025-07-01**：收到 Bill Riemers 和 Léon Bottou 的回复。\n*   **2025-07-02**：Léon Bottou 添加了修复提交：[https://sourceforge.net/p/djvu/djvulibre-git/ci/33f645196593d70bd5e37f55b63886c31c82c3da/](https://sourceforge.net/p/djvu/djvulibre-git/ci/33f645196593d70bd5e37f55b63886c31c82c3da/)\n*   **2025-07-03**：DjVuLibre 3.5.29 版本发布：[https://sourceforge.net/p/djvu/www-git/ci/9748b43794440aff40bae066132aa5c22e7fd6a3/](https://sourceforge.net/p/djvu/www-git/ci/9748b43794440aff40bae066132aa5c22e7fd6a3/)\n\n### 研究人员\n\n*   **Kevin Backhouse**\n    ![Kevin Backhouse](https://avatars.githubusercontent.com/u/4358136?v=4&s=200)\n    GitHub 安全实验室团队的安全研究员，通过寻找漏洞并与维护者合作修复，帮助提高开源软件的安全性。\n\n*   **Antonio Morales**\n    ![Antonio Morales](https://avatars.githubusercontent.com/u/55253029?v=4&s=200)",
      "shortSummary": "CVE-2025-53367是DjVuLibre 3.5.29版本中修复的一个越界写入漏洞，位于`MMRDecoder::scanruns`方法。该漏洞允许攻击者通过诱导用户打开特制的DjVu文档，在Linux桌面系统上实现代码执行。由于Evince和Papers等默认文档查看器会调用DjVuLibre处理DjVu文件，用户面临风险。尽管存在ASLR和AppArmor等安全防护，概念验证（POC）攻击已成功演示。该漏洞已迅速得到修复，新版本DjVuLibre 3.5.29已发布。",
      "translated_title": "CVE-2025-53367: DjVuLibre中一个可利用的越界写入漏洞",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/4358136?v=4&s=200",
          "alt": "Kevin Backhouse",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/55253029?v=4&s=200",
          "alt": "Antonio Morales",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>DjVuLibre has a vulnerability that could enable an attacker to gain code execution on a Linux Desktop system when the user tries to open a crafted document.</p>\n<p>The post <a href=\"https://github.blog/security/vulnerability-research/cve-2025-53367-an-exploitable-out-of-bounds-write-in-djvulibre/\">CVE-2025-53367: An exploitable out-of-bounds write in DjVuLibre</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用GitHub Copilot和MCP改进工作流程的5种方法 (原标题: 5 ways to transform your workflow using GitHub Copilot and MCP)",
      "link": "https://github.blog/ai-and-ml/github-copilot/5-ways-to-transform-your-workflow-using-github-copilot-and-mcp/",
      "pubDate": "Wed, 02 Jul 2025 17:44:02 +0000",
      "isoDate": "2025-07-02T17:44:02.000Z",
      "creator": "Klint Finley",
      "summary": "# 使用GitHub Copilot和MCP改进工作流程的5种方法\n\n本文探讨了如何利用模型上下文协议（Model Context Protocol, MCP）与GitHub Copilot结合，以优化开发工作流程。\n\n## MCP简介\n\n传统的AI编码助手通常独立运行，仅限于当前工作区内的代码。随着模型上下文协议（MCP）的引入，AI开发工作流程正在进一步演进，以整合更多工具和上下文。\n\n*   **什么是MCP？** MCP是由Anthropic开发的一个开放标准，旨在帮助GitHub Copilot等AI助手安全地连接到外部数据源和工具。\n*   **解决LLM挑战：** MCP解决了大型语言模型（LLM）在提供正确上下文以生成准确有用响应方面的常见挑战。\n*   **标准化访问：** 它标准化了AI工具访问外部上下文（如代码库、文档或设计规范）的方式，并使其更容易融入开发工作流程。\n*   **核心价值：** MCP的真正价值在于，它使开发者能够直接在集成开发环境（IDE）中执行以前需要多种工具、上下文切换和手动操作的任务，从而节省时间、保持专注并更快地交付代码。\n*   **场景示例：** 本文将通过实现一个安全的JWT（JSON Web Token）认证系统来演示MCP的端到端工作流程。\n\n## 使用MCP转换工作流程的五种方式\n\n### 1. 使用MCP连接设计与开发（Figma）\n\n设计与开发之间的鸿沟一直是产品团队的摩擦点。MCP提供了一种标准化方式，让GitHub Copilot能够安全地直接访问和解释设计规范。\n\n*   **功能：** Copilot能够自动检索精确的设计参数（如颜色、间距、排版和组件状态），并生成准确、即用的代码，从而减少猜测并简化设计师与开发人员之间的交接。\n*   **GitHub Copilot的代理能力：**\n    *   **代理模式（IDE中）：** 将Copilot Chat转变为实时协作伙伴，可规划、编辑文件、运行测试套件、读取失败、修复问题并循环直到成功。\n    *   **编码代理（GitHub项目中）：** 将Issue交给Copilot，它会在受保护的工作区中编写代码、运行检查/测试，并打开拉取请求供审查。\n*   **JWT认证示例：**\n    *   询问Copilot：“登录表单和认证组件的最新设计更新是什么？”它将从Figma检索相关规范。\n    *   然后提示它创建React组件，如`LoginForm`（包含精确的间距、颜色、排版）、`AuthErrorMessage`（包含正确的错误样式）和`TokenRefreshNotification`，Copilot将提供与Figma设计规范一致的即用代码。\n\n### 2. 利用Obsidian知识库（Obsidian）\n\n在实现JWT认证等复杂功能时，通常需要参考分散在知识库中的过往决策、架构笔记和研究成果。非官方的、社区维护的Obsidian MCP服务器通过将GitHub Copilot直接连接到Obsidian笔记库来弥补这一空白。\n\n*   **功能：**\n    *   **搜索与检索：** 告诉Copilot：“搜索所有提及JWT或令牌验证的文件并解释上下文。”Copilot可以搜索笔记库中的所有Markdown文件，检索特定的架构决策记录（ADR）内容，访问以前安全审查的会议记录，并获取团队编码标准中的实现指南。\n    *   **信息综合：** 可以进一步提示：“获取上次关于认证的架构会议记录内容并总结关键决策。”Copilot将定位相关文件并提取关键信息。\n    *   **文档创建：** 收集所需上下文后，可以要求Copilot综合信息：“创建一个名为‘jwt-implementation-summary.md’的新笔记，结合我们的认证标准和新的JWT方法。”Copilot将直接在笔记库中创建此文档。\n*   **设置要求：** 此集成需要社区的“Obsidian Local REST API”插件和API密钥。\n\n### 3. 使用Playwright测试代码（Playwright）\n\n将MCP与Playwright集成，将测试创建从手动、易错的过程转变为简单、引导式的体验。\n\n*   **功能：**\n    *   **生成测试：** 针对JWT认证系统，可以提示Copilot：“测试JWT认证流程，包括登录、自动令牌刷新和受保护路由访问。”Copilot将分析认证实现并生成全面的测试覆盖。\n    *   **运行与反馈：** Copilot随后使用Playwright运行测试，并立即提供失败反馈，为常见问题（如时序问题或选择器更改）提供修复建议。\n\n### 4. 更快地提交拉取请求（GitHub）\n\n拉取请求是协作开发的基础。GitHub的远程MCP服务器（目前在VS Code或Visual Studio中提供公共测试版）有助于将此过程转变为智能、自动化的工作流程。\n\n*   **功能：**\n    *   **PR创建：** 针对JWT认证示例，可以提示Copilot：“为我的认证功能更改创建一个拉取请求。”\n    *   **智能分析：** Copilot将分析跨多个文件的代码更改、相关问题和项目上下文、团队审查模式和专业领域，以及以前类似的实现。\n    *   **建议与推荐：** Copilot会返回包含概述、所做更改、测试策略甚至相关问题的Markdown文本。它还会根据代码所有权、专业映射和当前工作量，为更改的各个方面建议合适的审查者。\n\n### 5. 监控应用程序性能（Grafana）\n\n在处理完核心认证逻辑后，需要通过监控应用程序在生产环境中的行为来确保其性能。使用MCP通过开源的Grafana MCP服务器连接到Grafana，使这一过程变得更容易。\n\n*   **功能：**\n    *   **查询指标：** 告诉Copilot：“显示过去6小时内auth-service仪表板的认证延迟和错误率面板。”在配置Grafana MCP服务器后，Copilot可以查询Grafana实例以检查认证延迟指标、分析登录端点的错误率、审查现有认证服务的警报规则，并识别失败认证尝试中的模式。\n    *   **数据呈现：** Copilot将面板数据作为base64编码的图像返回，并在需要时提取原始时间序列数据。\n    *   **高级操作：** 通过使用`--enable-write`标志和编辑器角色API密钥启动服务器，可以启用写入操作，允许Copilot根据认证指标分析创建新的警报规则或修改仪表板配置。\n\n## 后续步骤与最佳实践\n\n在深入使用这些强大的集成之前，需要配置开发环境：\n\n*   **安装MCP扩展：** 通过官方扩展在IDE中启用MCP支持。\n*   **配置API访问：** 为每个服务（GitHub、Obsidian、Figma等）设置认证。\n*   **定义上下文边界：** 确定AI应可访问哪些信息。\n*   **安全考虑：** 实施适当的访问控制和数据隐私措施。\n\n**一些最佳实践：**\n\n*   **从小处着手：** 从一个集成开始，逐步扩展使用范围。\n*   **维护文档：** 保持知识库和文档的最新状态，以获得最佳AI协助。\n*   **定期审查Copilot的输出：** 定期审计AI生成的建议，以确保质量和安全性。\n*   **建立团队协作：** 确保团队理解并采用一致的MCP使用模式。\n\nMCP生态系统的不断发展将继续扩展其可能性。",
      "shortSummary": "模型上下文协议（MCP）通过连接GitHub Copilot与外部系统，革新了开发工作流程。它使Copilot能直接在IDE中访问Figma设计、Obsidian知识库、Playwright测试、GitHub拉取请求和Grafana监控数据。这五种集成方式显著提升了开发效率、上下文理解和团队协作，帮助开发者更快地交付高质量代码，并简化了从设计到部署的整个流程。",
      "translated_title": "使用GitHub Copilot和MCP改进工作流程的5种方法",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Learn how to streamline your development workflow with five different MCP use cases. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/5-ways-to-transform-your-workflow-using-github-copilot-and-mcp/\">5 ways to transform your workflow using GitHub Copilot and MCP</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "从想法到PR：GitHub Copilot智能代理工作流指南 (原标题: From idea to PR: A guide to GitHub Copilot’s agentic workflows)",
      "link": "https://github.blog/ai-and-ml/github-copilot/from-idea-to-pr-a-guide-to-github-copilots-agentic-workflows/",
      "pubDate": "Tue, 01 Jul 2025 18:57:22 +0000",
      "isoDate": "2025-07-01T18:57:22.000Z",
      "creator": "Chris Reddington",
      "summary": "# GitHub Copilot智能代理工作流指南\n\n本文提供了一份关于GitHub Copilot智能代理工作流的实用指南，旨在帮助开发者将GitHub Issue转化为经过测试的拉取请求（PR），从而减少繁琐的样板代码工作。\n\n## 痛点与解决方案\n\n许多开发者日常工作中，大量时间耗费在样板代码、重构以及为新功能发布做准备的“前期工作”上。GitHub Copilot的智能代理工作流旨在解决这一痛点，通过自动化这些重复性任务，让开发者能专注于更有趣、更具创造性的工作。\n\n文章通过一个实际项目演示了这些工作流：为一个Next.js Web应用和配套的SwiftUI iOS应用添加英语、法语和西班牙语本地化支持。该项目利用了Codespaces和Xcode 16环境，并结合了Copilot的编码代理、自定义规划聊天模式（预览版）和新的远程GitHub MCP服务器。\n\n## 核心能力与工具\n\nGitHub Copilot的智能代理工作流整合了多项关键能力，将从问题到PR的整个流程紧密连接起来，同时确保开发者始终掌控全局：\n\n*   **编码代理 (Coding Agent)**\n    *   **功能：** 将分配给Copilot的任何GitHub Issue异步转化为PR，并执行任务。\n    *   **重要性：** 允许开发者将样板工作卸载给AI，从而专注于代码审查和边缘逻辑。\n    *   **启用与使用：** 需启用Copilot编码代理。\n*   **Copilot创建问题 (Create Issues with Copilot)**\n    *   **功能：** 将自然语言提示转化为结构良好的Issue，包含标题、正文、验收标准和文件提示。\n    *   **重要性：** 节省产品经理/工程师的细化时间，并为团队成员或Copilot编码代理提供有效工作所需的上下文。\n    *   **启用与使用：** 访问github.com/copilot并输入提示来创建Issue。\n*   **自定义聊天模式 (Custom Chat Modes) (VS Code预览版)**\n    *   **功能：** 允许开发者编写可重复的AI工作流脚本（如规划、重构、测试编写），这些模式会出现在默认的“询问/编辑/代理”聊天模式旁边。\n    *   **重要性：** 方便打包指令和相关工具，帮助团队遵循相似的约定。\n    *   **启用与使用：** 在仓库中添加`.chatmode.md`文件；在VS Code 1.101预览版中可用。\n*   **远程GitHub MCP服务器 (Remote GitHub MCP Server)**\n    *   **功能：** 允许AI工具访问实时的GitHub上下文和工具，如Issue、PR和代码文件。无需本地安装，支持OAuth 2.0认证。\n    *   **重要性：** 提供流畅的GitHub MCP服务器访问体验，减少本地服务器的管理开销。\n    *   **启用与使用：** 根据远程GitHub MCP服务器文档更新MCP配置。\n*   **Copilot代理模式 (Copilot Agent Mode)**\n    *   **功能：** 作为实时协作伙伴，驻留在编辑器中，与开发者同步工作并根据需求编辑文件。\n    *   **重要性：** 类似于高级开发者进行结对编程，可访问多种工具（读写代码、运行终端命令、执行MCP服务器工具）。\n    *   **可用性：** 在VS Code、Visual Studio、JetBrains（公开预览）、Eclipse（公开预览）和Xcode（公开预览）中可用。\n\n## 实现类似成果的先决条件\n\n*   一个可推送的GitHub仓库。\n*   已启用编码代理的Copilot订阅（适用于所有付费层级，包括Copilot Business和Copilot Pro）。\n*   VS Code 1.101+及最新Copilot扩展。\n*   GitHub远程MCP服务器或本地GitHub MCP服务器。\n\n## 实战演练：本地化Next.js应用\n\n文章详细演示了将本地化请求转化为PR的流程：\n\n### 1. 将请求转化为GitHub Issue\n\n在Copilot Chat的沉浸式视图中，描述所需功能（例如，添加i11n能力，支持英法西语，用户可在个人资料页更改语言并即时生效，并包含概述、验收标准和文件提示）。Copilot会起草一个Issue，包含标题、验收标准和初步行动计划。随后，可将该Issue分配给Copilot，让其在后台处理。\n\n### 2. 编码代理将Issue转化为PR\n\n分配任务后，编码代理会：\n*   创建分支。\n*   启动新会话（若配置了`copilot-setup-steps.yml`，则会先配置开发环境）。\n*   审查任务，探索代码库现状，并制定完成任务的计划（会考虑自定义指令，如`npm run lint`和`npm run test`需通过）。\n*   完成后，会打开一个草稿PR供审查。\n\n### 3. 像往常一样审查PR\n\n无论是同事、协作者还是Copilot编写的代码，都需要审查。\n*   仔细审查PR正文和“文件更改”标签页中的代码。\n*   查看编码代理会话，了解Copilot解决问题的方法。\n*   可在GitHub Codespace中手动测试代码，或运行GitHub Actions工作流中的CI检查。\n*   如果发现问题（如硬编码字符串），可像处理任何其他PR一样，在评论中提供反馈。Copilot会响应评论并继续工作。\n\n## 通过自定义聊天模式提升工作流\n\nVS Code 1.101预览版中新增的自定义聊天模式允许开发者打包指令和相关工具，以实现更便捷的使用。例如，可以基于VS Code团队的“规划”聊天模式示例进行扩展，添加`create_issue`工具，并调整指令以在用户批准后创建GitHub Issue。这有助于团队保持一致且便捷的聊天模式配置。\n\n## 远程MCP：简化本地设置\n\n远程MCP服务器减少了在本地运行这些工具（如通过npm包或Docker容器）的管理开销。GitHub远程MCP服务器还支持OAuth 2.0认证，而非个人访问令牌。使用时需更新MCP配置。值得一提的是，GitHub MCP服务器是开源的。\n\n## 移动开发：Xcode中的Copilot代理模式\n\n文章简要提及了在Xcode中使用Copilot代理模式的案例，例如通过类似提示为应用添加国际化功能，并在模拟器中看到效果。\n\n## 使用建议：应该做和不应该做\n\n*   **✅ 应该做：**\n    *   保持Issue范围紧凑。\n    *   提供明确的验收标准。\n    *   仔细审查所做的更改。\n    *   与Copilot迭代，不要期望一次性完美。\n*   **❌ 不应该做：**\n    *   要求代理“重新架构整个应用”。\n    *   假设代理了解你的意图。\n    *   未经审查就执行代码或合并PR。\n    *   期望第一次就完美。\n\n## 总结与展望\n\nGitHub Copilot的智能代理工作流并非魔法，而是强大的工具。它们能帮助开发者减少技术债务和重复性任务，让开发者能够专注于解决更具挑战性、更有趣和更具创造性的问题。",
      "shortSummary": "GitHub Copilot的智能代理工作流旨在简化软件开发，将想法快速转化为经过测试的拉取请求。它通过编码代理、自定义聊天模式和远程MCP服务器，自动化了创建问题、编写样板代码和初步测试等繁琐任务。开发者仍能掌控审查和合并过程，从而将精力集中在核心功能开发和创新上，显著提升效率并减少重复劳动。",
      "translated_title": "从想法到PR：GitHub Copilot智能代理工作流指南",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>A practical guide to GitHub Copilot’s agentic coding agent, chat modes, and remote MCP server so you turn issues into tested PRs with clear steps (and no hype).</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/from-idea-to-pr-a-guide-to-github-copilots-agentic-workflows/\">From idea to PR: A guide to GitHub Copilot’s agentic workflows</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用GitHub的依赖图了解您的软件供应链 (原标题: Understand your software’s supply chain with GitHub’s dependency graph)",
      "link": "https://github.blog/security/supply-chain-security/understand-your-softwares-supply-chain-with-githubs-dependency-graph/",
      "pubDate": "Tue, 01 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-01T16:00:00.000Z",
      "creator": "Andrea Griffiths",
      "summary": "# GitHub依赖图：理解您的软件供应链\n\nGitHub的依赖图提供了一种强大的方式，帮助开发者全面了解其软件项目的外部包依赖关系，无论是直接还是间接的。这使得用户能够更好地理解、保护和管理其代码库的真实构成，尤其是在现代软件项目中，大部分代码可能来源于外部依赖。\n\n## 什么是依赖图？\n\n现代软件项目就像一座冰山。表面上，一个小的清单文件可能只列出少量直接依赖项，但其下方隐藏着一个庞大而复杂的传递性依赖世界，这通常是开发者容易忽视的部分。GitHub依赖图的作用正是映射出这个“水下世界”。\n\n*   **可视化表示**：它将每个包视为一个节点，每个依赖关系视为一条边，从而生成一个完整、可视化且结构化的软件外部代码库表示。\n*   **代码构成**：在许多情况下，一个项目高达95%至97%的代码实际上可能来自第三方。依赖图帮助开发者理解并管理这一现实。\n\n## 为什么依赖图至关重要？\n\n当开源包中发现漏洞时，其影响会向下游项目扩散。如果项目不清楚自身包含某个易受攻击的依赖项，就很难及时采取行动。\n\n*   **安全基础**：依赖图不仅仅是一个可视化工具，它更是GitHub Dependabot警报的基础。\n*   **漏洞通知**：当任何依赖项（包括传递性依赖）中发现安全问题时，GitHub会通过Dependabot通知用户。\n*   **全面洞察**：用户可以获得关于供应链中包含哪些内容、它们是如何进入项目以及可以采取哪些措施的完整视图。\n\n## 实际应用示例：从21到1,000个依赖项\n\n一个项目可能只有21个直接依赖项（在`package.json`等文件中列出），但包含所有传递性依赖后，总数可能达到1,000个。通过依赖图，您可以：\n\n*   **区分依赖类型**：清晰地区分直接依赖和传递性依赖。\n*   **追溯来源**：追踪像Log4j这样的包是如何进入您的代码库的（通常是作为其他依赖的传递依赖）。\n*   **明确责任**：了解哪些是您需要修复的，哪些是上游维护者负责的。\n\n## 通过Dependabot强化供应链安全\n\nDependabot基于依赖图运行。启用依赖图是实现Dependabot漏洞警报和自动修复建议的前提。\n\n*   **专业提示**：建议首先关注直接依赖项。这些是您可以直接控制的，将精力集中在此处比为传递性依赖项烦恼更有效。\n\n## 如何启用依赖图？\n\n您可以在仓库设置中，通过“Security > Dependency Graph”路径启用依赖图。如果启用了Dependabot，依赖图将自动启用。\n\n*   **GitHub Actions支持**：对于不支持自动发现的语言生态系统，社区维护的GitHub Actions可以生成软件物料清单（SBOM）并将其提交到GitHub的依赖提交API。\n\n## 免费提供\n\n依赖图和Dependabot警报对所有GitHub仓库都是免费的。\n\n## 总结\n\n您无法保护您看不到的东西。GitHub的依赖图提供了对代码库中90%以上来自开源库部分的可见性，并帮助您在关键时刻采取行动。\n\n*   立即启用它。\n*   与Dependabot结合使用，实现自动化警报和修复。\n*   最终发现您的软件供应链中究竟包含什么。\n\n您的未来（以及您的安全团队）会感谢您。\n\n## 了解更多\n\n*   探索GitHub依赖图文档：[Explore the documentation](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph)\n\n---\n\n**作者信息**\n\n![Andrea Griffiths](https://github.blog/wp-content/uploads/2025/03/cropped-IMG_1971-200x200.jpeg)\n\n本文由 **Andrea Griffiths** 撰写，她是GitHub的高级开发者倡导者，拥有十多年的开发者工具经验。她将深厚的技术知识与使先进技术更易于访问的使命相结合。在从军队服役和施工管理转型到软件开发后，她带来了独特的视角，弥合了复杂的工程概念与实际实现之间的鸿沟。她与她的威尔士伴侣、两个儿子和两只狗住在佛罗里达州，在那里她继续通过GitHub的全球倡议推动创新和支持开源。您可以在线找到她：@alacolombiadev。\n\n---\n\n**相关文章**\n\n探索更多来自GitHub的内容：\n\n*   **文档**\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n    掌握GitHub所需的一切，尽在一个地方。\n    [前往文档](https://docs.github.com/en)\n\n*   **GitHub**\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n    在GitHub上构建未来，这里是任何人、任何地方都可以构建任何东西的地方。\n    [开始构建](https://github.com/)\n\n*   **客户案例**\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n    了解使用GitHub进行构建的公司和工程团队。\n    [了解更多](https://github.com/customer-stories)\n\n*   **GitHub Universe 2025**\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)\n    最后机会：节省700美元购买Universe现场通行证，并于10月28-29日在旧金山与我们相聚。\n    [立即注册](https://githubuniverse.com/)",
      "shortSummary": "GitHub的依赖图提供软件供应链的全面视图，揭示直接和间接依赖。它帮助用户理解、保护和管理项目，尤其是在识别和响应开源漏洞方面。依赖图是Dependabot警报的基础，能自动检测并建议修复安全问题。该功能免费，可通过仓库设置启用，显著提升代码库的可见性和安全性，让开发者更好地掌控其外部代码构成。",
      "translated_title": "使用GitHub的依赖图了解您的软件供应链",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/03/cropped-IMG_1971-200x200.jpeg",
          "alt": "Andrea Griffiths",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>The GitHub dependency graph maps every direct and transitive dependency in your project, so you can identify risks, prioritize fixes, and keep your code secure.</p>\n<p>The post <a href=\"https://github.blog/security/supply-chain-security/understand-your-softwares-supply-chain-with-githubs-dependency-graph/\">Understand your software’s supply chain with GitHub’s dependency graph</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 咨询数据库数据概览：已知安全漏洞及其应对措施 (原标题: GitHub Advisory Database by the numbers: Known security vulnerabilities and what you can do about them)",
      "link": "https://github.blog/security/github-advisory-database-by-the-numbers-known-security-vulnerabilities-and-what-you-can-do-about-them/",
      "pubDate": "Fri, 27 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-27T16:00:00.000Z",
      "creator": "Jonathan Evans",
      "summary": "GitHub 咨询数据库（Advisory DB）是开发者获取开源软件包已知安全漏洞和恶意软件信息的重要资源。本文分析了 2024 年咨询数据库的趋势，包括已审查咨询的增长、生态系统覆盖范围的扩大以及来源贡献的增加，并阐述了 GitHub 如何提供可操作的数据来保护软件项目。\n\n## 咨询数据库分类\nGitHub 咨询数据库中的已知安全漏洞和恶意软件分为三类：\n\n*   **GitHub 已审查咨询**：由 GitHub 手动审查的软件包咨询，确保其有效性、完整描述以及包含生态系统和软件包信息。每年，GitHub 发布的已审查咨询数量都在增加，这得益于来源的增加、生态系统覆盖范围的扩大以及对数据库建立前发布的咨询进行的审查活动。\n    *   2019 年新增 385 条已审查咨询，到 2024 年增至 5256 条。\n    *   在过去五年中，数据库中的已审查咨询总数从 2019 年的不足 400 条增长到 2024 年 10 月的 20,000 多条。\n    ![每年新增的已审查咨询数量条形图。图表显示从 2019 年的 385 条开始，数量随时间增加，到 2024 年达到 5256 条。](https://github.blog/wp-content/uploads/2025/06/advisory1.png?resize=1024%2C633)\n    ![已审查咨询总数折线图。图表显示从 2019 年的 0 条稳步增长到 2024 年底的 20607 条。](https://github.blog/wp-content/uploads/2025/06/advisory2.png?resize=1024%2C601)\n\n*   **未审查咨询**：这些咨询自动从国家漏洞数据库（NVD）导入。尽管其中许多已被 GitHub 分析师审查，但由于它们不属于受支持的软件包或不构成有效漏洞，因此归入此类别。GitHub 仍发布它们，以避免用户需要查询多个数据库。\n    ![咨询总数随时间变化的折线图。图表显示在 2022 年 4 月 GitHub 开始发布国家漏洞数据库的所有漏洞时出现突然跳跃，随后随时间逐渐增加。](https://github.blog/wp-content/uploads/2025/06/advisory3.png?resize=1024%2C386)\n\n*   **恶意软件咨询**：由 npm 安全团队提供的信息自动发布到 GitHub 咨询数据库，专门针对恶意软件威胁。目前仅限于 npm 生态系统，GitHub 不对此类咨询进行编辑或接受社区贡献。\n    ![恶意软件咨询总数随时间变化的折线图，从 2022 年 5 月到 2024 年 12 月。图表显示恶意软件咨询在此期间总体呈上升趋势，最终达到 13405 条。](https://github.blog/wp-content/uploads/2025/06/advisory4.png?resize=1024%2C509)\n\n## 生态系统覆盖\nGitHub 已审查咨询涵盖了 GitHub 支持的生态系统中的软件包漏洞。这些生态系统通常以相关编程语言的包注册表命名。目前支持的生态系统包括：\n\n| 生态系统           | 总咨询数 | 易受攻击的软件包数 | 首次添加日期 |\n| :----------------- | :------- | :----------------- | :----------- |\n| pip                | 3378     | 1044               | 2019-04-19   |\n| Maven              | 5171     | 955                | 2019-04-22   |\n| Composer           | 4238     | 812                | 2019-04-26   |\n| npm                | 3653     | 2652               | 2019-04-26   |\n| RubyGems           | 840      | 371                | 2019-04-26   |\n| NuGet              | 651      | 489                | 2019-04-26   |\n| Go                 | 2011     | 865                | 2021-04-01   |\n| Rust               | 857      | 553                | 2021-05-25   |\n| Erlang             | 31       | 26                 | 2022-01-27   |\n| GitHub Actions     | 21       | 21                 | 2022-07-29   |\n| Pub                | 10       | 9                  | 2022-08-04   |\n| Swift              | 33       | 21                 | 2023-05-10   |\n\n*   Maven 和 Composer 软件包的漏洞几乎占数据库中咨询的一半。npm、pip 和 Go 构成了其余大部分，而其他生态系统的份额较小。\n    ![饼图显示了不同软件生态系统中咨询的比例。Maven、Composer、npm、Pip 和 Go 是最大的生态系统。](https://github.blog/wp-content/uploads/2025/06/advisory5.png?resize=1024%2C633)\n*   数据库刚推出时，NPM 咨询占据主导地位，但随着覆盖范围的扩大和新生态系统的支持，分布组合发生了变化。\n    ![堆叠面积折线图显示了 2019 年至 2024 年各种生态系统的百分比分布。图表显示最初一半的咨询是针对 NPM 的，但随着时间的推移，Maven 和 Composer 等其他生态系统变得更加突出。](https://github.blog/wp-content/uploads/2025/06/advisory7.png?resize=1024%2C539)\n\n## 咨询来源\nGitHub 咨询数据库的咨询来源于以下渠道：\n\n| 来源                   | 咨询数 | 已审查咨询数 | 唯一来源数 | 覆盖率 |\n| :--------------------- | :----- | :----------- | :--------- | :----- |\n| NVD                    | 267429 | 18295        | 7450       | 6.84%  |\n| GitHub Repository Advisories | 12247  | 5311         | 5644       | 43.37% |\n| Community Contributions | 451    | 241          | 60         | 1092.20% |\\\n| PyPA Advisories        | 3040   | 2739         | 149        | 0.10%  |\n| Go Vulncheck           | 1581   | 1528         | 79         | 6.65%  |\n| NPM Advisories         | 1411   | 1408         | 629        | 99.79% |\n| FriendsOfPHP           | 1406   | 1396         | 400        | 99.29% |\n| RustSec                | 943    | 849          | 17         | 90.03% |\n| RubySec                | 873    | 861          | 4          | 98.63% |\n\n*   **NVD**：巨大的漏洞来源，GitHub 仅审查与受支持生态系统相关的咨询。\n*   **GitHub Repository Advisories**：第二大来源，不限于受支持生态系统，但专注于开源软件。\n*   **Community Contributions**：主要请求更新现有咨询。\n*   **Other Specialized Sources**：如 PyPA Advisories 和 Go Vulncheck，专注于特定生态系统，其咨询大部分与 GitHub 相关并得到审查。\n\n*   46% 的咨询只有一个来源，85% 的咨询有三个或更少来源。\n    ![饼图显示了咨询按来源数量的比例。这表明 46% 的咨询只有一个来源，85% 的咨询有三个或更少来源。](https://github.blog/wp-content/uploads/2025/06/advisory8.png?resize=1024%2C633)\n*   在单一来源的咨询中，近 80% 来自 NVD/CVE，这证明了 NVD/CVE 作为来源的价值，尽管其信息量最大。\n    ![饼图显示了单一来源咨询按来源的比例。图表显示所有单一来源咨询的 80% 来自国家漏洞数据库。](https://github.blog/wp-content/uploads/2025/06/advisory9.png?resize=1024%2C633)\n*   2024 年，从来源导入的咨询数量显著增加了 39%，主要原因是 CVE 记录发布数量的增加。\n    ![咨询导入数量随时间变化的折线图。图表显示导入数量随时间增加。](https://github.blog/wp-content/uploads/2025/06/advisory10.png?resize=1024%2C633)\n\n## CVE 编号机构（CNA）\nGitHub 也是 GitHub 上任何仓库的 CVE 编号机构（CNA）。这意味着 GitHub 为报告的漏洞发布 CVE ID，并在相关仓库咨询发布后将其发布到 CVE 数据库。2024 年，GitHub 发布了 2000 多个 CVE 记录，成为 CVE 项目中第五大 CNA。\n\n*   GitHub CNA 对 GitHub 上的所有仓库开放，不限于受支持的生态系统。\n    ![条形图显示了咨询数据库 CNA 随时间发布的 CVE 记录数量。每年发布的数量都在增加。](https://github.blog/wp-content/uploads/2025/06/advisory11.png?resize=1024%2C633)\n    ![饼图显示了咨询数据库分配的 CVE 中属于受支持生态系统的比例。58% 属于受支持生态系统，42% 不属于。](https://github.blog/wp-content/uploads/2025/06/advisory12.png?resize=1024%2C585)\n\n## 咨询优先级\n为了帮助开发者优先处理漏洞修复工作，GitHub 在咨询中提供了额外数据：\n\n1.  **严重性评级/CVSS**：漏洞的严重程度（低、中/中等、高、关键），以及相应的 CVSS 分数和向量。一半的漏洞（15% 关键，35% 高）需要立即或近期关注。\n    ![堆叠面积折线图显示了按咨询发布年份划分的严重性评级比例。图表显示关键漏洞在早期更常见（20-25%），而中等漏洞随时间变得更常见。](https://github.blog/wp-content/uploads/2025/06/advisory13.png?resize=1024%2C633)\n2.  **CWE**：通用弱点枚举标识符，提供确定漏洞类型的编程方法，允许用户根据漏洞类型过滤警报。\n    | 排名 | CWE ID   | CWE 名称                                                              | 2024 年咨询数量 | 2023 年排名变化 |\n    | :--- | :------- | :-------------------------------------------------------------------- | :-------------- | :-------------- |\n    | 1    | CWE-79   | 网页生成过程中输入不当中和（“跨站脚本”）                                | 936             | +0              |\n    | 2    | CWE-200  | 敏感信息泄露给未经授权的参与者                                        | 320             | +0              |\n    | 3    | CWE-22   | 路径名限制到受限目录不当（“路径遍历”）                                | 259             | +2              |\n    | 4    | CWE-20   | 输入验证不当                                                          | 202             | +0              |\n    | 5    | CWE-94   | 代码生成控制不当（“代码注入”）                                        | 188             | +2              |\n    | 6    | CWE-89   | SQL 命令中使用的特殊元素不当中和（“SQL 注入”）                      | 181             | +3              |\n    | 7    | CWE-352  | 跨站请求伪造（CSRF）                                                  | 161             | -4              |\n    | 8    | CWE-284  | 访问控制不当                                                          | 153             | +4              |\n    | 9    | CWE-400  | 不受控制的资源消耗                                                    | 149             | -3              |\n    | 10   | CWE-287  | 认证不当                                                              | 124             | +1              |\n3.  **EPSS**：漏洞利用预测评分系统，量化漏洞在未来 30 天内被攻击的可能性。关注 EPSS 分数 10% 或更高的漏洞（约占咨询数据库中所有漏洞的 7%），可以覆盖几乎所有可能出现利用活动的漏洞。\n    ![条形图显示了按 EPSS 概率划分的咨询数量。大多数咨询处于低或非常低概率。](https://github.blog/wp-content/uploads/2025/06/advisory14.png?resize=1024%2C633)\n    | EPSS 概率         | 范围内的漏洞数 | 占总漏洞的百分比 | 未来 30 天内预计被攻击的漏洞数 | 占总被攻击漏洞的百分比 |\n    | :---------------- | :------------- | :--------------- | :----------------------------- | :--------------------- |\n    | 高 (>= 10%)       | 1440           | 7.17%            | 74                             | 85.96%                 |\n    | 中等 (>= 1%, < 10%) | 2687           | 13.37%           | 8                              | 9.74%                  |\n    | 低 (>= 0.1%, < 1%) | 10264          | 51.09%           | 3                              | 4.06%                  |\n    | 非常低 (< 0.1%)   | 5701           | 28.37%           | 0                              | 0.23%                  |\n    *   **注意事项**：低概率事件仍可能发生；EPSS 仅表示可能性，不表示确定性；EPSS 分数每日更新，会随新信息而变化。\n\n## 可操作数据\nGitHub 咨询数据库不仅是漏洞存储库，它还为帮助开发者保护项目安全的工具提供支持。例如，Dependabot 服务利用咨询数据库来：\n\n*   **识别漏洞**：检查项目是否使用了已知漏洞的软件包。\n*   **建议修复**：推荐可修复漏洞的软件包更新版本。\n*   **减少干扰**：仅通知用户其正在使用的软件包版本受影响的漏洞。\n\n*   每年发布的咨询中，几乎所有都带有补丁。\n    ![条形图显示了每年发布带有补丁的咨询数量与不带补丁的咨询数量。每年，几乎所有咨询都带有补丁。](https://github.blog/wp-content/uploads/2025/06/advisory15.png?resize=1024%2C633)",
      "shortSummary": "GitHub 咨询数据库（Advisory DB）是开源安全漏洞和恶意软件的关键资源。它将咨询分为 GitHub 已审查、未审查和恶意软件三类。数据库已显著增长，截至 2024 年 10 月，已审查咨询超过 20,000 条，并覆盖了更多生态系统。GitHub 还是重要的 CVE 编号机构，2024 年发布了 2,000 多个 CVE。它提供 CVSS、CWE 和 EPSS 等工具帮助开发者优先处理漏洞，并为 Dependabot 等服务提供支持，以识别漏洞并建议修复。",
      "translated_title": "GitHub 咨询数据库数据概览：已知安全漏洞及其应对措施",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory1.png?resize=1024%2C633",
          "alt": "The bar graph shows the number of reviewed advisories added each year. The graph starts with 385 advisories added in 2019, shows an increase over time, and ends with 5256 advisories added in 2024.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory2.png?resize=1024%2C601",
          "alt": "The line graph shows the total reviewed advisories steadily increasing from 0 in 2019 to 20607 at the end of 2024.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory3.png?resize=1024%2C386",
          "alt": "The line graph shows the total number of advisories overtime. The graph shows a sudden jump in April 2022, when GitHub started publishing all vulnerabilities from the National Vulnerability Database feed. It then shows a gradual increase over time.",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory4.png?resize=1024%2C509",
          "alt": "The line graph shows the total malware advisories over time, from May 2022 to December 2024. The line shows a general upward trend in malware advisories over the period, ending at 13405 advisories.",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory5.png?resize=1024%2C633",
          "alt": "The pie chart shows the proportion of advisories across different software ecosystems. Maven, Composer, npm, Pip, and Go are the largest ecosystems.",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory7.png?resize=1024%2C539",
          "alt": "The stacked area line graph shows the percentage distribution of various ecosystems from 2019 to 2024. The graph starts with half the advisories being for NPM but over time, other ecosystems like Maven and Composer become more prominent.",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory8.png?resize=1024%2C633",
          "alt": "The pie graph shows the proportion of advisories by the number of sources they have. This shows that 46% of the advisories have only one source and 85% have three or fewer.",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/advisory9.png?resize=1024%2C633",
          "alt": "The pie graph shows the proportion of advisories that have a single source by the source they came from. The graph shows that 80% of all single sourced advisories come from the National Vulnerability Database.",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Use these insights to automate software security (where possible) to keep your projects safe.</p>\n<p>The post <a href=\"https://github.blog/security/github-advisory-database-by-the-numbers-known-security-vulnerabilities-and-what-you-can-do-about-them/\">GitHub Advisory Database by the numbers: Known security vulnerabilities and what you can do about them</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "从结对编程到对等编程：GitHub Copilot 中智能代理工作流的愿景 (原标题: From pair to peer programmer: Our vision for agentic workflows in GitHub Copilot)",
      "link": "https://github.blog/news-insights/product-news/from-pair-to-peer-programmer-our-vision-for-agentic-workflows-in-github-copilot/",
      "pubDate": "Wed, 25 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-25T16:00:00.000Z",
      "creator": "Tim Rogers",
      "summary": "# GitHub Copilot：从结对编程到对等编程的智能代理工作流愿景\n\n## 引言：GitHub Copilot 的演进\n\nGitHub Copilot 最初于2021年推出时，被定位为“AI结对程序员”，旨在帮助开发者保持专注、减少样板代码并加速编码。然而，GitHub 的愿景是让 Copilot 不仅仅是一个助手，而是能够主动与开发者协作，包括同步任务、独立解决问题，甚至审查代码。这标志着 Copilot 正从一个辅助工具向一个能够主动解决问题的智能代理转变。\n\n## 智能代理的未来愿景\n\n未来的 GitHub Copilot AI 代理将通过多步骤推理和执行来积极解决问题，具备以下能力：\n\n*   **独立问题解决**：Copilot 将分解复杂任务并采取必要步骤来解决它们，并在此过程中提供更新。\n*   **自适应协作**：无论是与开发者同步工作，还是在后台独立运行，Copilot 都将迭代自己的输出以推动项目进展。\n*   **主动提升代码质量**：Copilot 将主动协助解决问题、测试和代码审查等任务，确保更高质量、更易于维护的代码。\n\nCopilot 的未来在于其在不同模式之间灵活切换的能力——独立执行任务，同时让开发者随时了解情况并保持控制。这种演变将使开发者能够专注于更高层次的决策，而 Copilot 则承担更多的执行工作。\n\n## Copilot 的实际应用：迈向愿景的步伐\n\n### 1. 代理模式（Agent Mode）：IDE 中的实时 AI 队友\n\n代理模式是 GitHub Copilot 中一个独立的 AI 代理，它存在于开发者的代码环境中，感觉就像将电脑交给队友几分钟。当开发者发出指令时，代理会接管控制，解决问题，并通过定期检查点报告其工作。其能力包括：\n\n*   读取整个工作区以理解上下文。\n*   规划多步骤的修复或重构（并首先展示计划）。\n*   应用更改、运行测试，并在紧密的反馈循环中迭代。\n*   在意图不明确时寻求指导。\n*   通过“代理循环”运行和完善自己的工作——规划、应用更改、测试和迭代。\n\n在代理模式下，Copilot 不仅仅响应请求，而是主动朝着开发者的目标努力。开发者定义结果，Copilot 决定最佳方法，并在需要时寻求反馈、测试自己的解决方案并实时完善工作。这就像是快速推进的结对编程：开发者实时观察任务的展开，可以随时介入或重新定向。\n\n### 2. 编码代理（Coding Agent）：在你休息时工作的 AI 队友\n\n并非所有编码都实时发生。有时，开发者需要将任务交给队友，稍后再检查。这就是编码代理的作用——它是 Copilot 转型为独立代理的第一步。编码代理在云端启动自己的安全开发环境。开发者可以向 Copilot 分配多个问题，然后专注于其他工作，而它则处理繁重的工作。其能力包括：\n\n*   克隆仓库并在隔离环境中引导工具。\n*   将问题分解为步骤，实现更改，并编写或更新测试。\n*   通过运行测试和 Linter 验证其工作。\n*   打开草稿拉取请求（PR），并根据 PR 审查意见进行迭代。\n*   流式传输进度更新，以便开发者可以随时查看或介入。\n\n与编码代理合作就像是请另一房间的队友（拥有自己的笔记本电脑和设置）来解决问题。开发者可以自由地处理其他事情，但可以随时查看状态或提供反馈。\n\n## Copilot 智能代理未来的下一阶段：三大支柱\n\nCopilot 的下一阶段将建立在三个融合的支柱之上：\n\n1.  **更智能、更精简的模型**：大型语言模型（LLM）的持续突破不断提高准确性，同时降低延迟和成本。扩展的上下文窗口现在可以覆盖整个单体应用，为 Copilot 提供了推理复杂代码库和返回基于实际代码答案所需的“长程记忆”。\n2.  **更深层的上下文感知**：Copilot 越来越能理解工作背后的完整故事——问题、拉取请求历史、依赖图，甚至私有运行手册和 API 规范（通过 MCP）。通过利用这种更丰富的上下文，它可以建议与项目意图而非仅语法对齐的更改。\n3.  **开放、可组合的基础**：Copilot 被设计为可以无缝集成到开发者的技术栈中。开发者选择编辑器、模型和工具；Copilot 则插入其中，学习开发者的模式并加以放大。开发者处于主导地位，引导 AI 以比以往任何时候都更快的速度构建、测试和发布代码。\n\n## 总结\n\n综合来看，这些支柱将 Copilot 从单一助手转变为一个灵活的 AI 队友——一个可以帮助任何团队（从车库里的三名开发者到全球企业中的数千名开发者）以更少的摩擦和更快的速度规划、编码、测试和发布代码的伙伴。下一波浪潮已经到来。\n\n## 相关信息\n\n*   **作者**：\n    ![Tim Rogers](https://avatars.githubusercontent.com/u/116134?v=4&s=200)\n    Staff Product Manager\n*   **相关文章**：\n    *   GitHub Copilot: Meet the new coding agent\n    *   Implementing features has never been easier: Just assign a task or issue to Copilot. It runs in the background with GitHub Actions and submits its work as a pull request.\n*   **探索更多来自 GitHub**：\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切，尽在一处。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来，这里是任何人都可以构建任何东西的地方。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 进行构建的公司和工程团队。\n    *   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：最后机会：节省700美元购买 Universe 线下通行证，于10月28-29日在旧金山加入我们。",
      "shortSummary": "GitHub Copilot正从“AI结对程序员”进化为“对等程序员”，旨在通过智能代理实现更深层次的协作。其愿景是让Copilot能独立解决问题、自适应协作并主动提升代码质量。目前已推出“代理模式”在IDE中实时协助，以及“编码代理”在云端独立完成任务。未来发展将基于更智能的模型、更深层的上下文感知和开放可组合的基础，使Copilot成为一个灵活的AI队友，加速软件开发，适用于各种规模的团队。",
      "translated_title": "从结对编程到对等编程：GitHub Copilot 中智能代理工作流的愿景",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/116134?v=4&s=200",
          "alt": "Tim Rogers",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>AI agents in GitHub Copilot don’t just assist developers but actively solve problems through multi-step reasoning and execution. Here’s what that means.</p>\n<p>The post <a href=\"https://github.blog/news-insights/product-news/from-pair-to-peer-programmer-our-vision-for-agentic-workflows-in-github-copilot/\">From pair to peer programmer: Our vision for agentic workflows in GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-07-15T04:48:27.197Z"
}