{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "GitHub Copilot Spaces：为每次建议带来正确的上下文 (原标题: GitHub Copilot Spaces: Bring the right context to every suggestion)",
      "link": "https://github.blog/ai-and-ml/github-copilot/github-copilot-spaces-bring-the-right-context-to-every-suggestion/",
      "pubDate": "Wed, 18 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-18T16:00:00.000Z",
      "creator": "Andrea Griffiths",
      "summary": "# GitHub Copilot Spaces：为每次建议带来正确的上下文\n\n## 引言：AI辅助开发的上下文瓶颈\n\n当生成式AI工具（如GitHub Copilot）尝试猜测用户需求时，其有效性取决于猜测的准确性。然而，面对不熟悉的复杂代码库、团队内部的特定安全清单、或解释重要性的临时Slack对话等非模式化上下文时，即使是最强大的模型也可能基于假设而非实际知识来填补空白。这导致AI助手只能进行猜测，成为AI辅助开发中的新瓶颈。\n\n## GitHub Copilot Spaces 简介\n\nGitHub Copilot Spaces 旨在解决这一问题，它允许用户将Copilot应读取的精确上下文（包括代码、文档、对话记录、示例查询等）捆绑到一个可重用的“空间”中。一旦创建了空间，Copilot的每次聊天、代码补全或命令都将基于这些精选知识，从而生成感觉像是来自组织内部专家而非通用模型的答案。\n\n### 什么是 Copilot Space？\n\n一个空间可以被视为一个安全、可共享的知识容器，并包含行为指令：\n\n*   **附件：** 包含代码文件、整个文件夹、Markdown文档、对话记录或任何纯文本。这些为Copilot提供了答案的“事实依据”。\n*   **自定义指令：** 简短的系统提示，用于设置Copilot的语气、编码风格或评审期望，使Copilot符合团队的“内部规范”。\n*   **共享与权限：** 遵循GitHub现有的角色/可见性模型，无需管理新的访问控制列表。\n*   **实时更新：** 空间中的文件与您引用的分支保持同步，确保空间内容与代码库保持最新。\n\n**简而言之：** 一个空间就像是将团队的集体智慧固定在Copilot侧边栏，让每个人都能用自然语言查询它。结果是：更少的错误猜测、更少的复制粘贴，以及可直接提交的代码。\n\n## 5分钟快速入门指南：如何构建您的第一个空间\n\n1.  **创建空间：** 导航至 `github.com/copilot/spaces` 并点击“Create space”。清晰命名（例如 `frontend-styleguide`），并添加描述，以便队友了解何时使用。\n2.  **附加上下文：**\n    *   **从仓库：** 引入 `src/components` 等文件夹或 `eslint.config.js` 等单个文件。\n    *   **自由文本：** 将Slack对话、视频转录、入职清单甚至JSON Schema粘贴到“Text”选项卡中。Copilot会将其视为任何其他附件。\n3.  **编写自定义指令：** 一两句话即可，例如：“作为高级React评审员回应。强制执行我们的ESLint规则和Tailwind类命名约定。”\n4.  **保存并测试：** 在空间聊天中向Copilot提问（例如：“重构此`<Button>`组件以符合我们的可访问性清单”），观察它引用您刚附加的文件。\n\n## 个性化Copilot的编码风格（和语气）\n\n自定义指令是空间的“个性层”，它们与附件并存，使您能够通过简单的句子实现强大的功能：\n\n*   **强制执行规范：** “示例中始终偏好Vue 3 `script setup` 语法和Composition API。”\n*   **采用团队语气：** “简洁回答。代码块前包含一行摘要。”\n*   **教授项目特定词汇：** “称之为‘场景ID’（SCID），而不是测试用例ID。”\n\n## 自动化工作流：三个真实案例\n\n1.  **可访问性合规助手**\n    *   **内容：** WCAG标准的Markdown文档和GitHub内部的“完成定义”。\n    *   **指令：** “回答时，引用文档部分，如果需要更改则提供代码差异。”\n    *   **效果：** 用户可以询问“此新模态框的MAS-C合规性需要哪些步骤？”，Copilot会总结相关检查点，引用文档锚点，甚至建议ARIA属性或颜色对比修复。\n2.  **复杂Schema的数据查询助手**\n    *   **内容：** 40多个事件表的YAML Schema文件，以及保存为`.sql`文件的KQL示例片段。\n    *   **指令：** “仅生成KQL，除非要求，否则不提供散文解释。”\n    *   **效果：** 不熟悉数据库结构的产品经理和支持工程师可以询问“过去7天平均PR评审时间？”，Copilot会自动补全有效的KQL查询，包含正确的连接，并允许他们迭代。\n3.  **入职培训中心和知识库**\n    *   **内容：** 导出为SVG文本的关键架构图，以及来自多个仓库的ADR（架构决策记录）和设计文档。\n    *   **指令：** “像入职导师一样回答；链接到更深入的文档。”\n    *   **效果：** 新员工输入“我们的认证流程如何处理SAML？”即可获得结构化答案，包含链接和图表，所有这些都无需离开GitHub。由于空间与主分支保持同步，ADR的更新会自动传播，避免知识库过时。\n\n## 与GitHub原生集成的协作与安全\n\nSpaces 尊重您已使用的相同权限模型：\n\n*   **个人空间：** 除非共享，否则仅您可见。\n*   **组织拥有的空间：** 使用仓库或团队权限来控制访问。\n*   **只读与可编辑：** 允许主题专家维护规范，而其他人则消费内容。\n\n共享就像发送空间URL或将其固定到仓库README一样简单。任何有访问权限和Copilot许可证的用户都可以立即开始聊天。\n\n## Copilot Spaces 的未来展望\n\nGitHub 正在努力将Copilot Spaces 引入更多工作流，目前正在开发：\n\n*   **问题和PR附件：** 将内联讨论和评审注释纳入相同的上下文捆绑包。\n*   **IDE集成：** 在VS Code中查询空间，以匹配团队模式编写测试。\n*   **组织范围可发现性：** 帮助您像浏览仓库一样浏览空间，以便新工程师可以搜索“支付主题专家”并开始聊天。\n\n您的反馈将塑造这些优先级。\n\n## 立即开始\n\n前往 `github.com/copilot/spaces`，创建您的第一个空间，并告诉我们它如何简化您的工作流。以下是完整的设置步骤：\n\n1.  **启用预览功能：** 在“Settings > Copilot > Preview features”中启用Copilot Spaces。\n2.  **创建空间：** 创建一个小型、高影响力的空间，例如团队的代码评审清单或一组常见的数据查询。\n3.  **分享：** 在Slack或README中分享链接，观察对主题专家的咨询请求减少。\n4.  **迭代：** 精简未使用的附件，完善指令，或将大型空间拆分为更小的空间。\n\nCopilot Spaces 在公开预览期间免费，并且在使用基础模型时不会计入您的Copilot席位权益。我们期待看到当Copilot拥有正确的上下文时，您能构建出什么。\n\n**作者：**\n\n![Andrea Griffiths](https://github.blog/wp-content/uploads/2025/03/cropped-IMG_1971-200x200.jpeg)\n\nAndrea Griffiths 是 GitHub 的高级开发者倡导者，拥有十多年的开发者工具经验。她将技术深度与使先进技术更易于访问的使命相结合。在从军队服役和施工管理转型到软件开发后，她为连接复杂的工程概念与实际实现带来了独特的视角。她与她的威尔士伴侣、两个儿子和两只狗住在佛罗里达州，在那里她通过GitHub的全球倡议继续推动创新和支持开源。\n\n**探索更多来自GitHub的资源：**\n\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) [Docs](https://docs.github.com/)\n    掌握GitHub所需的一切，尽在一处。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) [GitHub](https://github.com/)\n    在GitHub上构建未来，这里是任何人、任何地方、构建任何东西的场所。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) [Customer stories](https://github.blog/customer-stories/)\n    了解使用GitHub进行构建的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) [GitHub Universe 2025](https://githubuniverse.com/)\n    最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山与我们相聚。",
      "shortSummary": "GitHub Copilot Spaces 旨在解决生成式AI在缺乏特定上下文时的问题。它允许用户将代码、文档、内部知识等捆绑成可重用的“空间”，并通过自定义指令个性化Copilot的行为。这使得Copilot能基于组织特有知识提供精确、专业的建议，减少错误和重复工作。功能包括快速创建、个性化风格、以及用于可访问性、数据查询和新员工培训的实际应用。Spaces遵循GitHub权限模型，未来将集成到IDE和PR工作流中。该功能在公开预览期间对所有Copilot用户免费。",
      "translated_title": "GitHub Copilot Spaces：为每次建议带来正确的上下文",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/03/cropped-IMG_1971-200x200.jpeg",
          "alt": "Andrea Griffiths",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to build your first space in minutes and customize Copilot to match your team's unique coding style and workflows.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/github-copilot-spaces-bring-the-right-context-to-every-suggestion/\">GitHub Copilot Spaces: Bring the right context to every suggestion</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用 GitHub Copilot 处理议题以提升生产力的 5 个技巧 (原标题: 5 tips for using GitHub Copilot with issues to boost your productivity)",
      "link": "https://github.blog/ai-and-ml/github-copilot/5-tips-for-using-github-copilot-with-issues-to-boost-your-productivity/",
      "pubDate": "Tue, 17 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-17T16:00:00.000Z",
      "creator": "Klint Finley",
      "summary": "## 使用 GitHub Copilot 处理议题以提升生产力的 5 个技巧\n\n软件开发中的议题管理可能既繁琐又耗时。GitHub Copilot 最新的议题管理功能旨在简化这一过程，帮助开发者创建、组织甚至解决议题。这些功能可以节省时间、减少摩擦并保持项目的一致性。\n\n### 1. 截图转议题：即时生成 Bug 报告\n\n编写详细的 Bug 报告通常重复且令人沮丧，导致文档不一致。Copilot 的“截图转议题”功能显著减少了这一摩擦。\n\n*   **操作方式**：只需将 Bug 截图粘贴到 Copilot 聊天中，并附上简短描述，Copilot 就会分析图像并为你生成一份全面的 Bug 报告。\n*   **优势**：无需费力描述视觉故障或 UI 问题，图像本身就能说明问题，Copilot 负责文档化。例如，遇到 UI 对齐问题或难以描述的视觉故障时，截屏后粘贴到 Copilot，并简要提及问题即可。\n*   **示例**：文章提到，用户提示“创建 Bug 议题，因为 Markdown 表格在评论中未正确渲染”，Copilot 随后自动起草报告，包括重现 Bug 的步骤。\n*   **提示**：清晰地标注截图（高亮或圈出问题区域）有助于 Copilot 生成更精确的议题描述。\n\n### 2. 自动元数据和模板\n\n当团队成员跳过添加正确的元数据时，项目会迅速变得混乱，不正确的模板、缺失的标签或错误的议题类型会使跟踪和优先级排序变得困难。Copilot 通过以下方式解决此问题：\n\n*   **自动推断**：根据你的提示自动推断最佳模板。\n*   **自动添加**：无需导航多个下拉菜单或记住标签约定，即可添加适当的标签和议题类型。\n*   **自定义**：可以要求 Copilot 添加特定标签或切换模板。\n*   **自动重格式化**：如果起草后更改模板，Copilot 会自动重格式化内容，无需手动复制。\n\n### 3. 通过版本控制和里程碑保持井然有序\n\n保持议题更新和正确分类对于清晰沟通、维持项目进度和确保可见性至关重要。Copilot 使添加项目和里程碑变得像输入提示一样简单。\n\n*   **灵活组织**：你可以精确指定议题的组织方式，例如，要求 Copilot 使用“Bug 报告”或“功能请求”模板，添加“优先级：高”、“前端”或“需要分类”等标签，或将议题类型设置为“任务”或“史诗”。\n*   **一致性**：Copilot 会自动应用这些细节，确保议题始终保持一致的分类。\n*   **历史记录**：Copilot 还会跟踪所有更改，使其易于查阅。你可以查看议题历史记录并在需要时恢复更改，确保重要信息不会丢失。\n\n### 4. 批量创建多个议题\n\n有时在客户会议、用户测试会话或 Bug 修复活动后，你需要记录多个议题。传统上，这意味着重复多次相同的创建过程。Copilot 支持多议题起草，允许你在一次对话中创建多个议题。\n\n*   **节省时间**：无论是记录功能请求还是文档化 Bug，批量创建都能显著节省时间。\n*   **操作方式**：只需提示 Copilot 创建议题，描述每一个，Copilot 就会全部起草。\n*   **示例**：你可以给出类似“为以下功能创建议题：- 渲染的 Markdown 中忽略换行符，尽管有双空格 - 粗体和斜体 Markdown 样式组合时未应用”的提示，一次创建两个议题。\n*   **流程**：你仍然需要审查并最终确定每个议题，但起草过程被简化为单一工作流。\n\n### 5. 让 AI 帮助修复 Bug：Copilot 编码代理\n\n创建议题只是成功的一半，修复它们才是真正的工作。现在，你可以直接将议题分配给 Copilot。\n\n*   **AI 协助**：只需要求 Copilot 编码代理接管议题，你的 AI 编码助手就会开始分析 Bug。\n*   **建议修复**：Copilot 甚至可以建议包含潜在修复的拉取请求草稿。\n*   **效率提升**：这种无缝交接减少了上下文切换，并加快了解决时间，让你的团队能够专注于更复杂的挑战。\n\n### GitHub 议题增强功能（超越 Copilot）\n\n除了 Copilot，GitHub 也在不断增强整体议题体验：\n\n*   **标准化议题类型**：跨仓库标准化议题类型，实现一致的跟踪和报告。\n*   **分解复杂任务**：将复杂任务分解为子议题，以便更好地管理进度。\n*   **高级搜索**：使用逻辑运算符进行高级搜索，快速找到所需内容。\n*   **扩展限制**：管理更大的项目，支持多达 50,000 个项目。\n\n### 立即开始增强议题管理\n\n准备好使用 GitHub Copilot 改变你的议题管理工作流了吗？访问 github.com/copilot 并尝试以下提示：\n\n*   “为……创建议题”\n*   “记录一个 Bug”\n*   或者直接上传截图并提及你想提交一个 Bug。\n\n亲身体验 Copilot 如何让议题管理不再像行政负担，而更像与你的 AI 结对程序员进行对话。",
      "shortSummary": "GitHub Copilot 推出五项新功能，旨在提升议题管理效率。这些功能包括：将截图转化为详细 Bug 报告、自动添加元数据和模板、通过版本控制和里程碑保持议题有序、支持批量创建多个议题，以及让 Copilot 编码代理协助分析和修复 Bug。Copilot 旨在简化议题创建、组织和解决流程，减少开发者的行政负担，提升生产力。",
      "translated_title": "使用 GitHub Copilot 处理议题以提升生产力的 5 个技巧",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/957053?v=4&s=200",
          "alt": "Klint Finley",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Reduce context-switching, minimize manual work, and accelerate resolution times with these new AI-powered features.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/5-tips-for-using-github-copilot-with-issues-to-boost-your-productivity/\">5 tips for using GitHub Copilot with issues to boost your productivity</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "Git 2.50 的亮点 (原标题: Highlights from Git 2.50)",
      "link": "https://github.blog/open-source/git/highlights-from-git-2-50/",
      "pubDate": "Mon, 16 Jun 2025 17:12:27 +0000",
      "isoDate": "2025-06-16T17:12:27.000Z",
      "creator": "Taylor Blau",
      "summary": "Git 开源项目发布了 Git 2.50 版本，包含了来自 98 位贡献者（其中 35 位是新贡献者）的新功能和错误修复。在深入探讨本次发布细节之前，值得一提的是，Git 用户和开发者大会 Git Merge 将于今年 9 月 29-30 日在旧金山举行，门票现已发售。\n\n以下是 Git 2.50 中一些最值得关注的功能和变化：\n\n*   **多余对象包（Cruft Packs）的改进**\n    *   **背景：** Git 2.37 引入了多余对象包（cruft packs）来存储不可达对象。Git 2.43 增加了 `git repack --max-cruft-size` 选项，旨在将不可达对象分散到多个包中。\n    *   **旧问题：** `git repack --max-cruft-size` 的行为令人困惑，与 `git repack --max-pack-size` 不同，并且在实际使用中常常无法达到预期效果，例如，它可能阻止合并小的多余对象包。\n    *   **Git 2.50 的解决方案：**\n        *   引入了新的选项 `--combine-cruft-below-size`：该选项用于确定哪些现有的多余对象包可以合并，从而允许用户逐步减少仓库中多余对象包的数量。\n        *   重新定义了 `--max-cruft-size`：现在它仅作为多余对象包特有的 `--max-pack-size` 覆盖选项，只决定输出包的大小，而不决定哪些包被合并。\n        *   修复了错误：解决了在某些情况下，存储在多个多余对象包中的对象无法“刷新”（更新修改时间）的问题，避免了对象被过早删除。\n\n*   **增量多包可达性位图（Incremental Multi-pack Reachability Bitmaps）**\n    *   **背景：** 多包索引（MIDXs）通过为分散在多个包中的对象提供单一索引，显著加速了大型仓库中的对象查找。多包可达性位图是 MIDX 特有的位图，用于提升可达性信息查询性能。然而，随着仓库增长，更新 MIDX 和位图需要重写整个文件，效率低下。\n    *   **Git 2.47 的进展：** 引入了增量 MIDX 格式，允许 MIDX 层叠。\n    *   **Git 2.50 的突破：** 为增量 MIDX 链带来了多包可达性位图支持，每个 MIDX 层都有自己的 `.bitmap` 文件。这使得在大型仓库中，随着新提交的推送，可以快速高效地添加新的可达性位图。\n    *   **现状：** 此功能仍被认为是高度实验性的，对增量多包索引和位图进行重打包的支持仍处于早期阶段。\n\n*   **ORT 合并引擎取代 Recursive**\n    *   **背景：** ORT（“Ostensibly Recursive’s Twin”）是 Git 旧有合并引擎“recursive”的全新重写，于 Git 2.33 引入，旨在提供更快的速度、更好的可维护性和更多新功能。\n    *   **新功能：** Git 2.50 允许在不实际持久化任何新对象的情况下判断两个事物是否可合并。通过 `merge-tree` 的新 `--quiet` 模式并依赖其退出码即可实现，避免了旧方法 `git merge-tree --write-tree` 可能导致的性能问题。\n    *   **重大里程碑：** ORT 已完全取代了“recursive”合并引擎，后者已从 Git 源代码中移除。ORT 自 Git 2.34 成为默认选项后，经过 16 个版本和两年半的迭代，现在“recursive”已彻底“调试完毕”（即被删除）。\n\n*   **`git cat-file` 的改进**\n    *   **对象类型过滤：** Git 2.50 将部分克隆中使用的对象过滤机制引入到 `git cat-file` 命令中。现在可以更简洁地按对象类型（如树对象）进行过滤，例如使用 `--filter='object:type=tree'`。\n    *   **移除 `--allow-unknown-type`：** 此版本使 `git cat-file` 的 `--allow-unknown-type` 选项静默失效，并移除了 `git hash-object` 写入未知类型对象的支持。这个功能在过去十年中很少被使用，且存在问题。\n\n*   **`git maintenance` 命令的增强**\n    *   **新增任务：** `git maintenance` 命令现在可以执行 `worktree-prune`（清理陈旧或损坏的工作树）、`rerere-gc`（清理旧的 rerere 条目）和 `reflog-expire`（从 reflog 中移除陈旧的不可达对象）等任务。\n    *   **`loose-objects` 任务配置：** 现有的 `loose-objects` 任务的配置得到了增强，可以通过 `maintenance.loose-objects.batchSize` 配置选项来调整为剩余松散对象创建新包的最大大小（之前固定为 50,000）。\n\n*   **`git reflog delete` 子命令**\n    *   **背景：** 之前要删除分支的整个 reflog，需要使用 `git reflog expire $BRANCH --expire=all`。\n    *   **Git 2.50 的改进：** 引入了新的 `delete` 子命令，现在可以使用更直观的 `git reflog delete $BRANCH` 来完成相同的操作。\n\n*   **引用处理的优化**\n    *   **`git update-ref` 性能提升：** 低级命令 `git update-ref` 不再检查提议的引用名称是否也可能是有效的对象 ID，从而为依赖它的高级命令带来了性能提升。\n    *   **引用前缀缓存：** Git 2.50 学习了如何缓存提议引用名称的任何前缀是否存在（例如，如果 `refs/heads/foo` 或 `refs/heads/foo/bar` 已经存在，则不能创建 `ref/heads/foo/bar/baz`）。\n    *   **迭代器查找优化：** Git 2.50 的引用后端学会了“查找”现有迭代器，通过重用相同的迭代器来检查每个可能的前缀，从而节省了时间。\n\n*   **TCP Keepalive 配置选项**\n    *   **背景：** Git 使用 curl 进行 HTTP 连接，并提供了 `http.lowSpeedLimit` 和 `http.lowSpeedTime` 等选项来控制连接。\n    *   **Git 2.50 的新增功能：** 引入了三个新的配置选项：`http.keepAliveIdle`、`http.keepAliveInterval` 和 `http.keepAliveCount`，用于精细控制 curl 的 TCP 探测行为（如果操作系统支持）。",
      "shortSummary": "Git 2.50 发布，带来了多项重要更新。核心亮点包括：ORT 合并引擎完全取代了旧的 recursive 引擎，提升了合并性能并支持无对象写入的合并判断。多余对象包管理得到显著改进，引入了 `--combine-cruft-below-size` 选项并修复了相关错误。增量多包可达性位图现在支持 MIDX 链，极大地优化了大型仓库的性能。此外，`git cat-file` 增加了对象类型过滤，`git maintenance` 新增了多项任务，`git reflog` 引入了更便捷的 `delete` 子命令，并优化了引用处理和 TCP Keepalive 配置。",
      "translated_title": "Git 2.50 的亮点",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/443245?v=4&s=200",
          "alt": "Taylor Blau",
          "title": "",
          "position": 1
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>The open source Git project just released Git 2.50. Here is GitHub’s look at some of the most interesting features and changes introduced since last time.</p>\n<p>The post <a href=\"https://github.blog/open-source/git/highlights-from-git-2-50/\">Highlights from Git 2.50</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 计费团队如何利用 GitHub Copilot 中的编码代理持续消除技术债务 (原标题: How the GitHub billing team uses the coding agent in GitHub Copilot to continuously burn down technical debt)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-the-github-billing-team-uses-the-coding-agent-in-github-copilot-to-continuously-burn-down-technical-debt/",
      "pubDate": "Thu, 12 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-12T16:00:00.000Z",
      "creator": "Brittany Ellich",
      "summary": "## GitHub 计费团队如何利用 GitHub Copilot 中的编码代理持续消除技术债务\n\n### 引言：技术债务的挑战\n\n软件在不断演进中会积累技术债务，这源于过去的快速修复、临时方案和妥协。技术债务如同金融债务，拖延越久成本越高，但在紧迫的截止日期和不断涌入的功能需求下，很难优先处理。传统的管理方法（如“园艺周”或延长功能时间线）效果不佳，因为它们将技术债务视为例外而非持续维护，或导致不切实际的估算。核心问题在于将技术债务视为对正常开发流程的干扰。理想状态是能够与日常工作并行，持续地消除技术债务。\n\n### 利用 AI 代理持续管理技术债务\n\nAI 代理（如 GitHub Copilot 中的编码代理）为管理技术债务提供了巨大机会。技术债务任务不再需要堆积在待办事项中。工程师可以专注于新功能和架构变更，同时将技术债务任务分配给 GitHub Copilot。\n\n### 编码代理的具体应用示例（来自 GitHub 计费团队的实践）\n\nGitHub 计费团队已通过 GitHub Copilot 编码代理成功解决了以下实际问题：\n\n*   **提高代码测试覆盖率：** 分配任务给 Copilot 增加测试覆盖，完成后通知审查。\n*   **替换依赖项：** 让 Copilot 处理耗时的库替换工作。\n*   **标准化代码库模式：** 统一错误返回和日志记录方式，提高可维护性。\n*   **优化前端加载模式：** 调整应用，仅在需要数据时才进行 API 调用，而非每次页面加载。\n*   **识别并消除废弃代码：** 让 Copilot 查找并安全移除未使用的函数、过时端点或陈旧配置。\n\n这些实践极大地提升了团队持续处理技术债务的能力，将消除技术债务的时间从数周的间歇性工作缩短到几分钟的发布问题和几小时的拉取请求审查。\n\n### 人机协作：AI 作为副驾驶\n\nAI 代理并非取代人类工程师，而是增强其能力。代理处理重复、耗时的工作（如重构遗留代码、更新依赖、标准化模式），而工程师则可以专注于架构决策、功能创新和解决复杂的业务问题。这使得软件更健康、团队交付更快、工程师工作更有活力。\n\n人类在整个过程中至关重要：AI 代理擅长明确、重复的任务，但大型架构决策和复杂业务逻辑仍需人类判断。每个提示都需要仔细考虑，每次代码更改都需要彻底审查。AI 代理提供速度和一致性，而人类提供战略性思考（优先处理哪个技术债务、评估业务影响、识别潜在问题）。人机协作的精髓在于人类定义问题、设定约束、验证解决方案，代理处理繁琐的实现细节。\n\n### 充分利用 GitHub Copilot 编码代理的技巧\n\n1.  **为你的仓库编写 Copilot 指令：** 显著改善体验，可让代理协助编写，包含开发脚本（格式化、linting）。\n2.  **分块处理任务：** 代理可能进行大范围修改，但审查大量文件的拉取请求效率低下。将大任务分解为更小的、可审查的子任务（例如，针对特定文件或文件夹改进测试覆盖）。\n3.  **掌握有效提示的艺术：** 明确说明上下文、约束和编码标准。\n4.  **始终彻底审查代码：** AI 代理不理解业务逻辑，代码审查是确保质量的核心环节。Copilot 编码代理与现有代码审查工具无缝集成。\n\n### 拥抱 AI 工具的软件工程师的未来\n\n技术债务长期以来是“无声的生产力杀手”，很少被优先处理直到成为危机。AI 编码代理提供了彻底改变这一局面的机会。能够有效与 AI 代理协作的工程师（掌握清晰提示、周到代码审查和战略性任务委派）将拥有巨大优势。他们将能够维护同行难以处理的代码库，解决他人回避的技术债务，并可能消除耗时且昂贵的系统重写。这种转变需要有意识的努力：实验工具、了解其优缺点并将其整合到工作流程中。这将使工程师更高效、更少挫败，专注于工程的创造性方面，并为用户带来更稳定、维护良好的应用程序。\n\n### 作者信息及相关资源\n\n*   作者：Brittany Ellich，GitHub 软件工程师。\n    ![Brittany Ellich](https://avatars.githubusercontent.com/u/25957322?v=4&s=200)\n*   更多来自 GitHub 的资源：\n    *   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切。\n    *   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来。\n    *   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 的公司和工程团队。\n    *   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) Enterprise content：专为您策划的高管见解。",
      "shortSummary": "GitHub 计费团队利用 GitHub Copilot 的编码代理持续消除技术债务。传统技术债务管理效率低下，而 AI 代理能并行处理测试覆盖、依赖替换、代码标准化和死代码清理等任务。这并非取代工程师，而是增强其能力，让人类专注于架构和创新，AI 处理重复性工作。关键在于人机协作，工程师提供战略指导和彻底审查，AI 负责高效执行。通过有效提示和分块处理，团队能显著提升生产力，使软件更健康，并避免昂贵的系统重写。",
      "translated_title": "GitHub 计费团队如何利用 GitHub Copilot 中的编码代理持续消除技术债务",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/25957322?v=4&s=200",
          "alt": "Brittany Ellich",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Tech debt is a big problem that no one has time to solve. GitHub Copilot coding agent can help.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-the-github-billing-team-uses-the-coding-agent-in-github-copilot-to-continuously-burn-down-technical-debt/\">How the GitHub billing team uses the coding agent in GitHub Copilot to continuously burn down technical debt</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 可用性报告：2025 年 5 月 (原标题: GitHub Availability Report: May 2025)",
      "link": "https://github.blog/news-insights/company-news/github-availability-report-may-2025/",
      "pubDate": "Wed, 11 Jun 2025 23:24:41 +0000",
      "isoDate": "2025-06-11T23:24:41.000Z",
      "creator": "Jakub Oleksy",
      "summary": "# GitHub 2025 年 5 月可用性报告\n\nGitHub 在 2025 年 5 月经历了三次导致服务性能下降的事件。\n\n## 事件回顾\n\n### 1. 5 月 1 日事件：附件上传降级\n\n*   **时间：** 2025 年 5 月 1 日 22:09 UTC 至 23:13 UTC（持续 1 小时 4 分钟）。\n*   **受影响服务：** Issues 服务。\n*   **影响：** 用户无法上传附件，估计约 13 万用户受到影响约 45 分钟。\n*   **根本原因：** 新功能在所有客户端 HTTP 请求中添加了自定义头部，导致上传附件到提供商时出现 CORS 错误。\n*   **缓解措施：** 于 22:56 UTC 回滚了添加新头部的功能标志。\n*   **预防措施：** 正在添加新的监控指标，以确保客户端请求更改的安全推出。基于此次事件的经验，已部署了增强版功能，目前在生产环境中运行良好。\n\n### 2. 5 月 28 日事件：GitHub Actions 作业启动延迟\n\n*   **时间：** 2025 年 5 月 28 日约 09:45 UTC 至 14:45 UTC（持续 5 小时）。\n*   **受影响服务：** GitHub Actions，特别是使用 Ubuntu-24 标准托管运行器的公共仓库工作流。\n*   **影响：** 公共仓库中约 19.7% 的 Ubuntu-24 托管运行器作业出现延迟。其他托管运行器、自托管运行器和私有仓库工作流未受影响。\n*   **根本原因：** 故障转移后后端缓存行为配置错误，导致重复的作业分配，降低了受影响托管运行器池的整体容量。\n*   **缓解措施：** 配置问题于 12:45 UTC 修复。同时扩大了运行器池规模，以更快地处理积压的排队作业，直到 14:45 UTC 完全缓解排队影响。\n*   **预防措施：** 正在改进故障转移的弹性和验证，以降低未来发生类似问题的可能性。\n\n### 3. 5 月 30 日事件：Microsoft Teams GitHub 集成服务中断\n\n*   **时间：** 2025 年 5 月 30 日 08:10 UTC 至 16:00 UTC（持续 7 小时 50 分钟）。\n*   **受影响服务：** Microsoft Teams GitHub 集成服务。\n*   **影响：** 除链接预览外，所有功能均出现 100% 的错误率，集成服务无法处理用户请求或发送通知。\n*   **根本原因：** 下游身份验证提供商的身份验证问题。尽管有适当的监控，但警报阈值不够灵敏，导致事件检测和响应延迟。\n*   **缓解措施：** 团队与下游提供商密切合作诊断并解决了身份验证故障，恢复了服务功能。\n*   **预防措施：** 正在迁移到更持久的身份验证方法，以降低未来发生类似问题的风险。提供商响应时间超出预期也导致了此次中断的延长。\n\n## 更多信息\n\n*   请关注 [GitHub 状态页面](https://www.githubstatus.com/) 获取实时状态更新和事件后总结。\n*   访问 [GitHub 工程博客](https://github.blog/engineering/) 了解更多正在进行的工作。\n*   文章作者： ![Jakub Oleksy](https://avatars.githubusercontent.com/u/6147691?v=4&s=200)\n\n### 相关文章\n\n*   GitHub Copilot：认识新的编码代理\n*   实现功能从未如此简单：只需将任务或问题分配给 Copilot。它在后台与 GitHub Actions 一起运行，并将其工作作为拉取请求提交。\n\n### 探索更多 GitHub 内容\n\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) **文档**\n    掌握 GitHub 所需的一切，尽在一处。前往文档\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) **GitHub**\n    在 GitHub 上构建未来，这里是任何人、任何地点构建任何东西的地方。开始构建\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) **客户案例**\n    了解使用 GitHub 进行构建的公司和工程团队。了解更多\n*   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) **企业内容**\n    为您精心策划的执行洞察。开始使用",
      "shortSummary": "GitHub 在 2025 年 5 月报告了三起服务中断事件。5 月 1 日，Issues 服务因新功能导致附件上传降级，影响约 13 万用户。5 月 28 日，GitHub Actions 因后端缓存配置错误导致公共仓库作业启动延迟。5 月 30 日，Microsoft Teams GitHub 集成服务因下游身份验证问题完全中断，持续近 8 小时。GitHub 已采取措施修复并预防类似问题，包括回滚功能、改进故障转移弹性和迁移认证方法。",
      "translated_title": "GitHub 可用性报告：2025 年 5 月",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/6147691?v=4&s=200",
          "alt": "Jakub Oleksy",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>In May, we experienced three incidents that resulted in degraded performance across GitHub services.</p>\n<p>The post <a href=\"https://github.blog/news-insights/company-news/github-availability-report-may-2025/\">GitHub Availability Report: May 2025</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub工程师如何解决平台问题 (原标题: How GitHub engineers tackle platform problems)",
      "link": "https://github.blog/engineering/infrastructure/how-github-engineers-tackle-platform-problems/",
      "pubDate": "Tue, 10 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-10T16:00:00.000Z",
      "creator": "Fabian Aguilar Gomez",
      "summary": "# GitHub工程师如何解决平台问题\n\n## 引言：产品与平台工程的类比\n*   文章通过高达模型制作类比产品工程师和平台工程师的角色：\n    *   **产品工程师**：使用工具包构建最终产品（高达模型），专注于构建可玩或收藏的工作产品。\n    *   **平台工程师**：提供构建工具（如剪钳、锉刀）并可能搭建展示平台，确保构建者拥有所需工具，即使他们不亲自构建高达模型。\n*   作者的团队一年前转入基础设施组织，职责从解决外部客户问题（如构建新的部署视图）转变为服务内部客户，成为平台工程团队。这意味着他们现在负责构建产品组件，这要求他们重新思考代码测试和问题解决方法。\n\n## 解决平台问题的最佳实践\n\n### 1. 理解你的领域\n*   **定义**：“领域”是指团队和平台组织运作的业务和技术主题区域。\n*   **如何快速掌握**：\n    *   **与同事交流**：与对主题有更多知识和经验的团队安排交接会议，询问术语并深入理解问题。\n    *   **调查旧问题**：研究积压或持续存在的问题，以更好地理解系统的当前限制和潜在改进领域。\n    *   **阅读文档**：文档是知识的宝库，有助于理解系统的工作原理。\n\n### 2. 将概念与平台特定技能相结合\n*   平台团队作为基础层，需要更深入的理解：\n    *   **网络**：理解TCP、UDP、L4负载均衡等网络基础知识，以及`dig`等调试工具，这对于理解网络流量如何影响平台至关重要。\n    *   **操作系统和硬件**：选择合适的虚拟机（VM）或物理硬件对于可扩展性和成本管理至关重要，并需选择正确的操作系统以避免漏洞或接近生命周期结束的系统。\n    *   **基础设施即代码（IaC）**：熟练使用Terraform、Ansible、Consul等自动化工具，它们能显著减少基础设施配置和修改过程中的人为错误。\n    *   **分布式系统**：处理平台问题，尤其是在分布式系统中，需要深入理解故障是不可避免的。因此，采用故障转移和恢复机制等主动解决方案对于保持系统可靠性和防止不良用户体验至关重要。\n\n### 3. 知识共享\n*   通过分享经验和想法，工程师可以引入新视角，从而带来突破和创新。\n*   **重要性**：\n    *   **团队合作**：协作通常能更快地解决问题，并促进新解决方案的创新，因为工程师有机会相互学习并扩展现有想法。\n    *   **防止知识流失**：如果不分享经验教训，信息就无法在团队或组织内传播。当工程师离职或无法联系时，这会成为问题。\n    *   **提升客户成功**：工程师的解决方案应有效地服务客户。通过分享知识和经验教训，团队可以构建可靠、可扩展、安全的平台，从而创造出满足客户需求和期望的更好产品！\n\n## 产品工程与基础设施工程的显著差异\n\n### 1. 影响范围\n*   平台作为系统的基本构建块，任何（无论大小的）变更都可能影响广泛的产品。例如，DNS服务的一个微小改动就可能对GitHub Pages到GitHub Copilot等产品造成广泛影响。\n*   **如何理解影响范围**：\n    *   **与下游团队直接沟通**：与依赖服务的团队直接沟通，提供有关拟议变更可能如何影响其他服务的宝贵见解。\n    *   **事后分析（Postmortems）**：通过查看与平台相关的过去事件，并询问“此事件的影响是什么？”，可以更深入地了解引入了什么变更或故障、平台在其中扮演的角色以及如何修复。\n    *   **监控和遥测**：将重要的监控和日志信息浓缩成小巧且易于消化的介质（例如单一可用性指标SAM），以提供系统的总体健康状况。快速浏览单个仪表盘的能力使工程师能够迅速查明问题来源，并简化调试和事件缓解过程。\n\n### 2. 测试变更\n*   在分布式环境中测试变更（特别是像DNS这样的服务）可能具有挑战性。\n*   **关键步骤**：\n    *   **利用测试站点**：将其作为“真实”机器，可以在其中实施和评估所有变更。\n    *   **基础设施即代码（IaC）测试**：使用Terraform或Ansible等工具时，测试配置和解除配置机器等基本操作至关重要。在需要重新配置机器的情况下，要确保机器不会被意外删除，并且在需要时能够创建新机器。\n    *   **端到端（E2E）测试**：开始将一些网络流量导向这些服务器。团队可以通过直接与其交互来观察主机行为，或者通过分流一小部分流量来评估功能。\n    *   **自愈能力测试**：测试平台从意外负载中恢复的能力，并在影响用户之前识别瓶颈。早期识别瓶颈或错误对于维护平台健康至关重要。\n    *   **逐主机实施**：理想情况下，测试完成后应逐主机实施变更。这种方法允许单独机器回滚，并防止变更应用于未受影响的主机。\n\n## 总结\n*   平台工程可能很困难，GitHub的系统复杂且包含许多服务和活动部件。然而，当一切顺利运行时，所有幕后努力都得到了回报。当平台平稳运行，团队能够更快、更可靠地交付产品时，GitHub就能成为所有开发者的家园。\n\n由 ![Fabian Aguilar Gomez](https://avatars.githubusercontent.com/u/27039604?v=4&s=200) Fabian Aguilar Gomez 撰写\n\n### 相关文章\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握GitHub所需的一切。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在GitHub上构建未来，这里是任何地方的任何人都可以构建任何东西的地方。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用GitHub进行构建的公司和工程团队。\n*   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) Enterprise content：专为您策划的企业洞察。",
      "shortSummary": "GitHub工程师通过高达模型类比阐述了平台工程与产品工程的区别，强调平台工程师提供基础工具和基础设施。解决平台问题需深入理解领域知识、掌握网络、操作系统、IaC和分布式系统等平台特定技能，并重视知识共享。平台工程的挑战在于其广泛的影响范围和分布式环境下的测试复杂性。通过理解依赖、事后分析、有效监控和分阶段测试，确保平台稳定运行，从而支持产品团队更快、更可靠地交付产品。",
      "translated_title": "GitHub工程师如何解决平台问题",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/gundam.jpg?resize=1024%2C840",
          "alt": "A photograph of several Gundam models on a shelf.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/27039604?v=4&s=200",
          "alt": "Fabian Aguilar Gomez",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Our best practices for quickly identifying, resolving, and preventing issues at scale.</p>\n<p>The post <a href=\"https://github.blog/engineering/infrastructure/how-github-engineers-tackle-platform-problems/\">How GitHub engineers tackle platform problems</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub 初学者指南：使用 GitHub Copilot 进行代码审查和重构 (原标题: GitHub for Beginners: Code review and refactoring with GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/github-for-beginners-code-review-and-refactoring-with-github-copilot/",
      "pubDate": "Mon, 09 Jun 2025 13:00:00 +0000",
      "isoDate": "2025-06-09T13:00:00.000Z",
      "creator": "Kedasha Kerr",
      "summary": "# GitHub 初学者指南：使用 GitHub Copilot 进行代码审查和重构\n\n本篇文章是“GitHub 初学者指南”系列的第八集，也是最后一集，深入探讨了 GitHub Copilot 在代码审查和重构中的应用。在任何开发项目中，维护一个清晰高效的代码库至关重要，而 GitHub Copilot 不仅能辅助编写代码，还能使代码审查和重构过程更顺畅、更高效。\n\n## 使用 Copilot 进行代码重构\n\nGitHub Copilot 能够帮助开发者重构代码，使其更易于理解和维护。\n\n### 操作步骤与建议类型\n\n1.  **高亮代码并提问：** 在代码编辑器中高亮需要重构的函数，然后在 Copilot Chat 中发送提示，例如“`please provide refactoring suggestions`”（请提供重构建议）。\n2.  **审查建议：** Copilot 会提供多种重构建议，包括将代码拆分为更小的部分、优化逻辑以提高性能，甚至更新变量名称以符合命名规范。\n3.  **应用更改：** 审查并确认建议后，点击“`Apply in editor`”按钮即可自动更新文件。\n\n### 重构范围与具体示例\n\n*   **局部重构：** 适用于对代码特定区域的关注。\n*   **文件或项目级重构：** Copilot 也可以审查整个文件或项目。例如，对于一个仪表盘组件，可以向 Copilot Chat 提问“`How can I improve this code?`”（我如何改进这段代码？），Copilot 会给出多条改进建议，并可进一步解释。\n*   **提取逻辑：** 可以通过提问“`How can I extract the data fetching logic into a custom hook?`”（如何将数据获取逻辑提取到自定义 Hook 中？）来将特定逻辑（如数据获取）提取到可重用的组件中。操作流程包括将更改保存到新文件、导入 Hook 并删除旧代码。\n*   **识别冗余代码：** 提问“`Is there any redundant code in this file?`”（此文件中是否有任何冗余代码？），Copilot 会扫描代码并识别可纠正的冗余部分。\n*   **其他重构辅助：** Copilot 还能提供性能改进建议、帮助函数模块化、添加注释以提高可读性，以及升级语法到更现代的版本等。\n\n![一张幻灯片，解释 Copilot 可以提供性能改进建议、如何使函数更模块化、添加注释以提高可读性、升级语法等等！](https://github.blog/wp-content/uploads/2025/06/copilot_refactor_help.png?resize=1024%2C573)\n\n## 在 GitHub.com 上进行代码审查\n\nGitHub Copilot 也能直接在 GitHub.com 上进行代码审查，使流程更加无缝。\n\n### 审查流程\n\n1.  **创建拉取请求：** 打开一个拉取请求（Pull Request）。\n2.  **请求 Copilot 审查：** 在右上角的“Reviewers”（审查者）部分，会看到 Copilot 列为可能的审查者。点击“Request”（请求）即可让 Copilot 审查代码。\n\n![一张截图，显示了在右侧“审查者”列表中如何请求 Copilot 进行审查。](https://github.blog/wp-content/uploads/2025/06/code_review.png?resize=1024%2C573)\n\n3.  **查看建议：** Copilot 完成审查后，向下滚动拉取请求即可看到其提出的任何建议。\n4.  **接受建议：** Copilot 总是留下“Comment review”（评论审查），从不留下“Approve”（批准）或“Request changes”（请求更改）审查，这意味着 Copilot 的审查永远不会是必需的，也不会阻止合并。要接受 Copilot 的建议，点击特定建议底部的“`Commit suggestion`”（提交建议），然后在上下文菜单中点击“`Commit changes`”（提交更改），GitHub 会更新拉取请求。\n\n![一张截图，显示了标题为“提交建议”的下拉菜单中的“提交更改”按钮。](https://github.blog/wp-content/uploads/2025/06/commit_code_review.png?resize=1024%2C573)\n\n5.  **批量处理与重新审查：** 可以通过点击单个建议下的“`Add to batch`”（添加到批次）按钮来批量处理多个建议。在集成建议后，可以通过点击“Reviewers”框中 Copilot 名称旁边的圆形箭头来再次请求 Copilot 审查。\n\nCopilot 代码审查可以作为团队最终代码审查前的初步审查。\n\n## 关键组成部分与局限性\n\n### 关键组成部分\n\n使用 Copilot 进行代码审查和重构主要包括以下五个方面：\n\n*   **自动化建议：** 在审查代码时，Copilot 会提出改进和优化建议。\n*   **一致性检查：** 通过建议一致的命名约定和函数结构，帮助维护编码标准。\n*   **重构辅助：** 提供可操作的重构建议，无论是简化复杂函数还是重组代码库。\n*   **错误检测：** 能够发现可能遗漏的潜在错误或低效率问题。\n*   **注释支持：** 帮助生成清晰的代码注释，使其更易于他人理解。\n\n### 局限性\n\n尽管 GitHub Copilot 功能强大，但它仍是一个辅助工具，并非人类审查的替代品：\n\n*   **依赖上下文：** Copilot 的建议质量取决于所提供的上下文，不清晰或文档不完善的代码可能导致建议效果不佳。\n*   **非人类审查替代品：** Copilot 无法替代彻底的人工审查。务必仔细检查其提供的建议，确保它们符合项目目标、标准以及组织政策。\n\n![一张幻灯片，列出了 Copilot 的功能：协助代码审查和重构；帮助维护整洁、高效和一致的代码；节省时间并减少错误；让您更专注于构建。](https://github.blog/wp-content/uploads/2025/06/copilot_can_do.png?resize=1024%2C573)\n\n## 总结\n\nGitHub Copilot 是代码审查和重构的宝贵助手，它能帮助开发者维护整洁、高效且一致的代码，从而节省时间并减少错误。通过将 Copilot 整合到工作流程中，开发者可以更专注于构建出色的功能，而不是纠结于代码维护的细节。",
      "shortSummary": "GitHub Copilot 是一个强大的代码审查和重构工具。它通过 Copilot Chat 提供重构建议，如优化代码、提取逻辑和识别冗余。在 GitHub.com 上，Copilot 可作为拉取请求的初步审查者，提供评论但不阻塞合并。其核心功能包括自动化建议、一致性检查和错误检测。尽管功能强大，Copilot 仍是辅助工具，不能替代彻底的人工审查，其建议需人工复核。它旨在帮助开发者维护整洁高效的代码，节省时间并减少错误。",
      "translated_title": "GitHub 初学者指南：使用 GitHub Copilot 进行代码审查和重构",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/copilot_refactor_help.png?resize=1024%2C573",
          "alt": "A slide explaining that Copilot can help with performance improvement suggestions, how to make functions more modular, adding comments for readability, upgrading syntax, and much more!",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/code_review.png?resize=1024%2C573",
          "alt": "A screenshot shoring where to request a review from Copilot, under the 'reviewers' list on the right.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/commit_code_review.png?resize=1024%2C573",
          "alt": "A screenshot showing the 'Commit changes' button in the drop down menu titled 'Commit suggestion.'",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/copilot_can_do.png?resize=1024%2C573",
          "alt": "A slide listing items Copilot can do: Assists with code review and refactoring; helps maintain clean, efficient, and consistent code; saves you time and reduces errors; and allows you to focus more on building.",
          "title": "",
          "position": 4
        },
        {
          "url": "https://avatars.githubusercontent.com/u/47188731?v=4&s=200",
          "alt": "Kedasha Kerr",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 7
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 8
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to use GitHub Copilot to help review and polish your code.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/github-for-beginners-code-review-and-refactoring-with-github-copilot/\">GitHub for Beginners: Code review and refactoring with GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用GitHub Copilot中的编码代理分配和完成问题 (原标题: Assigning and completing issues with coding agent in GitHub Copilot)",
      "link": "https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/",
      "pubDate": "Fri, 06 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-06T16:00:00.000Z",
      "creator": "Alexandra Lietzke",
      "summary": "# GitHub Copilot 编码代理：分配与完成问题\n\nGitHub Copilot 推出了一项新的编码代理功能，旨在帮助开发者更高效地工作，通过将 GitHub 问题分配给它，从而获得经过充分测试的拉取请求。\n\n## 编码代理概述\n\n*   **功能定位**：作为一种新型的软件工程代理，它直接内置于 GitHub 中，一旦被分配 GitHub Issue 或在 VS Code 中收到提示，便会开始工作。\n*   **工作方式**：它像一位异步协作的队友，基于您分配的问题构建拉取请求。它不是简单的自动补全，而是能够异步工作，帮助您加速开发、清理技术债务并专注于更重要的工作。\n*   **核心机制**：\n    *   基于 GitHub Actions 构建，提供集成、安全、可定制的环境。\n    *   接收问题后，会规划工作、打开拉取请求、编写代码、运行测试，然后请求您的审查。\n    *   如果收到反馈，它会修改拉取请求并持续工作直到您批准。\n    *   能够整合相关问题或 PR 讨论的上下文，并遵循团队设定的自定义仓库指令。\n\n## 编码代理与代理模式的区别\n\n*   **代理模式 (Agent Mode)**：\n    *   同步协作器，在您工作时进行配对。\n    *   在 IDE（如 VS Code, JetBrains, Eclipse, Xcode）内作为实时协作器工作，迭代代码、运行测试并实时修正错误。\n*   **编码代理 (Coding Agent)**：\n    *   异步协作器，代表您像队友一样工作。\n    *   作为 SWE 代理在 GitHub Actions 内部运行，接收您分配的问题，探索仓库以获取上下文，编写代码，通过测试，并打开拉取请求供您审查。\n*   **资源消耗**：两者都使用 Copilot 高级请求，编码代理还会消耗 GitHub Actions 分钟数。\n\n## 编码代理的优势与应用场景\n\nGitHub 高级软件工程师 Brittany Ellich 指出，编码代理能帮助开发者更好地完成多项任务：\n\n*   **卸载重复性任务**：例如添加和扩展单元测试、快速修复拼写错误、进行小型重构等。\n*   **改善问题管理和文档**：通过快速修复和小型重构来维护更好的问题卫生和文档。\n*   **提升用户体验**：修复错误、更新用户界面功能和增强可访问性。\n\n通过将这些低到中等复杂度的任务分配给编码代理，开发者可以有更多精力专注于高层次的问题解决和设计、处理积压的技术债务、学习新技能等。\n\n## 使用编码代理完成问题的步骤\n\n尽管 Copilot 执行工作，但您始终掌握控制权：您决定分配什么、批准什么以及需要更改什么。Copilot 还可以通过其“创建问题流程”预览功能帮助您构建问题。\n\n1.  **编写并分配问题给 Copilot**\n    *   这是最关键的步骤，需要提供充足的上下文，如同向团队成员简要说明任务。\n    *   **包含信息**：相关背景信息、预期结果、技术细节、格式或 linting 规则。\n    *   **分配方式**：通过 github.com、GitHub 移动应用或 GitHub CLI。\n    *   **任务范围**：最适合范围明确的任务，但也能处理大型任务（可能耗时更长）。可以批量分配多个问题。\n    *   **实用技巧**：\n        *   使用问题模板（如“描述”和“验收标准”字段）提高一致性。\n        *   Copilot 会利用仓库中的自定义指令（如自动生成文件、格式化规则）。\n        *   代理能够识别分配问题中包含的图片，因此您可以分享新功能的外观图片。\n\n2.  **Copilot 规划代码**\n    *   分配后，Copilot 会添加 👀 表情符号反应，并启动 GitHub Actions 会话。\n    *   在此环境中，Copilot 会探索和分析代码库、运行测试并进行更改。\n    *   它会同时打开一个分支和一个拉取请求，并随着工作进展而演变。\n    *   Copilot 会阅读问题并将其分解为任务清单，然后更新拉取请求。\n    *   完成任务后，Copilot 会将其勾选并推送提交。您可以实时查看会话、查看日志或刷新 PR。\n\n3.  **Copilot 编写代码**\n    *   当拉取请求时间线显示“Copilot started work”事件时，表示工作已开始。\n    *   Copilot 会根据问题修改代码库，运行自动化测试和 linter（如果存在），并根据需要更新或生成测试。\n    *   它会迭代推送提交。您可以实时查看工作进展，并在必要时介入以确保方向正确。\n\n4.  **审查并合并拉取请求**\n    *   Copilot 完成工作后，会标记您进行审查。您可以：\n        *   批准拉取请求\n        *   留下评论\n        *   要求更改\n    *   Copilot 会根据仓库规则自动请求审阅者。可以进行多轮审查。\n    *   **重要提示**：问题创建者不能是最终批准者。需要由同事、经理或指定审阅者批准，以促进协作并确保代码安全。\n\n## 成功使用编码代理的建议\n\n*   **编写全面的问题**：清晰、范围明确、文档完善的问题会带来更好的结果。\n*   **从小处着手**：尝试将代理用于测试、文档或简单的重构。\n*   **故障排除**：如果 Copilot 遇到问题，在评论中标记它并添加更多上下文。迭代和完善问题要求也有帮助。\n\n## 展望\n\nAI 和 LLM 正在快速发展，编码代理已在实际工作流程中展现出实用性。鼓励开发者尝试使用编码代理，构建自己的代理工作流。",
      "shortSummary": "GitHub Copilot 推出了一项新的编码代理功能，允许开发者将 GitHub 问题分配给它。该代理作为异步队友，能自动规划、编写代码、运行测试并创建拉取请求，从而帮助开发者卸载重复性任务，专注于更复杂的开发工作。用户始终保持控制权，通过细致的问题描述和审查流程指导代理。这项功能旨在显著提升开发效率，加速软件交付。",
      "translated_title": "使用GitHub Copilot中的编码代理分配和完成问题",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Have you tried the new coding agent in GitHub Copilot? Here’s how developers are using it to work more efficiently. </p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/\">Assigning and completing issues with coding agent in GitHub Copilot</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何在GitHub上快速创建问题和拉取请求 (原标题: How to create issues and pull requests in record time on GitHub)",
      "link": "https://github.blog/developer-skills/github/how-to-create-issues-and-pull-requests-in-record-time-on-github/",
      "pubDate": "Thu, 05 Jun 2025 16:00:00 +0000",
      "isoDate": "2025-06-05T16:00:00.000Z",
      "creator": "Jon Peck",
      "summary": "## GitHub Copilot如何加速问题和拉取请求的创建\n\n软件开发的核心始于对话，而GitHub上的“问题”（Issue）正是这种对话的结晶。一个精心设计的问题为后续的拉取请求（PR）、代码审查、测试和部署奠定了基础。GitHub Copilot正在改变从想法到问题再到PR的流程，通过协助起草问题并将其分配给其编码代理，从而显著加速整个开发周期。\n\n本文将深入探讨：\n\n*   问题为何仍然是GitHub上工作的核心，无论是由人工还是Copilot创建。\n*   与团队或Copilot协作时，构建优质问题的最佳实践。\n*   Copilot驱动的工作流如何帮助您更快地推进工作，确保一致性，并为Copilot编码代理的自动化修复做好准备。\n\n## 为何优质的问题和拉取请求至关重要\n\nGitHub上的问题和拉取请求是核心构建块。每个问题描述一项独立的工作，并提供有用的细节和要求；PR则捆绑已完成的工作以进行代码审查和合并。即使在AI加速的工作流中，这些“工件”仍是团队理解工作进展的关键。无论由谁（或什么）创建，结构良好的问题和拉取请求都能带来四大关键优势：\n\n*   **共享上下文**：一个URL即可捕获问题陈述、复现步骤和完成定义，便于新成员快速了解。\n*   **异步协作**：减少会议，让开发人员可以异步工作，仅在必要时进行同步。\n*   **审计和分析**：标签、里程碑和模板支持仪表盘、SLA和合规性报告。\n*   **自动化钩子**：Actions工作流、项目看板和代理工具都依赖于附加到每个问题的可预测元数据。\n\n**不良问题的示例**：文章中提到一个糟糕的问题示例，仅有标题“Issue #12609: Found broken link. Please fix!”，但正文没有任何解释、实际链接、上下文、环境或版本信息，也没有可复现的示例或建议修复。这种模糊的提示会导致模糊的输出，无论是人类还是机器。\n\nAI（如大型语言模型）在目标、约束和成功标准明确时表现最佳。Copilot通过协助创建问题，让开发者能够专注于清晰度，而非复制粘贴，因为它能定位相关引用、构建初始问题结构，甚至添加标签或项目分配。\n\n## 优质GitHub问题的构成要素\n\n创建或审查问题时，请使用以下清单（Copilot会协助编写，但您仍需把控）：\n\n*   **行动导向的标题**：以名词开头，动词结尾（例如：“登录按钮 – 在Safari 17 beta上禁用”）。\n*   **问题或用户故事**：描述痛点（例如：“作为购物者，我无法在移动Safari上点击购买，因此放弃购物车并哭泣。”）。\n*   **预期行为与实际行为**：简洁的对比（例如：“应渲染主按钮” vs. “按钮不可点击，无CSS pointer-events。”）。\n*   **复现步骤或视觉证据**：GIF、截图或命令行细节，帮助团队成员（或Copilot）快速理解问题。\n*   **验收标准/完成定义**：明确的通过/失败标准（例如：“所有测试通过”，“Lighthouse分数 > 90”，“功能标志已移除”）。\n*   **范围和约束**：防止过度开发（例如：性能预算、浏览器列表、无新依赖）。\n*   **元数据**：标签、负责人、里程碑、项目，这是驱动看板、筛选和Slack通知的关键。\n\n## 如何使用Copilot在GitHub上更快地起草问题\n\n优质问题具备两个特点：编写快速且上下文丰富。GitHub Copilot的“创建问题”流程兼顾两者。您无需在不同字段间跳转或复制粘贴片段，只需打开Copilot Chat并用自然语言描述问题，例如：“创建关于octo-org/octo-web登录表单500错误的bug报告。”\n\nCopilot会起草标题、正文，甚至建议标签和负责人，并根据您的仓库首选模板进行格式化，确保每次问题都以正确的格式呈现。\n\n**分步指南**：\n\n1.  在github.com/copilot打开Copilot Chat的沉浸式视图。\n2.  描述您的需求。提及仓库（组织/仓库）或让Copilot根据您上次提交问题的位置推断。\n3.  如果图片能更快地说明问题，请插入截图；Copilot会将其嵌入草稿并引用在描述中。\n4.  审查草稿。可以提出后续提示（例如：“添加复现步骤”、“切换到bug模板”）或直接修改Markdown。\n5.  确认无误后点击“创建”。\n\n**使用GitHub Copilot构建优质问题的技巧**：\n\n| 您做什么           | Copilot如何帮助                                | 为何重要                                     |\n| :----------------- | :--------------------------------------------- | :------------------------------------------- |\n| 提供上下文         | 将您的措辞解析到正确的模板部分。               | 团队成员（或Copilot）获得清晰度。            |\n| 附上证据           | “图像转问题”将文件保留在问题正文中。           | 未来的调试者能准确看到您所看到的。           |\n| 标记后续操作       | 一次性添加负责人、标签、里程碑。               | 保持看板整洁，工作流自动化。                 |\n| 批量处理相关bug    | 生成多个草稿供您单独批准。                     | 在分类模式下无需切换标签页。                 |\n\n## 如何通过GitHub Copilot的编码代理将问题转化为草稿PR\n\n一旦您通过Copilot获得了清晰的问题，就可以通过编码代理将其分配给Copilot（它会像任何团队成员一样显示）或直接询问：“将此分配给Copilot。”当您点击“创建”时，Copilot会接管并开始修复工作——您会在问题线程上看到👀表情符号。\n\n**幕后流程**：\n\n1.  Copilot启动一个安全的GitHub Actions工作区。\n2.  它克隆仓库，进行语义代码搜索（RAG风格），并制定修复计划。\n3.  提交会实时推送到草稿PR，您可以实时查看——没有意外的强制推送。\n4.  您的标准分支保护和CI门禁仍会运行。\n\n**这样做的好处**：\n\n*   **并行化**：您在审查时Copilot在编写，开发周期完美重叠。\n*   **可审计性**：每次提交、差异和评论都清晰可见，没有黑盒AI的神秘感。\n*   **安全保障**：遵循相同的CODEOWNERS和签名规则，在提高速度的同时保持控制。\n\n## 常见问题与快速解答\n\n*   **“Copilot会用低质量问题淹没我的仓库吗？”**：它起草，您完善并点击“创建”。相同的速率限制，相同的模板——只是减少了打字量。\n*   **“它能更新现有问题吗？”**：目前不能。目前仅支持新建；更新现有问题的功能正在路线图上。\n*   **“它理解我的自定义模板吗？”**：是的！Copilot会从您的仓库中推断，并且您可以在起草过程中切换模板而不会丢失提示上下文。\n*   **“支持移动端吗？”**：目前仅支持桌面端；移动端支持正在计划中。\n\n## 总结\n\n下次当您觉得“天哪，提交这个bug比修复它还费时间”时，打开Copilot Chat，让机器人处理表单字段，您则专注于捕捉意图。将想法更快地转化为问题和PR，用户就能更快地获得功能——您也能更快地回到有趣的工作中。祝您编码愉快！\n\n想要了解更多关于GitHub Copilot的信息？请访问我们的文档。\n\n**作者**：\n\n![Jon Peck](https://avatars.githubusercontent.com/u/5299412?v=4&s=200)\n\n**探索更多来自GitHub的内容**：\n\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) **文档**：掌握GitHub所需的一切，尽在一个地方。 [前往文档](https://docs.github.com/)\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) **GitHub**：在GitHub上构建未来，这里是任何人、任何地点构建任何东西的地方。 [开始构建](https://github.com/)\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) **客户案例**：了解使用GitHub进行构建的公司和工程团队。 [了解更多](https://github.blog/customer-stories/)\n*   ![Enterprise content](https://github.blog/wp-content/uploads/2022/05/careers.svg) **企业内容**：专为您策划的执行洞察。 [开始](https://github.blog/enterprise/)",
      "shortSummary": "GitHub Copilot显著加速了在GitHub上创建问题和拉取请求的流程。它能根据自然语言描述自动起草清晰的问题，包括标题、正文和元数据，并支持添加截图和遵循自定义模板。更进一步，Copilot的编码代理可直接接管问题，自动生成并提交草稿PR，实现开发工作的并行化和自动化。这大大提高了开发效率，确保了工作流的清晰性和可审计性。",
      "translated_title": "如何在GitHub上快速创建问题和拉取请求",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/5299412?v=4&s=200",
          "alt": "Jon Peck",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to spin up a GitHub Issue, hand it to Copilot, and get a draft pull request in the same workflow you already know.</p>\n<p>The post <a href=\"https://github.blog/developer-skills/github/how-to-create-issues-and-pull-requests-in-record-time-on-github/\">How to create issues and pull requests in record time on GitHub</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "攻破模型：通过GitHub安全代码游戏构建AI安全技能 (原标题: Hack the model: Build AI security skills with the GitHub Secure Code Game)",
      "link": "https://github.blog/security/hack-the-model-build-ai-security-skills-with-the-github-secure-code-game/",
      "pubDate": "Tue, 03 Jun 2025 16:37:03 +0000",
      "isoDate": "2025-06-03T16:37:03.000Z",
      "creator": "Joseph Katsioloudes",
      "summary": "# GitHub安全代码游戏第三季：构建AI安全技能\n\nGitHub近日推出了安全代码游戏第三季，本次重点聚焦人工智能引入的安全风险，旨在通过实践帮助开发者提升AI安全技能。\n\n## 关于GitHub安全代码游戏\n\n*   **免费软件安全课程**：适合所有开发者水平。\n*   **学习方式**：玩家通过修复故意设置的漏洞代码来构建代码安全技能。\n*   **沉浸式体验**：游戏直接在代码编辑器中进行，模拟开发者日常工作环境。\n*   **快速上手**：使用Codespaces，两分钟内即可开始。\n\n## 历史与成就\n\n*   **第一季（2023年3月）**：旨在弥补开发者培训中安全技能的不足，通过看似完美但实则包含OWASP Top 10等关键漏洞的代码片段吸引玩家。\n*   **游戏化学习**：挑战玩家高效修复问题，同时避免引入新漏洞或遗漏边缘情况。\n*   **第二季**：在强大社区支持下推出，已有超过10,000名来自企业、开源和教育领域的开发者参与，磨练了技能。\n*   **玩家反馈**：\n    *   Sanyam Mehta（后端开发者）：“这让我意识到识别最基本缺陷的差距有多大，也让我更加谨慎。”\n    *   Tyler Anton（计算机科学学生）： “这是一种非常有趣的学习方式！我绝对会推荐这款游戏，它帮助我更清楚地认识到存在的漏洞。”\n\n## 第三季：聚焦AI安全\n\n*   **推出背景**：随着生成式AI的广泛应用（麦肯锡报告显示，生成式AI使用率从2023年的33%增至2024年的71%），以及GitHub Copilot被超过77,000个组织使用，提升AI安全技能正当其时。\n*   **学习内容**：第三季包含六个现实挑战，难度递增，涵盖以下防御技术：\n    1.  **构建健壮的系统提示**：安全地设计引导模型行为的初始指令，确保输出安全、相关且符合预期。\n    2.  **输出验证**：通过验证输出是否符合预定义规则、格式或预期来防止信息泄露。\n    3.  **输入过滤**：在用户提供的文本输入模型之前进行检查、修改或阻止，以防止有害或不相关内容影响模型生成输出。\n    4.  **LLM自我验证**：利用大型语言模型（LLM）检查自身输出的准确性、一致性和合规性。\n\n## 游戏玩法\n\n*   玩家需“攻破”大型语言模型（LLM）。\n*   每个挑战始于LLM的一组指导指令（代码和系统消息），其中可能包含可被恶意提示利用的漏洞或边缘情况。\n*   **任务一**：识别漏洞，并精心设计提示来操纵模型，使其泄露隐藏的秘密。\n*   **任务二**：在保持代码功能的同时，完善代码和系统消息，以防止未来出现类似的恶意提示泄露。\n\n## 玩家感言\n\n*   Rajeev Mandalam（波音公司应用安全）： “我学会了发现漏洞，了解它们发生的位置和方式，并在将其发布到世界之前有效地纠正它们。我绝对会向任何人推荐这项培训，不仅是网络安全领域，也包括软件开发领域。”\n*   Reshmi Mehta（爱尔康安全分析师）： “一个主要收获是，关注细节很重要，因为它们常常会导致你意想不到的漏洞。在格式方面，我喜欢它不专注于某一种特定的编程语言，而是强调代码概念。我也喜欢游戏关卡之间切换的便捷性。这款游戏为我的职业生涯增添了很棒的新技能。”\n\n## 如何开始\n\n*   访问Secure Code Game GitHub仓库，其中包含所有季度的说明。\n\n## 第三季的诞生\n\n*   第三季由Bartosz Gałek（@bgalek）贡献，源于他在FOSDEM 2025上与Joseph Katsioloudes的交流。\n*   Bartosz创建的“HackMerlin”游戏（挑战玩家的提示工程技能）成为了第三季的基础。\n*   **游戏界面截图**：\n    ![游戏界面截图，显示了第6关的交互式游戏界面。游戏指示玩家通过巧妙提问来智取梅林，以揭示密码。顶部显示卡通巫师梅林，说着“你好，旅行者！问我任何问题……”。下方是一个文本框，用户可以在其中输入问题，一个“提问”按钮，以及一个标有“输入秘密密码”的字段，后面跟着一个“提交”按钮，用于检查答案的有效性。](https://github.blog/wp-content/uploads/2025/06/hackmerlin.png?resize=932%2C1240)\n*   **技术实现**：\n    *   从HackMerlin的UI中心方法转向安全代码游戏的“代码优先”方法，同时确保用户友好性是一个关键挑战。\n    *   Codespaces预配置了开发环境，并自动化了对GitHub Models的访问，后者提供了内置的LLM集成。\n    *   第三季通过遵循GitHub Models的默认安全防护措施来优先考虑真实性。\n\n## 参与贡献\n\n*   欢迎提出新挑战的想法，成为下一季的贡献者。\n\n## 立即体验\n\n*   立即开始游戏，释放你的创造力，迎接第三季的挑战！",
      "shortSummary": "GitHub发布了安全代码游戏第三季，专注于AI安全技能培训。这款免费课程让开发者通过在代码编辑器中实践，学习如何识别和修复大型语言模型（LLM）中的安全漏洞。内容涵盖构建健壮提示、输出验证、输入过滤和LLM自我验证等。游戏基于社区贡献，旨在帮助开发者应对日益增长的AI安全风险，提升其在AI时代的关键技能。",
      "translated_title": "攻破模型：通过GitHub安全代码游戏构建AI安全技能",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/06/hackmerlin.png?resize=932%2C1240",
          "alt": "Screenshot of an interactive game interface at Level 6. The game instructs the player to outsmart Merlin by asking clever questions to reveal a password. A cartoon wizard, Merlin, appears at the top, saying 'Hello traveler! Ask me anything...'. Below is a text box where the user can type questions, an 'Ask' button, and a field labeled 'Enter the secret password' followed by a 'Submit' button to check the validity of the answer.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://avatars.githubusercontent.com/u/31040295?v=4&s=200",
          "alt": "Joseph Katsioloudes",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2022/05/careers.svg",
          "alt": "Enterprise content",
          "title": "",
          "position": 6
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Dive into the novel security challenges AI introduces with the open source game  that over 10,000 developers have used to sharpen their skills.</p>\n<p>The post <a href=\"https://github.blog/security/hack-the-model-build-ai-security-skills-with-the-github-secure-code-game/\">Hack the model: Build AI security skills with the GitHub Secure Code Game</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-06-23T04:44:26.763Z"
}