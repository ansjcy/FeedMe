{
  "sourceUrl": "https://github.blog/feed/",
  "title": "The GitHub Blog",
  "description": "Updates, ideas, and inspiration from GitHub to help developers build and design software.",
  "link": "https://github.blog/",
  "items": [
    {
      "title": "如何使用 GitHub Copilot 提升代码审查和拉取请求的水平 (原标题: How to use GitHub Copilot to level up your code reviews and pull requests)",
      "link": "https://github.blog/ai-and-ml/github-copilot/how-to-use-github-copilot-to-level-up-your-code-reviews-and-pull-requests/",
      "pubDate": "Fri, 08 Aug 2025 16:00:00 +0000",
      "isoDate": "2025-08-08T16:00:00.000Z",
      "creator": "Melissa Pastore",
      "summary": "# 如何使用 GitHub Copilot 提升代码审查和拉取请求的水平\n\n作为 GitHub 的软件工程师，作者亲历了 GitHub Copilot 从简单的代码补全工具发展成为功能更强大的 AI 编码助手。其应用场景已扩展到日常工作的各个方面，包括拉取请求（Pull Requests, PRs）和代码审查。Copilot 在软件开发生命周期的这些关键环节中展现出极高的实用价值。\n\n## Copilot 在代码审查和拉取请求中的实际应用\n\n### 1. 代码审查中的 Copilot 建议\n\n在审查队友的拉取请求时，Copilot 能提供代码改进建议或确认代码是否遵循最佳实践，从而节省手动编写重构代码的时间。\n\n*   **代码重构**：当发现重复代码时，可以点击 Copilot 图标并提示其进行重构。例如，作者曾提示 Copilot 重构 Ruby on Rails 中的重复代码，Copilot 的建议与作者预期一致，节省了数分钟时间，使其能专注于更高层次的反馈。\n*   **最佳实践检查**：由于经常在 Ruby、TypeScript 和 Go 等不同语言之间切换上下文，作者会利用 Copilot 提醒特定语言的最佳实践。例如，通过提示 Copilot 检查 Go 代码是否遵循变量赋值的最佳实践，Copilot 迅速生成了可操作的改进建议。\n\n![GitHub Copilot 在 Go 语言代码审查中提供变量声明优化建议](https://github.blog/wp-content/uploads/2025/08/Screenshot-2025-07-09-at-4.31.23-PM.png?resize=1024%2C448)\n*图片描述：一张 GitHub 拉取请求的截图，展示了 Copilot 对 Go 语言文件中的代码进行审查，建议将 `var result int` 更改为更简洁的短变量声明 `result := add(1, 2)`。右侧的 Copilot 面板总结了更改并解释了建议的理由。*\n\n### 2. 为拉取请求格式化表格和数据\n\n为了给审阅者提供更多上下文，作者喜欢在拉取请求描述中添加图片、屏幕录像和电子表格。将这些信息格式化为 Markdown 表格通常很繁琐，此时 Copilot 可以代劳。\n\n*   **Markdown 表格生成**：作者曾将页面加载时间数据（前后对比）提供给 Copilot，并要求其格式化为 GitHub Flavored Markdown 表格。Copilot 迅速生成了清晰、易于粘贴的表格，极大地简化了数据共享。\n\n### 3. 让 Copilot 协助撰写拉取请求摘要\n\n撰写拉取请求描述往往是提交代码前的最后一道障碍。Copilot 可以通过在拉取请求描述编辑器栏中提供初始草稿来帮助启动这一过程，即使后续需要编辑，有一个起点也能减轻任务的难度。\n\n![GitHub Copilot 在拉取请求页面提供摘要生成选项](https://github.blog/wp-content/uploads/2025/08/Screenshot-2025-07-09-at-4.31.54-PM.png?resize=1024%2C438)\n*图片描述：一张 GitHub 拉取请求页面的截图，标题为“Test PR #1”，显示了对话选项卡。Copilot 菜单提供了生成摘要或拉取请求更改大纲的选项。*\n\n### 4. 利用 Copilot 进行代码自查和理解陌生代码\n\nCopilot 在审查和解释代码方面表现出色，作者将其应用于日常工作中的两个方面：\n\n*   **提交前自查**：在将拉取请求标记为“准备好审查”之前，作者会利用 Copilot 对自己的更改进行快速审查，它经常能发现作者可能遗漏的问题或提出更好的编写方式。用户还可以在仓库的自定义指令中添加注释，指导 Copilot 在审查拉取请求时关注的重点。\n*   **解释不熟悉的代码**：在审查他人代码时，如果遇到不理解的更改，作者会请 Copilot 解释。这有助于快速获取上下文，尤其是在不熟悉该部分代码库时，从而能为队友提供更周到、更彻底的审查。\n\n## Copilot 对代码审查和拉取请求的影响\n\n尽管 Copilot 无法替代深思熟虑的人工代码审查，但它已成为作者作为软件工程师日常工作中不可或缺的工具。从生成智能建议和代码重构，到快速 Markdown 格式化和起草拉取请求摘要，Copilot 通过使反馈更具操作性、代码审查过程更快更彻底，从而简化了围绕代码编写的工作。通过将 Copilot 整合到软件开发生命周期的每个阶段，作者能够专注于更高层次的工程问题和协作。",
      "shortSummary": "GitHub Copilot 已从代码补全发展为强大的AI工具，显著提升了代码审查和拉取请求的效率。它能提供代码重构和最佳实践建议，协助格式化PR描述中的数据表格，并帮助撰写PR摘要。此外，Copilot还能进行代码自查和解释不熟悉的代码，从而加快审查流程，使反馈更具操作性。Copilot 并非人工审查的替代品，但它简化了开发工作，让工程师能专注于更复杂的工程挑战。",
      "translated_title": "如何使用 GitHub Copilot 提升代码审查和拉取请求的水平",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/Screenshot-2025-07-09-at-4.31.23-PM.png?resize=1024%2C448",
          "alt": "Screenshot of a GitHub pull request for a Go file, suggesting a change to use the short variable declaration “result := add(1, 2)” instead of “var result int”. A Copilot panel on the right summarizes the changes and explains the reasoning behind the suggestion.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/08/Screenshot-2025-07-09-at-4.31.54-PM.png?resize=1024%2C438",
          "alt": "Screenshot of a GitHub pull request page titled \"Test PR #1\" showing the conversation tab, with a Copilot menu offering options to generate a summary or an outline of the pull request changes.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://avatars.githubusercontent.com/u/64283754?v=4&s=200",
          "alt": "Melissa Pastore",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 5
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 6
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 7
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Discover practical ways GitHub Copilot streamlines code reviews, pull requests, and daily engineering tasks with real prompts, examples, and workflow tips from our engineering team.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/how-to-use-github-copilot-to-level-up-your-code-reviews-and-pull-requests/\">How to use GitHub Copilot to level up your code reviews and pull requests</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "初级开发者并未过时：在AI时代如何蓬勃发展 (原标题: Junior developers aren’t obsolete: Here’s how to thrive in the age of AI)",
      "link": "https://github.blog/ai-and-ml/generative-ai/junior-developers-arent-obsolete-heres-how-to-thrive-in-the-age-of-ai/",
      "pubDate": "Thu, 07 Aug 2025 21:05:55 +0000",
      "isoDate": "2025-08-07T21:05:55.000Z",
      "creator": "Gwen Davis",
      "summary": "## 初级开发者在AI时代蓬勃发展\n\n### 引言：AI对初级开发者的影响与机遇\n\n人工智能（AI）正在深刻改变软件工程领域的工作方式。尽管2023年的一项研究预测，到2027年，初级应用开发者近26%的任务将被AI增强或完全自动化，但这并不意味着初级开发者会过时。相反，文章指出，新入行的学习者由于天生就熟悉AI工具，反而处于有利地位，能够更好地适应软件开发方式的变革。\n\nGitHub首席执行官Thomas Dohmke强调，实习生和初级开发者已经熟练掌握市场上最好的AI代码生成工具，他们与AI“产生共鸣”并用AI进行构建。罗汉普顿大学计算教育教授Miles Berry也认为，今天的学习者必须培养与AI协作的技能，而非担心被其取代。他强调，批判性思维、好奇心以及与AI和资深团队成员的协作至关重要，因为“创造力和好奇心是区分我们与机器的核心”。\n\n### 在AI时代脱颖而出的五种方法\n\n为了在AI时代作为初级开发者脱颖而出，文章提出了以下五种策略：\n\n1.  **利用AI加速学习，而非仅加速编码**\n    *   **将GitHub Copilot用作编程导师：** 大多数开发者使用Copilot进行自动补全，但初学者可以将其设置为强大的学习工具。通过设置个性化指令（例如，充当导师，教授概念和最佳实践，但不提供完整解决方案，并提醒检查AI生成内容的正确性），Copilot可以引导你理解概念。\n    *   **向Copilot提问：** 将Copilot Chat视为私人教练，询问它解释不熟悉的概念、调试步骤、分解复杂语法，或比较不同方法（如`for`循环与`map`），解释错误消息，或帮助编写测试用例。\n    *   **练习不依赖自动补全的问题解决：** 暂时关闭内联补全功能，以锻炼解决问题和批判性思维能力。你仍可使用Copilot Chat提问和获取帮助，但不会过早看到完整解决方案。这有助于在学习新概念时深入思考。\n\n2.  **构建展示技能（和AI熟练度）的公开项目**\n    *   个人项目是你的作品集，GitHub提供了展示和提升技能的平台。使用Copilot Chat的`/new`命令可以快速搭建新项目。\n    *   请求Copilot为项目添加MIT许可证并发布为GitHub上的公共项目。\n    *   通过问题、提交和项目看板跟踪进度，在README中记录旅程和里程碑，并通过反馈和AI协助进行迭代和改进。\n\n3.  **通过核心GitHub工作流提升开发者工具包**\n    *   尽管AI改变了游戏规则，但扎实的基础仍然是成功的关键。以下核心工作流是初级开发者晋升的跳板：\n        *   **使用GitHub Actions自动化：** 自动化构建和部署是所有开发者的最佳实践。利用GitHub Actions自动构建、测试和部署项目。\n        *   **贡献开源：** 加入全球开发者社区，通过贡献开源项目学习新技能、丰富简历并获得实际经验。\n        *   **通过拉取请求（Pull Requests）协作：** 编码是团队运动。练习专业团队使用的拉取请求工作流：审查他人代码、讨论反馈并自信地合并。\n    *   **AI辅助故障排除：** 在学习GitHub工作流时遇到问题（如YAML语法错误、权限问题、构建失败）是正常的。Copilot Chat可以帮助解释错误日志、调试YAML格式、指导配置认证、密钥或CI/CD步骤。\n\n4.  **通过代码审查提升专业技能**\n    *   从同行审查中学习是开发者成长最快的方式之一。每次拉取请求都是获取反馈的机会，不仅针对代码，也针对思维、沟通和协作方式。\n    *   **有效利用代码审查的技巧：** 提问以理解决策或探索替代方法；寻找重复出现的模式以内化最佳实践；记录收到的反馈和处理方式；保持谦逊，感谢并跟进。\n\n5.  **利用AI更智能、更快速地调试**\n    *   调试是软件开发中最耗时的部分之一。GitHub Copilot可以提供帮助：\n        *   询问“这个函数为什么会抛出错误？”以获得实时解释。\n        *   使用`/fix`高亮代码并生成潜在修复方案。\n        *   运行`/tests`创建测试用例并验证逻辑。\n        *   对晦涩的错误使用`/explain`来理解根本原因。\n        *   甚至可以组合命令进行深度调试（例如，`/explain`理解问题，`/fix`生成解决方案，`/doc`为团队编写文档）。\n\n### 更多资源与总结\n\n文章还推荐了GitHub Skills、GitHub Education和GitHub Copilot文档等资源，以帮助开发者成长。总而言之，无论你是第一次提交拉取请求还是在构建第五个副项目，GitHub都是磨练技能、开放协作和构建求职作品集的理想场所。AI正在重塑软件世界，但凭借正确的工具和心态，初级开发者完全可以蓬勃发展。",
      "shortSummary": "初级开发者在AI时代并非过时，反而因熟悉AI工具而拥有独特优势。文章提出五种策略助其蓬勃发展：利用AI加速学习（如将Copilot作导师）、构建展示AI技能的公开项目、掌握核心GitHub工作流（自动化、开源贡献、PR协作）、通过代码审查提升专业技能，以及利用AI更智能地调试。关键在于培养与AI协作的能力、批判性思维和好奇心。通过这些方法，初级开发者能有效适应行业变化，在AI时代取得成功。",
      "translated_title": "初级开发者并未过时：在AI时代如何蓬勃发展",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>The role of junior developer is evolving. If you're at this stage in your career, here's how to keep up and stand out.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/junior-developers-arent-obsolete-heres-how-to-thrive-in-the-age-of-ai/\">Junior developers aren’t obsolete: Here’s how to thrive in the age of AI</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用GitHub Models在Actions中自动化你的项目 (原标题: Automate your project with GitHub Models in Actions)",
      "link": "https://github.blog/ai-and-ml/generative-ai/automate-your-project-with-github-models-in-actions/",
      "pubDate": "Mon, 04 Aug 2025 16:00:00 +0000",
      "isoDate": "2025-08-04T16:00:00.000Z",
      "creator": "Kevin Lewis",
      "summary": "## 使用GitHub Models在Actions中自动化你的项目\n\nGitHub Models将人工智能（AI）引入GitHub Actions工作流，帮助您在项目所在位置自动化分类、总结等任务。本文探讨了三种集成和自动化使用GitHub Models的方法，从最直接到最强大。\n\n### 前置条件：添加正确的权限\n\n在使用GitHub Models之前，您的工作流需要获得访问AI模型的权限。在工作流的权限块中添加以下行即可：\n\n```yaml\npermissions:\n  contents: read\n  issues: write\n  models: read\n```\n\n这些权限允许工作流读取仓库内容、读写问题和评论，最重要的是，启用对GitHub Models的访问。\n\n### 示例一：在Bug报告中请求更多信息\n\n此示例展示了如何使用AI推理操作以及如何利用AI创建分支逻辑，以自动化处理信息不足的Bug报告。\n\n*   **目标**：自动检查新的Bug报告是否包含足够信息，并在信息不足时自动回复。\n*   **工具**：`actions/ai-inference` 操作，允许调用领先的AI模型来分析或生成文本。\n*   **工作流 (`bug-reproduction-instructions.yml`) 设置**：\n    *   **触发器**：当新问题被打开时 (`on: issues: types: [opened]`)。\n    *   **权限**：`contents: read`, `issues: write`, `models: read`。\n    *   **步骤**：\n        1.  **获取问题**：使用`actions/github-script`获取问题的标题和正文。\n        2.  **分析问题以进行复现**：\n            *   仅当问题标记为“bug”时执行 (`if: contains(..., 'bug')`)。\n            *   使用`actions/ai-inference@v1`，配置`mistral-ai/ministral-3b`模型（可替换为GitHub Models目录中的40多种模型）。\n            *   `system-prompt`定义了有效复现说明的特征（复现步骤、预期/实际行为、环境细节）。如果信息足够，AI返回“pass”；否则，返回缺失信息的简要描述。\n        3.  **评论问题**：\n            *   仅当问题标记为“bug”且AI返回的值不是“pass”时执行。\n            *   使用`actions/github-script@v7`将AI的回复作为评论发布到问题中。\n*   **核心思想**：通过提示AI模型在满足特定条件时返回固定字符串（如“pass”），可以在工作流中创建AI驱动的条件逻辑。\n\n![An issue on GitHub named \"Doesn't work on firefox\" with no description and a bug label. The github-actions bot responds asking for more information - specifically reproduction steps, expected and actual behavior, and browser and operating system details.](https://github.blog/wp-content/uploads/2025/07/image1_5f1e88.png?resize=1024%2C755)\n\n### 示例二：从合并的拉取请求创建发布说明\n\n此示例展示了如何使用`gh CLI`与`gh-models`扩展来自动化发布说明的生成。\n\n*   **目标**：当拉取请求合并时，自动汇总其内容并添加到发布说明问题中。\n*   **工具**：`gh CLI`及`gh-models`扩展。\n*   **设置**：创建一个名为“release”的标签，并创建一个名为“Publish next release changelog”的问题，并为其添加“release”标签。\n*   **工作流 (`release-notes.yml`) 设置**：\n    *   **触发器**：当拉取请求关闭时 (`on: pull_request: types: [closed]`)。\n    *   **条件**：仅当拉取请求已合并时运行 (`if: github.event.pull_request.merged == true`)。\n    *   **权限**：`pull-requests: read`, `issues: write`, `contents: read`, `models: read`。\n    *   **步骤**：\n        1.  **检出仓库**：使用`actions/checkout@v4`。\n        2.  **安装gh-models扩展**：运行`gh extension install https://github.com/github/gh-models`，需要工作流令牌。\n        3.  **汇总拉取请求并追加到发布问题**：\n            *   使用`gh pr view`获取PR的标题、正文、评论和评审信息，并保存到文件。\n            *   将PR数据通过管道传递给`gh models run xai/grok-3-mini`，并提供一个提示，要求生成一个简洁的单行变更日志条目。\n            *   获取带有“release”标签的发布问题编号和当前正文。\n            *   将AI生成的摘要（包含PR编号）追加到发布问题正文。\n            *   使用`gh issue edit`更新发布问题。\n\n![A pull request named Publish Next Release Changelog. The description has two bullet list items - each one describing a change in 8-12 words with a link to the merged pull request.](https://github.blog/wp-content/uploads/2025/07/image2_f6eb85.png?resize=1024%2C438)\n\n### 示例三：汇总和优先排序问题\n\n此示例演示了如何使用`GitHub CLI`、`gh-models`扩展和提示文件来自动化更复杂的定时工作流，以每周汇总、主题化和优先排序新问题。\n\n*   **目标**：每周生成一个问题，汇总、主题化并优先排序过去一周新打开的问题。\n*   **工具**：`gh CLI`、`gh-models`扩展和独立的提示文件。\n*   **工作流 (`weekly-issue-summary.yml`) 设置**：\n    *   **触发器**：手动触发 (`workflow_dispatch`) 或每周一上午9点定时触发 (`schedule: - cron: '0 9 * * 1'`)。\n    *   **权限**：`issues: write`, `contents: read`, `models: read`。\n    *   **步骤**：\n        1.  **检出仓库**：使用`actions/checkout@v4`。\n        2.  **安装gh-models扩展**：运行`gh extension install https://github.com/github/gh-models`。\n        3.  **获取过去一周的问题并汇总**：\n            *   使用`gh search issues`获取过去一周内创建的开放问题（标题、正文、URL），并保存到文件。\n            *   将问题数据通过管道传递给`gh models run --file prompts/issue-summary.prompt.yml`。\n        4.  **提示文件 (`prompts/issue-summary.prompt.yml`)**：\n            *   定义模型（如`openai/gpt-4.1`）、系统和用户提示。\n            *   系统提示：“你是一个有用的问题汇总器。”\n            *   用户提示：“请将以下问题总结为几个简短的要点。如果提供链接，请包含。如果可能，提取一般主题并帮助团队根据影响进行优先排序。”\n            *   使用`{{input}}`占位符接收管道数据。\n            *   优势：通过`.prompt.yml`文件，可以利用GitHub Models的仓库集成，通过丰富的UI迭代提示。\n        5.  **创建问题**：使用`gh issue create`创建新问题，标题包含日期范围，并使用AI生成的摘要作为正文。\n\n![An issue with the title \"Issue Summary - June 16 to June 23\". It has three sections - an issue summary which details and links each issue that has been opened, general themes which contains three groupings for the issues, and suggested prioritization. The top issue is on data integrity - issue 37.](https://github.blog/wp-content/uploads/2025/07/image3_6c2c47.png?resize=972%2C1024)\n\n### 总结\n\n无论是从简单的AI推理操作开始，使用带有内联提示的`gh-models CLI`，还是创建功能齐全、提示驱动的工作流，GitHub Models都使您能够轻松地通过AI扩展您的项目流程。只需添加正确的权限，选择一个上述示例，即可在您的下一个工作流中尝试GitHub Models。",
      "shortSummary": "GitHub Models将AI集成到GitHub Actions，实现项目自动化。通过设置特定权限，用户可利用AI处理任务。文章展示了三种应用：一是使用`actions/ai-inference`自动请求Bug报告补充信息；二是利用`gh CLI`和`gh-models`从PR生成发布说明；三是结合定时任务和提示文件，每周汇总并优先排序新问题。这些方法使开发者能更高效地管理项目，简化工作流程。",
      "translated_title": "使用GitHub Models在Actions中自动化你的项目",
      "images": [
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/image1_5f1e88.png?resize=1024%2C755",
          "alt": "An issue on GitHub named \"Doesn't work on firefox\" with no description and a bug label. The github-actions bot responds asking for more information - specifically reproduction steps, expected and actual behavior, and browser and operating system details.",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/image2_f6eb85.png?resize=1024%2C438",
          "alt": "A pull request named Publish Next Release Changelog. The description has two bullet list items - each one describing a change in 8-12 words with a link to the merged pull request.",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2025/07/image3_6c2c47.png?resize=972%2C1024",
          "alt": "An issue with the title \"Issue Summary - June 16 to June 23\". It has three sections - an issue summary which details and links each issue that has been opened, general themes which contains three groupings for the issues, and suggested prioritization. The top issue is on data integrity - issue 37.",
          "title": "",
          "position": 3
        },
        {
          "url": "https://avatars.githubusercontent.com/u/1461554?v=4&s=200",
          "alt": "Kevin Lewis",
          "title": "",
          "position": 4
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Learn how to integrate AI features with GitHub Models directly in GitHub Actions workflows.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/automate-your-project-with-github-models-in-actions/\">Automate your project with GitHub Models in Actions</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "入职你的AI结对程序员：成功设置GitHub Copilot编码代理 (原标题: Onboarding your AI peer programmer: Setting up GitHub Copilot coding agent for success)",
      "link": "https://github.blog/ai-and-ml/github-copilot/onboarding-your-ai-peer-programmer-setting-up-github-copilot-coding-agent-for-success/",
      "pubDate": "Thu, 31 Jul 2025 17:12:43 +0000",
      "isoDate": "2025-07-31T17:12:43.000Z",
      "creator": "Christopher Harrison",
      "summary": "## 入职你的AI结对程序员：成功设置GitHub Copilot编码代理\n\nGitHub Copilot被定位为AI结对程序员或团队中的AI成员，其编码代理（coding agent）功能能够自主处理问题并提出解决方案。要确保Copilot编码代理的成功，需要进行类似于新开发人员入职的配置和优化。\n\n### GitHub Copilot中的代理工作流：编码代理 vs. 代理模式\n\nGitHub Copilot提供两种核心代理能力：\n\n*   **编码代理 (Coding Agent)**：一个自主工具。你向Copilot分配一个问题，它会在后台启动Actions容器，迭代工作，并最终返回一个拉取请求（PR）。这是一种异步的、面向拉取请求的交互模式。\n*   **代理模式 (Agent Mode)**：一个交互式助手。它在编辑器或github.com上实时执行较小的、多步骤的任务。这是一种对话式的、即时的交互模式。\n\n### Copilot编码代理的工作流程：从问题到可审查的拉取请求\n\n当一个问题被分配给Copilot时，它会遵循以下模式：\n\n1.  为将要创建的代码创建一个分支。\n2.  创建一个拉取请求来跟踪其工作并与团队沟通。\n3.  为其工作创建一个受限环境（在GitHub Actions内部运行）。\n4.  阅读问题或提示以理解请求的任务。\n5.  探索项目以确定解决问题的最佳方法。\n6.  迭代地朝着解决方案工作。\n7.  完成工作，更新拉取请求，并通知团队拉取请求已准备好审查。\n\n理解这个流程有助于我们确保Copilot的成功。\n\n### 使用GitHub Actions配置Copilot的环境\n\n为了让Copilot高效工作，它需要访问团队使用的所有工具、服务、库和框架。这可以通过自定义工作流文件来实现：\n\n*   **工作原理**：编码代理在GitHub Actions中运行的容器内工作。你可以利用Actions的YAML配置能力来确保容器正确设置。\n*   **配置步骤**：\n    *   在`.github/workflows/copilot-setup-steps.yml`路径下创建一个名为`copilot-setup-steps`的作业。\n    *   在该作业中列出安装环境所需的所有步骤（例如，安装Python和SQLite依赖）。\n    *   每次将问题分配给Copilot时，它都会运行此工作流来配置其环境。\n*   **专业提示**：可以重用现有的用于开发环境（如运行测试或验证脚本）的工作流。\n*   **重要提示**：如果某些操作应以特定方式完成，请明确告知Copilot，避免其自行推断导致意外版本或错误。\n\n### 通过精心编写的问题和提示设置Copilot的成功\n\n问题或提示是Copilot创建拉取请求的入口点。问题定义越清晰，拉取请求的质量就越高。一个好的问题应包含：\n\n*   清晰定义的问题陈述或用户故事。\n*   如果是bug，提供完整的错误信息、堆栈跟踪、输出以及重现步骤。\n*   任何相关的历史或之前尝试过的方法。\n*   关于如何处理问题的建议。\n\n**示例**：一个将测试从unittest迁移到pytest的良好问题描述，详细说明了需求、现有资源和推荐方法。\n\n### 使你的仓库受欢迎（对开发者和AI）\n\n优化项目结构和文档对Copilot和新入职的开发者同样重要。Copilot在处理问题时会探索代码库，查找README文件并阅读文档，然后进行代码库搜索。\n\n*   **优化内容**：\n    *   拥有健壮且最新的项目和服务README文件。\n    *   代码中包含描述操作的注释。\n    *   遵循良好的命名规范（类、函数、变量）。\n    *   逻辑化的项目结构，遵循文件夹名称和实体分组的最佳实践。\n*   **专业提示**：通过查看Copilot创建的PR中的“View session”按钮，你可以了解Copilot的工作方式，从而进一步优化任务分配和环境配置。\n\n### 使用Copilot自定义指令记录机构知识\n\n自定义指令是指导Copilot的最佳方式，它们可以包含代码格式规则或团队“固有”但未书面记录的机构知识。Copilot编码代理支持两种类型的指令文件：\n\n1.  **仓库级指令文件 (`copilot-instructions.md`)**：\n    *   存储在代码库的`.github/copilot-instructions.md`中。\n    *   适用于所有请求。\n    *   应包含：项目概览、构建方式、用户故事、使用的框架和库、项目结构、全局编码指南和规则。\n    *   **示例**：一个关于经典街机项目的指令文件，包含标准玩家流程、框架、编码指南和项目结构。\n\n2.  **目标指令文件 (`.instructions.md`)**：\n    *   存储在代码库的`.github/instructions/`文件夹（或其子文件夹）中。\n    *   可以通过`applyTo`部分设置glob模式，以指定规则适用的文件类型（例如，`**/games/*.py`）。\n    *   包含特定于这些文件的指令，如继承的基类和测试要求。\n    *   **示例**：一个针对游戏文件的指令文件，要求所有游戏继承自`BaseGame`，并包含单元测试要求。",
      "shortSummary": "本文介绍了如何成功设置和使用GitHub Copilot编码代理。关键在于通过GitHub Actions配置其运行环境，编写清晰详细的问题和提示以指导其工作，优化项目结构和文档以提高其理解效率。此外，利用仓库级和目标文件级的自定义指令，可以向Copilot传达编码规范和机构知识，确保其生成的代码符合团队标准，从而使其成为高效的AI结对程序员。",
      "translated_title": "入职你的AI结对程序员：成功设置GitHub Copilot编码代理",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Learn how to configure Copilot coding agent’s environment, optimize project structure, use custom instructions, and extend its capabilities with MCP servers.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/github-copilot/onboarding-your-ai-peer-programmer-setting-up-github-copilot-coding-agent-for-success/\">Onboarding your AI peer programmer: Setting up GitHub Copilot coding agent for success</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "GitHub MCP 服务器实用指南 (原标题: A practical guide on how to use the GitHub MCP server)",
      "link": "https://github.blog/ai-and-ml/generative-ai/a-practical-guide-on-how-to-use-the-github-mcp-server/",
      "pubDate": "Wed, 30 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-30T16:00:00.000Z",
      "creator": "Andrea Griffiths",
      "summary": "# GitHub MCP 服务器实用指南\n\n本文提供了一份关于如何从本地 Docker 镜像升级到 GitHub 托管的 Model Context Protocol (MCP) 服务器的实用指南，旨在帮助用户自动化拉取请求、持续集成和安全分类等任务，且无需令牌。\n\n## GitHub MCP 服务器简介\n\n本地运行 MCP 服务器虽然可行，但管理 Docker、轮换访问令牌和拉取更新等操作繁琐。GitHub 托管的 MCP 端点消除了这些基础设施的烦恼，让开发者能够专注于代码交付。本教程将引导用户从本地 MCP 设置升级到 GitHub 托管端点，从而获得 OAuth 认证、自动更新以及访问更丰富的 AI 工作流所需的工具集。用户还将学习如何通过只读模式自定义工具访问、通过动态工具集简化 AI 工作流，并为使用 GitHub Copilot 进行代理间协作做好准备。\n\nGitHub 远程 MCP 服务器是 GitHub 完全托管、始终保持最新状态的 MCP 实现。用户只需将 IDE 或代理主机指向 `https://api.githubcopilot.com/mcp/`，并通过 OAuth 进行一次性认证，GitHub 将处理其余所有事务。\n\n### 默认启用的工具集（可禁用）\n\n*   **代码库智能：** 无需本地克隆即可搜索代码、流式传输文件和打开拉取请求。\n*   **问题和拉取请求自动化：** 从单个代理提示中归档、分类、标记、审查甚至合并。\n*   **CI/CD 可见性：** 在聊天中检查工作流运行、获取日志并重新运行失败的作业。\n*   **安全洞察：** 发现代码扫描和 Dependabot 警报，确保在漏洞被利用前修复。\n*   **细粒度控制：** 切换特定工具集或将服务器设置为只读模式以提高安全性。\n\n## 为什么选择托管 MCP 服务器？\n\n本地开源 MCP 服务器虽然可用，但存在隐性成本。以下是切换到远程托管服务器后的变化：\n\n| 特性           | 本地 Docker 服务器          | 托管 MCP 端点                   |\n| :------------- | :-------------------------- | :------------------------------ |\n| 维护与升级     | 手动维护 Docker 镜像，手动升级 | GitHub 自动修补和升级           |\n| 认证           | 管理个人访问令牌 (PATs)     | 通过 OAuth 一次性登录，范围自动处理 |\n| 可访问性       | 仅在 localhost 上暴露服务器 | 可从任何 IDE 或远程开发环境访问   |\n| 写入权限       | 除非自定义二进制文件，否则完全写入权限 | 内置只读开关和按工具集标志控制    |\n\n对于大多数团队而言，托管服务器消除了基础设施工作，使团队能够专注于自动化。但如果需要气隙环境，仍需坚持使用本地设置。\n\n## 开始前的准备\n\n*   GitHub Copilot 或 Copilot Enterprise 席位\n*   VS Code 1.92+（或其他支持 MCP 的客户端）\n*   网络访问 `https://api.githubcopilot.com`\n*   一个用于实验的测试仓库\n\n## 步骤 1：安装远程 MCP 服务器\n\n与基于本地 Docker 的安装相比，设置 GitHub 远程 MCP 服务器非常简单。它由 GitHub 托管，无需管理 Docker 容器或手动处理更新，提供简化的云原生体验。\n\n### 在 VS Code 或 VS Code Insiders 上安装：\n\n1.  打开命令面板并运行：`> GitHub MCP: Install Remote Server`\n2.  完成 OAuth 流程以连接您的 GitHub 账户。\n3.  重启服务器以完成设置。\n\n### 对于任何其他客户端：\n\n1.  将服务器 URL 设置为：`https://api.githubcopilot.com/mcp/`\n2.  在提示时进行认证。\n\n### 验证连接：\n\n使用 `curl -I https://api.githubcopilot.com/mcp/healthz` 进行快速检查。如果看到 `HTTP/1.1 200 OK`，则表示连接成功。安装后，远程服务器将取代本地服务器，无需 Docker 或令牌，只需简单的集成。\n\n## 步骤 2：配置访问控制\n\n### 使用只读模式进行安全探索\n\n在敏感环境、生产测试或向利益相关者演示时，可以将服务器切换到只读模式：\n\n```json\n{\n  \"servers\": {\n    \"github\": {\n      \"type\": \"http\",\n      \"url\": \"https://api.githubcopilot.com/mcp/\",\n      \"mode\": \"read-only\"\n    }\n  }\n}\n```\n\n在此模式下，代理可以读取问题、拉取请求和代码，但无法推送更改。这非常适合需要上下文而无风险的代码审查。\n\n**用例：拉取请求查看器**\n无需修改任何内容即可审查拉取请求。此设置提供安全的只读访问，非常适合浏览更改、留下评论或收集上下文，而不会有更改代码的风险。\n\n1.  访问 GitHub MCP 服务器仓库。\n2.  导航到“Remote Server”部分。\n3.  选择拉取请求只读变体。\n4.  点击“Install Read Only”。\n\n您将看到 `listPullRequests`、`getPullRequest` 和 `searchPullRequests` 等工具，但没有写入权限。由于这些工具不进行更改，VS Code 会跳过权限提示，提供无缝体验。\n\n### 通过选择性工具集限制范围\n\n通过以下命令仅暴露所需的工具，使开发人员和代理都保持专注：\n\n```json\n\"toolsets\": [\"context\", \"issues\", \"pull_requests\"]\n```\n\n将此数组添加到 `mode` 字段旁边即可隐藏其他所有内容。\n\n## 步骤 3：通过三个实践示例进行尝试\n\n这些实际示例展示了 Copilot 代理模式如何在实践中处理日常开发任务，如管理拉取请求、调试工作流和分类安全警报，而无需本地设置或手动挖掘。只需提示即可。\n\n### 示例 1：添加 CODEOWNERS 文件并打开拉取请求\n\n打开您的仓库，然后询问 Copilot 代理：\n提示：“为 `/api/**` 添加一个 CODEOWNERS 文件，分配给 `@backend-team`，然后打开一个草稿拉取请求。”\n\n代理将：\n*   使用 `repos.create_file` 添加 CODEOWNERS 文件。\n*   调用 `pull_requests.open` 创建拉取请求。\n*   执行 `pull_requests.request_reviewers` 分配审阅者。\n\n无需本地克隆，无需手动创建文件。只需提示即可完成。\n\n### 示例 2：调试失败的工作流\n\n提示：“昨晚 `release.yml` 作业为什么失败了？”\n代理将使用 `actions.get_workflow_run_logs` 拉取日志，分析堆栈跟踪，并建议修复方案。这就像有一位高级工程师审查您的 CI/CD 故障。\n\n### 示例 3：分类安全警报\n\n提示：“列出我所有仓库中的关键 Dependabot 警报，并为每个警报创建问题。”\n服务器将通过 `dependabot.list_dependabot_alerts` 返回警报，然后代理仅在需要时创建有针对性的问题。\n\n## 步骤 4：GitHub 远程 MCP 服务器故障排除技巧\n\n| 症状             | 可能原因                   | 修复方法                               |\n| :--------------- | :------------------------- | :------------------------------------- |\n| 安装时 401 Unauthorized | 遗留的 `GITHUB_TOKEN` 环境变量 | 取消设置该变量并重新运行 OAuth 流程    |\n| 工具不显示       | 企业代理阻止 `api.githubcopilot.com` | 添加代理设置或将该域列入白名单         |\n| 模型超时         | 启用了大型工具集           | 仅限于所需的工具集                     |\n\n## 步骤 5：使用动态工具集简化工作流\n\n完整的 MCP 服务器包含 70 多个工具，虽然功能强大，但这可能会让您和 AI 模型感到不知所措。这就是动态工具集的用武之地。\n\n**工作原理：**\n大型语言模型 (LLM) 最初只包含少量元工具：`listAvailableToolsets`、`enableToolset` 和 `getToolsetTools`。它会根据手头的任务（例如“处理拉取请求”）确定所需工具，然后仅获取并启用这些工具。VS Code 会通过工具更改通知自动加载它们。这使得您的界面（和您的 AI）保持专注和高效。\n\n## 步骤 6：安全和代理工作流的下一步发展\n\nGitHub MCP 服务器正在积极发展。以下是即将推出的功能：\n\n### MCP 中的秘密扫描\n\n很快，MCP 服务器将能够检测并阻止 AI 生成的秘密，就像 GitHub 阻止您在拉取请求中推送秘密一样。如果需要，您可以覆盖，但默认设置会保护您的数据，无论是来自提示注入还是意外情况。\n\n### 将问题分配给 Copilot\n\n与 Copilot 编码代理的直接集成意味着您将能够：\n*   将问题直接分配给 Copilot。\n*   从 VS Code 触发完成。\n*   观察代理间工作流在不同工具之间展开。\n\n未来是代理与代理之间的协作，而 GitHub MCP 是其基础。\n\n## 贡献与总结\n\nGitHub MCP 项目是完全开源的，并且发展迅速。欢迎：\n*   **探索仓库：** 了解工具的构建方式并贡献您自己的工具。\n*   **提交问题：** 帮助塑造协议和工具。\n*   **加入讨论：** 在 GitHub 和 Discord 上与其他构建者联系。\n\n无论您是构建工具、提供反馈还是探索 AI 驱动的开发，MCP 生态系统都有您的位置。\n\nGitHub 远程 MCP 服务器消除了基础设施开销，让您能够专注于构建更好的自动化。不再需要管理 Docker，不再需要轮换令牌，只需一次 OAuth 认证即可开始交付。记住：最好的基础设施是您无需管理的基础设施。\n\n阅读完整的文档以开始使用，或深入研究上述示例并立即开始实验。",
      "shortSummary": "GitHub MCP 服务器提供托管服务，简化AI工作流。它替代了本地Docker设置，消除了令牌管理和手动更新的繁琐。通过OAuth认证，用户可获得自动更新和丰富的AI工具集，支持代码库智能、PR自动化、CI/CD可见性及安全洞察。该服务提供只读模式和动态工具集等细粒度控制。未来将集成AI生成秘密扫描和Copilot代理间协作，旨在实现代理间的无缝协作，让开发者专注于代码交付。",
      "translated_title": "GitHub MCP 服务器实用指南",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Upgrade from a local MCP Docker image to GitHub’s hosted server and automate pull requests, continuous integration, and security triage in minutes — no tokens required.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/a-practical-guide-on-how-to-use-the-github-mcp-server/\">A practical guide on how to use the GitHub MCP server</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "从首次提交到大型项目：收听我们的全新开源播客 (原标题: From first commits to big ships: Tune into our new open source podcast)",
      "link": "https://github.blog/open-source/maintainers/from-first-commits-to-big-ships-tune-into-our-new-open-source-podcast/",
      "pubDate": "Tue, 29 Jul 2025 16:31:29 +0000",
      "isoDate": "2025-07-29T16:31:29.000Z",
      "creator": "Abigail Cabunoc Mayes",
      "summary": "# GitHub推出全新开源播客：从首次提交到大型项目\n\nGitHub隆重推出全新播客，旨在深入探讨开源世界的运作机制，以及为何如此多的人持续投入其中共同建设。播客将深入挖掘代码背后的故事：塑造开源生态系统的项目、人物和理念。\n\n## 播客宗旨与GitHub愿景\nGitHub认为开源一直是未来创新的启动平台。尤其在2025年，软件领域的一切新事物，从AI代理到边缘运行时再到气候技术仪表板，都始于公共仓库，任何人都可以轻松地进行分叉、重混和改进。投资开源公共领域，不仅是赞助代码，更是为全球的研发引擎提供支持。播客将围绕这一核心理念，探索构成当今开源的一切要素。\n\n## 核心贡献者团队\n播客由一支由资深开源贡献者组成的轮值主持团队共同呈现，包括：\n*   **Cassidy Williams**\n*   **Kedasha Kerr**\n*   **Andrea Griffiths**\n*   **Abby Cabunoc Mayes** (本文作者)\n\n他们都对开源世界的不同领域做出了长期贡献。团队将共同探讨当前开源领域中令人兴奋、充满挑战和不断演变的话题，涵盖社区建设、开放科学、开发者教育以及公开构建等。每位主持人都会为对话带来独特的视角。\n\n## 首期节目亮点\n在首期节目中，主持人团队进行了自我介绍，分享了他们如何参与到开源中，以及是什么让他们坚持不懈。\n*   Kedasha讨论了在看似充斥着初学者开发者内容的今天，创建初学者内容的重要性。\n*   Cassidy分享了她十几岁时偶然听到的一段对话如何激发了她对代码的热爱。\n\n节目还特别介绍了本周引起他们关注的一些优秀开源项目：\n*   **Anime.JS**：一个视觉效果惊艳的JavaScript动画库，激发创造力。\n*   **Docs**：由法国和德国政府开发的协作式开源文档编辑器。\n*   **CSS Zero**：一个无需构建的前端启动套件，简化了Web开发。\n\n## 播客内容与未来展望\n播客将每两周更新一期，分享来自开源生态系统中的维护者、贡献者和构建者的故事。内容将涵盖工具、标准以及那些带来乐趣（有时也带来混乱）的副项目。\n\n听众还将听到特邀嘉宾的分享，例如：\n*   **Jason Lengstorf**：为开发者制作电视节目。\n*   **Keeley Hammond**：Electron的核心维护者。\n\n他们将分享各自的旅程和见解。无论您是刚刚入门，还是已经维护项目多年，播客都将为您提供有价值的内容。\n\n## 即将推出\n下一期节目将深入探讨**模型上下文协议（Model Context Protocol, MCP）**：\n*   它是什么？\n*   为什么它很重要？\n*   它如何帮助提高AI工具的透明度和互操作性？\n\n节目将探索MCP如何建立在开放标准的悠久历史之上，以及它为当今开发者解锁了哪些可能性。\n\n## 作者与相关资源\n本文由 **Abigail Cabunoc Mayes** 撰写。\n![Abigail Cabunoc Mayes](https://avatars.githubusercontent.com/u/617994?v=4&s=200)\nAbigail Cabunoc Mayes 在 GitHub 工作，致力于帮助开源生态系统在当下和未来蓬勃发展。\n\n**相关文章与资源：**\n*   **我们需要一个欧洲主权技术基金**：探讨开源软件作为关键基础设施却资金不足的问题，以及GitHub开发者政策团队如何建立联盟以弥补维护资金缺口。\n*   **Docs**：掌握GitHub所需的一切，一站式获取。\n    ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg)\n    [前往Docs](https://docs.github.com/)\n*   **GitHub**：在GitHub上构建未来，这里是任何人、任何地点、构建任何事物的平台。\n    ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg)\n    [开始构建](https://github.com/)\n*   **客户案例**：了解使用GitHub进行构建的公司和工程团队。\n    ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg)\n    [了解更多](https://github.com/customer-stories)\n*   **GitHub Universe 2025**：最后机会：节省700美元购买Universe现场通行证，于10月28-29日在旧金山加入我们。\n    ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg)\n    [立即注册](https://github.com/universe)",
      "shortSummary": "GitHub推出全新开源播客，探讨开源生态系统的故事、人物和理念。播客由多位资深开源贡献者轮流主持，每两周更新一期。内容涵盖社区建设、开发者教育和精选开源项目（如Anime.JS、Docs、CSS Zero）。未来将邀请特邀嘉宾并深入探讨Model Context Protocol等前沿话题。播客旨在为开源社区提供洞察和灵感，无论初学者还是资深维护者都能从中受益。",
      "translated_title": "从首次提交到大型项目：收听我们的全新开源播客",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/617994?v=4&s=200",
          "alt": "Abigail Cabunoc Mayes",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Introducing the brand new GitHub Podcast: A show dedicated to the topics, trends, stories, and culture in and around the open source developer community on GitHub.</p>\n<p>The post <a href=\"https://github.blog/open-source/maintainers/from-first-commits-to-big-ships-tune-into-our-new-open-source-podcast/\">From first commits to big ships: Tune into our new open source podcast</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "扩大影响力：GitHub Copilot 如何赋能小农户 (原标题: Scaling for impact: How GitHub Copilot supercharges smallholder farmers)",
      "link": "https://github.blog/open-source/social-impact/scaling-for-impact-how-github-copilot-supercharges-smallholder-farmers/",
      "pubDate": "Mon, 28 Jul 2025 19:53:32 +0000",
      "isoDate": "2025-07-28T19:53:32.000Z",
      "creator": "Paull Young",
      "summary": "## One Acre Fund 简介与使命\n\nOne Acre Fund 始于 2006 年肯尼亚西部的 40 个农户家庭，现已发展成为一项强大的运动。如今，该组织在东非和南部非洲的十个国家为 500 万农户家庭提供服务。他们的宏伟目标是到 2030 年每年支持 1000 万农户家庭，并通过利用开源技术和人工智能，为这些社区创造惊人的 10 亿美元新收入。\n\n### 科技赋能农业\n\n对于小农户（通常耕作一英亩或更少土地的农民）而言，集约化农业对其繁荣至关重要。这种在相同土地上生产更多食物的过程，不仅能带来更高的作物产量，还能刺激经济、加强社区并帮助农民扩大规模。One Acre Fund 的核心使命是赋能这些农民，为他们提供一条摆脱贫困的直接途径。与传统小额信贷不同，他们不只提供现金贷款，而是直接提供重要的农业资源，如化肥和种子，以及培训和服务，为农民提供成功所需的工具。他们还帮助农民改善土壤健康和种植树木，不仅提高产量，还能帮助农民更好地应对气候变化带来的天气变化。\n\n> “过去，农民害怕使用技术。但随着我们为他们提供培训，他们现在渴望使用它。”\n> — Blaise Murame，One Acre Fund 区域负责人\n\n技术是 One Acre Fund 快速增长的核心。他们已从完全模拟的方法（在田间使用纸质记录与农民会面）转变为高度数字化的系统。这一转变彻底改变了他们的运营，使从物流和交付到农民注册以及培训材料开发的一切都变得更加高效。农民最初犹豫不决，但在及时获得资源和工具并比以往更快地实现目标后，现在渴望拥抱这项技术。\n\n## GitHub Copilot 的赋能作用\n\nOne Acre Fund 技术飞跃的一个重要部分来自于他们对 GitHub Copilot 的采用。\n\n> “自从 GitHub Copilot 问世以来，我们过去需要三周的开发工作现在可以在一周内完成。这影响了我们的目标——我们能够设定比去年更多的目标。”\n> — Yididiya Gebredingel，One Acre Fund 开发人员\n\n通过引入 GitHub Copilot，One Acre Fund 能够更快地推进开发，并专注于真正在实地产生影响的部分。这种加速使他们能够设定并实现更多目标，开发人员完成项目的速度提高了三倍，超过 30% 的工作由 AI 辅助完成。\n\n## 开源技术的重要性\n\n作为一个非营利组织，与世界上最贫困的人群打交道意味着在微薄的利润下运营。这使得其解决方案的成本效益至关重要。开源技术提供了理想的平衡，既提供了“解决方案的成熟度，又提供了解决方案的灵活性”，同时避免了随着规模扩大而呈指数级增长的许可费用负担。拥抱开源社区是 One Acre Fund 的一项战略举措，他们已将其大部分核心运营系统迁移到开源，以利用协作开发和社区支持。\n\n> “作为一个非营利组织，我们无法承受随着规模扩大而呈指数级增长的许可费用。开源为我们提供了解决方案成熟度和解决方案灵活性之间的正确平衡。”\n> — Sarah Hylden，One Acre Fund 全球运营总监\n\n## 总结与展望\n\n最终，One Acre Fund 相信，如果你有一个行之有效的干预措施，可以为农民创造可持续的脱贫之路，并且你知道它有效，那么你就有道德义务去扩大它的规模。在 GitHub Copilot 的帮助下，他们正在这样做——更快地行动，对数百万农户家庭的生活产生更大的影响。\n\n### 相关资源\n\n*   ![Paull Young](https://avatars.githubusercontent.com/u/157849754?v=4&s=200)\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切，尽在一处。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来，这里是任何人、任何地方构建任何东西的平台。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) 客户案例：了解使用 GitHub 进行构建的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：最后机会：节省 700 美元购买 Universe 现场通行证，于 10 月 28-29 日在旧金山与我们相聚。",
      "shortSummary": "One Acre Fund 是一家非营利组织，通过提供农资、培训和技术，帮助非洲小农户摆脱贫困。他们采用 GitHub Copilot 和开源技术，显著加速了软件开发，将项目完成速度提升三倍，并有效控制了成本。这使得组织能更快地扩大规模，目标是到 2030 年每年支持 1000 万农户，为他们创造 10 亿美元新收入，从而对数百万农户的生活产生深远影响。",
      "translated_title": "扩大影响力：GitHub Copilot 如何赋能小农户",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/157849754?v=4&s=200",
          "alt": "Paull Young",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>Empowering 10 million farm families by 2030 to generate $1 billion in new revenue. How GitHub helps One Acre Fund’s mission — driving real impact across Africa.</p>\n<p>The post <a href=\"https://github.blog/open-source/social-impact/scaling-for-impact-how-github-copilot-supercharges-smallholder-farmers/\">Scaling for impact: How GitHub Copilot supercharges smallholder farmers</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何构建安全且可扩展的远程MCP服务器 (原标题: How to build secure and scalable remote MCP servers)",
      "link": "https://github.blog/ai-and-ml/generative-ai/how-to-build-secure-and-scalable-remote-mcp-servers/",
      "pubDate": "Fri, 25 Jul 2025 17:12:02 +0000",
      "isoDate": "2025-07-25T17:12:02.000Z",
      "creator": "Den Delimarsky",
      "summary": "## 如何构建安全且可扩展的远程MCP服务器\n\n本文探讨了构建安全且可扩展的远程模型上下文协议（MCP）服务器的关键方面。MCP允许AI代理连接到外部工具和数据源，而无需实现特定的API连接器，为大型语言模型（LLM）提供所需的上下文。\n\n### 为什么MCP的安全性至关重要\n\n与传统API不同，MCP服务器充当AI代理与无限数据源（包括敏感企业资源）之间的桥梁。安全漏洞不仅会危及数据，还可能使恶意行为者操纵AI行为并访问连接的系统。为了应对常见的攻击向量（如困惑代理问题、令牌传递漏洞和会话劫持），最新的MCP规范包含了安全指南和最佳实践。\n\n### 理解MCP授权\n\nMCP规范采用OAuth 2.1进行安全授权，利用了现代安全能力：\n\n*   **授权服务器发现**：MCP服务器实现OAuth 2.0受保护资源元数据（PRM）（RFC 9728），以公布其支持的授权服务器。\n*   **动态客户端注册**：使用OAuth 2.0动态客户端注册协议（RFC 7591）实现自动客户端注册，消除了AI代理动态连接时的手动设置需求。\n*   **资源指示符**：规范强制要求RFC 8707资源指示符，确保令牌绑定到特定的MCP服务器，防止令牌重用攻击。\n\n开发者可以利用现有的OAuth库和现成的授权服务器/身份提供商，无需从头开始构建安全基础设施。\n\n### 完整的授权流程\n\n连接到受保护的MCP服务器的流程遵循标准的OAuth模式：\n\n1.  **发现阶段**：MCP客户端尝试在没有凭据的情况下访问MCP服务器。\n2.  **服务器响应**：MCP服务器返回HTTP 401 Unauthorized响应，并在WWW-Authenticate头中包含元数据URL。\n3.  **元数据检索**：MCP客户端获取并解析受保护资源元数据，获取授权服务器端点。\n4.  **客户端注册**：MCP客户端自动向授权服务器注册（如果支持）。\n5.  **授权请求**：MCP客户端使用PKCE（Proof Key for Code Exchange）和资源参数启动OAuth流程。\n6.  **用户同意**：用户通过授权服务器授权访问。\n7.  **令牌交换**：MCP客户端交换授权码以获取访问令牌。\n8.  **认证请求**：MCP客户端向MCP服务器发出的所有后续请求都包含Bearer令牌。\n\n### 在MCP中实现授权\n\n大多数OAuth提供商无需额外配置即可用于MCP服务器授权。在实现授权时，需要考虑以下关键组件和行为：\n\n*   **PRM端点**：MCP服务器必须实现`/.well-known/oauth-protected-resource`端点以公布支持的授权服务器范围。MCP TypeScript SDK已原生集成此功能。\n*   **令牌验证中间件**：确保MCP服务器只接受为其签发的令牌，通过以下方式：\n    *   从授权头中提取Bearer令牌。\n    *   使用OAuth提供商的JWKS（JSON Web Key Sets）端点验证令牌签名。\n    *   检查令牌过期和受众声明。\n    *   确保令牌是专门为您的MCP服务器签发的。\n*   **错误处理**：MCP服务器需要返回正确的HTTP状态码（例如，缺少/无效令牌返回HTTP 401 Unauthorized，权限不足返回HTTP 403 Forbidden），并附带适当的WWW-Authenticate头。\n\nAnthropic和MCP社区正在将这些功能直接集成到MCP SDK中，以简化开发。\n\n### 处理多用户场景\n\nMCP服务器中的多租户引入了独特的安全挑战，需要强制执行严格的边界以防止未经授权的访问和数据泄露，解决“困惑代理”问题。\n\n*   **用户身份验证和验证**：OAuth令牌是安全识别用户的基础，其声明（如`sub`）包含用户信息，但必须严格验证。\n*   **强制授权策略**：将用户标识符映射到内部用户配置文件以确定其特定权限，并确保令牌的受众（`aud`）正确，防止令牌被用于其他MCP服务器。\n*   **数据隔离**：每个数据库查询、下游API请求、缓存查找和日志条目都必须限定在当前用户范围内，遵循最小权限原则。\n\n强烈建议使用现有、经过充分测试的库和框架来处理用户会话和数据范围限定。\n\n### 使用AI网关进行扩展\n\nAI网关位于MCP客户端和MCP服务器之间，充当防护罩和流量导向器，集中处理交叉关注点：\n\n*   **速率限制**：防止失控AI代理的资源耗尽。\n*   **JWT令牌验证**：在请求到达服务器前进行验证。\n*   **安全头注入**：保护免受常见Web漏洞侵害。\n*   **请求/响应转换**：优雅地处理协议演变。\n*   **缓存**：针对不经常变化的昂贵操作。\n*   **熔断器**：当下游服务出现问题时快速失败。\n\n这种关注点分离提高了可维护性和诊断效率。\n\n### 生产就绪模式\n\n部署MCP服务器到生产环境时，应采纳以下最佳实践：\n\n*   **更好的秘密管理**：\n    *   MCP服务器需要处理自身的一系列秘密来与各种服务、数据库或API通信。\n    *   生产环境中，环境变量是安全反模式。\n    *   现代方法是使用专用的秘密管理服务（如Azure Key Vault、AWS Secrets Manager或HashiCorp Vault）。\n    *   最安全的方式是使用**工作负载身份**（“无秘密”或“无密钥”），应用程序由云平台分配安全身份，在运行时检索所需秘密，无需在配置中处理长期凭据。\n    *   这支持动态、短生命周期的秘密，实现启动验证和运行时秘密轮换。\n    *   最小权限原则：每个MCP服务器实例只访问其任务绝对需要的秘密。\n*   **可观测性和监控**：\n    *   通过日志、指标和跟踪实现对操作的全面可见性。\n    *   **结构化日志**：跨请求边界保持一致性，使用唯一的关联ID追踪请求的完整旅程。\n    *   **分布式跟踪**：使用OpenTelemetry等标准，提供请求生命周期的详细视图，帮助识别性能瓶颈。\n    *   **安全事件日志**：捕获每次认证尝试、授权失败和异常访问模式，因为MCP服务器是高价值目标。",
      "shortSummary": "本文详细介绍了如何构建安全且可扩展的远程模型上下文协议（MCP）服务器。MCP使AI代理能连接外部数据源。安全性至关重要，规范采用OAuth 2.1进行授权，并强调了授权流程、令牌验证和多用户场景下的数据隔离。为实现可扩展性，建议使用AI网关集中处理流量和安全策略。生产实践包括采用工作负载身份进行高级秘密管理，以及通过结构化日志、分布式跟踪和安全事件日志实现全面的可观测性。",
      "translated_title": "如何构建安全且可扩展的远程MCP服务器",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>More context can mean more attack surfaces for your projects. Be prepared for what lies ahead with this guide.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/generative-ai/how-to-build-secure-and-scalable-remote-mcp-servers/\">How to build secure and scalable remote MCP servers</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "如何在 Azure Pipelines 中简化 GitHub API 调用 (原标题: How to streamline GitHub API calls in Azure Pipelines)",
      "link": "https://github.blog/enterprise-software/ci-cd/how-to-streamline-github-api-calls-in-azure-pipelines/",
      "pubDate": "Thu, 24 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-24T16:00:00.000Z",
      "creator": "Tiago Pascoal",
      "summary": "## Azure Pipelines 中简化 GitHub API 调用\n\n本文探讨了如何在 Azure Pipelines 中通过构建自定义 Azure DevOps 扩展来简化 GitHub API 调用，从而消除 JWT 生成和令牌管理的复杂性，实现强大的自动化和增强的安全控制。\n\n### Azure Pipelines 与 GitHub 的集成\n\nAzure Pipelines 是一个基于云的持续集成/持续交付 (CI/CD) 服务，与 GitHub 深度集成。它能够响应 GitHub 仓库的推送或拉取请求触发管道，并将执行结果通过 GitHub 状态检查报告回 GitHub，帮助开发者监控代码健康状况并强制执行规则集。\n\n### 常见用例和场景\n\n在 Azure Pipelines 中调用 GitHub API 的常见场景包括：\n\n*   **设置提交或拉取请求的状态检查：** 报告管道步骤（如测试、构建、安全扫描）的成功或失败，以强制执行策略并提供反馈。\n*   **向拉取请求添加评论：** 自动发布管道结果、测试覆盖率报告或部署信息。\n*   **更新仓库中的文件：** 自动更新文档、配置文件或版本号（如 `CHANGELOG.md`）。\n*   **管理 GitHub Issues：** 根据管道结果自动创建、更新或关闭问题（如测试失败时创建 Bug 报告）。\n*   **与 GitHub Advanced Security 集成：** 将代码扫描结果发送到 GitHub 的代码扫描功能，实现集中式漏洞管理。\n*   **管理发布和资产：** 成功部署后自动创建 GitHub 发布并上传构建产物。\n*   **使用 GitHub 部署跟踪部署：** 在 GitHub 界面中提供部署历史和状态的可视性。\n*   **触发 GitHub Actions 工作流：** 编排混合 CI/CD 场景，由 Azure Pipelines 处理部分任务，然后触发 GitHub Actions 进行后续处理。\n\n### 理解 GitHub API：REST 与 GraphQL\n\nGitHub API 提供两种主要的接口：\n\n*   **REST API：** 遵循 RESTful 原则，提供直接的 HTTP 端点，适用于管理仓库、问题、拉取请求等常见操作。易于上手，支持个人访问令牌、GitHub Apps 或 OAuth 令牌认证。\n*   **GraphQL API：** 提供更灵活高效的数据检索方式。允许在单个请求中精确指定所需数据，减少数据过度获取或不足，特别适用于检索复杂、嵌套的数据结构。\n\n### 如何选择正确的认证方法\n\nGitHub 提供三种主要的 API 认证方法：\n\n1.  **个人访问令牌 (PATs)：**\n    *   **优点：** 创建和使用简单，快速上手，适用于个人自动化，可配置权限和过期日期。\n    *   **缺点：** 与用户账户生命周期绑定，权限可能粗粒度（经典 PATs），需要手动轮换，一旦泄露可能暴露所有可访问的组织/仓库。\n2.  **OAuth 令牌：**\n    *   **优点：** 标准 OAuth 2.0 流程，适用于需要代表不同用户操作的第三方应用，用户批准权限。\n    *   **缺点：** 需要安全存储刷新令牌，需要服务器基础设施，比 PATs 更复杂，仍与用户账户绑定。\n3.  **GitHub Apps：**\n    *   **优点：** 作为独立实体运行，具有细粒度、仓库级别的权限，基于安装的访问控制，短生命周期令牌（最长 1 小时），更高的速率限制，提供最佳安全模型，不依赖用户账户，有审计跟踪。\n    *   **缺点：** 初始设置更复杂，需要实现 JWT，可能不适用于简单场景，需要私钥管理。\n\n**结论：** 鉴于其细粒度权限、安全特性和更高的速率限制，GitHub Apps 是 Azure Pipelines 中机器到机器集成的理想选择。其短生命周期令牌和基于安装的访问模型提供了比 PATs 和 OAuth 令牌更好的安全控制，特别适合 CI/CD 场景中的自动化。\n\n### 注册和安装 GitHub App\n\n使用 GitHub App 进行认证需要以下步骤：\n\n1.  **注册 GitHub App：** 在 GitHub Enterprise、组织或账户中注册应用，并选择适当的权限。权限决定了应用在企业、组织和仓库中的操作能力。请注意，权限更改可能需要所有者管理员重新授权。通常建议将应用设置为私有。\n2.  **保存私钥：** 如果生成了私钥，请将其安全保存。私钥用于向 GitHub 认证以生成安装令牌。\n3.  **安装 GitHub App：** 将应用安装到将与之交互的账户或组织上，并选择应用可以访问的仓库（所有仓库或特定仓库）。\n\n### GitHub App 认证流程\n\nGitHub Apps 使用两步认证过程访问 GitHub API：\n\n1.  **应用认证：** 应用首先使用其私钥签名的 JSON Web Token (JWT) 进行自我认证。此 JWT 仅证明应用的身份，不提供对 GitHub 资源的直接访问。\n2.  **获取安装令牌：** 为了调用 GitHub API，应用需要获取一个安装令牌。安装令牌是使用应用的 JWT 认证生成的、具有作用域（企业、组织或账户）的访问令牌。这些令牌生命周期短（有效一小时），并且只能访问其安装范围内的资源，并使用安装时授予的最大权限。\n\n获取安装令牌有两种方法：使用已知的安装 ID，或通过调用安装 API 来检索 ID。一旦应用获得安装 ID，它就使用该 ID 请求新的令牌。生成的安装令牌继承了应用的权限和该安装的仓库访问权限，也可以选择请求具有更低权限或仅限于特定仓库的令牌。\n\n### 在 Azure Pipelines 中生成安装令牌\n\n管道作者在 Azure Pipelines 中生成安装令牌有三种主要选项：\n\n1.  **使用命令行工具：** 例如，`gh-token` 是一个流行的开源工具，可以处理整个令牌生成过程。\n2.  **编写自定义脚本：** 使用 `bash/curl` 或 PowerShell 脚本实现令牌生成过程，提供完全控制但需要更多实现工作。\n3.  **使用 Azure Pipeline 任务：** 可以从 Azure DevOps 市场寻找合适的任务，或创建自定义任务来实现 GitHub App 认证流。\n\n### 用于 GitHub App 认证的 Azure DevOps 扩展\n\n在 Azure Pipelines 和 GitHub 之间创建集成时，应用私钥的安全性至关重要。在 Azure Pipelines 中，有多种存储敏感数据的选项：\n\n*   Azure Pipeline 秘密存储（通过秘密变量访问）\n*   Azure Pipelines 安全文件\n*   Azure Pipelines 服务连接\n\n**服务连接的优势：**\n\n服务连接为管理外部服务认证提供了多项关键优势，包括：\n\n*   集中式访问控制\n*   支持多种认证方案\n*   可在项目内的多个管道之间共享连接\n*   内置安全控制，用于管理谁可以查看或修改连接详细信息\n*   将敏感凭据对管道作者隐藏，同时仍允许使用\n*   跨多个项目共享连接，减少重复和管理开销\n\n对于 GitHub App 认证，服务连接尤为重要，因为它们可以安全地存储应用的私钥，允许管理员配置和强制连接行为，并提供比直接在管道或变量组中存储秘密更好的安全性。\n\n### 创建自定义 Azure DevOps 扩展\n\nAzure DevOps 扩展是为 Azure DevOps 服务添加新功能的包。本例中，需要创建一个提供两个关键组件的扩展：\n\n1.  **自定义服务连接类型：** 用于安全存储 GitHub App 凭据和其他设置。\n2.  **自定义任务：** 使用这些凭据生成安装令牌。\n\n一个扩展由描述其功能的清单文件和实际实现代码组成。",
      "shortSummary": "本文介绍如何在 Azure Pipelines 中通过自定义 Azure DevOps 扩展简化 GitHub API 调用。核心在于利用 GitHub Apps 进行身份验证，以消除 JWT 生成和令牌管理的复杂性。GitHub Apps 提供细粒度权限、短生命期令牌和更高安全性，是 CI/CD 场景下机器到机器集成的理想选择。该方法通过集中式凭据管理、标准化集成和跨项目重用，增强了安全性、可维护性并节省了时间。",
      "translated_title": "如何在 Azure Pipelines 中简化 GitHub API 调用",
      "images": [],
      "contentSource": "RSS",
      "content": "<p>Build a custom Azure DevOps extension that eliminates the complexity of JWT generation and token management, enabling powerful automation and enhanced security controls.</p>\n<p>The post <a href=\"https://github.blog/enterprise-software/ci-cd/how-to-streamline-github-api-calls-in-azure-pipelines/\">How to streamline GitHub API calls in Azure Pipelines</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    },
    {
      "title": "使用 GitHub Models 解决开源 AI 项目的推理问题 (原标题: Solving the inference problem for open source AI projects with GitHub Models)",
      "link": "https://github.blog/ai-and-ml/llms/solving-the-inference-problem-for-open-source-ai-projects-with-github-models/",
      "pubDate": "Wed, 23 Jul 2025 16:00:00 +0000",
      "isoDate": "2025-07-23T16:00:00.000Z",
      "creator": "Sean Goedecke",
      "summary": "## 使用 GitHub Models 解决开源 AI 项目的推理问题\n\n本文介绍了 GitHub Models，一个旨在解决开源 AI 项目中 AI 推理（inference）难题的免费、兼容 OpenAI 的 API。\n\n### 现有问题与挑战\n在开源项目中集成 AI 功能时，开发者和用户常面临以下障碍：\n*   **付费 API 密钥：** 要求用户提供 OpenAI 或 Anthropic 等付费 API 密钥，对许多业余爱好者和学生来说成本过高，阻碍了项目采用。\n*   **本地模型运行：** 运行大型语言模型（LLM）需要大量内存，普通笔记本电脑或 GitHub Actions runner（14 GB 容器）难以承受。\n*   **模型分发：** 捆绑多 GB 的模型权重会显著增加安装包大小，并拖慢持续集成（CI）流程。\n这些额外的要求都会筛选掉潜在用户和贡献者。\n\n### GitHub Models 解决方案\nGitHub Models 提供了一个免费的、与 OpenAI 兼容的推理 API，每个 GitHub 账户都可以使用，无需新的密钥、控制台或 SDK。\n\n*   **核心功能：**\n    *   一个 REST 端点，遵循 OpenAI 已知的 `chat/completions` 规范。\n    *   提供 GitHub 托管的一系列精选模型，包括 GPT-4o、DeepSeek-R1、Llama 3 等。\n    *   任何拥有 GitHub 个人访问令牌（PAT）的用户，或在仓库中通过权限选择启用的内置 `GITHUB_TOKEN`，都可以调用。\n    *   **成本：** 个人账户和开源组织提供免费层级；付费层级提供更高的吞吐量和更大的上下文窗口。\n*   **兼容性：** 由于 API 镜像了 OpenAI，任何接受 `baseURL` 参数的客户端（如 OpenAI-JS、OpenAI Python、LangChain、llamaccp 或自定义 curl 脚本）都可以无缝使用。\n\n### 如何开始使用 GitHub Models\nGitHub Models 与 OpenAI `chat/completions` API 兼容，因此几乎所有推理 SDK 都能使用。\n\n*   **通过 OpenAI SDK 示例：**\n    ```javascript\n    import OpenAI from \"openai\";\n    const openai = new OpenAI({\n      baseURL: \"https://models.github.ai/inference/chat/completions\",\n      apiKey: process.env.GITHUB_TOKEN // 或任何带有 models:read 权限的 PAT\n    });\n    const res = await openai.chat.completions.create({\n      model: \"openai/gpt-4o\",\n      messages: [{ role: \"user\", content: \"Hi!\" }]\n    });\n    console.log(res.choices[0].message.content);\n    ```\n*   **GitHub Actions 中的零配置 CI：**\n    *   在工作流文件中请求 `models:read` 权限，内置的 `GITHUB_TOKEN` 将自动获得调用 GitHub Models 的权限。\n    *   这使得开发者可以构建一键安装的 AI 驱动型 Actions，例如：\n        *   代码审查或 PR 分类机器人\n        *   智能问题标签工作流\n        *   每周仓库活动报告生成器\n    *   示例 `.github/workflows/triage.yml` 配置：\n        ```yaml\n        permissions:\n          contents: read\n          issues: write\n          models: read # 👈 为 GITHUB_TOKEN 解锁 GitHub Models\n        jobs:\n          triage:\n            runs-on: ubuntu-latest\n            steps:\n              - uses: actions/checkout@v4\n              - name: Smart issue triage\n                run: node scripts/triage.js\n        ```\n\n### 优势与扩展性\n*   **降低门槛：** 任何拥有 GitHub 账户的用户都可以运行 AI 驱动的代码，无需提供付费 API 密钥，极大地降低了用户和贡献者的入门障碍。\n*   **促进贡献：** 更容易的设置意味着更广泛的 GitHub 用户群体可以参与贡献。\n*   **项目扩展：**\n    *   GitHub Models 推理 API 对所有人免费。\n    *   如果需要更高的推理量，用户可以在设置中开启付费使用，以获得显著更大的上下文窗口和更高的每分钟请求数（RPM）。\n    *   付费层级提供更高的 RPM、支持 128k token 的上下文窗口，并在独立部署中运行以降低延迟。\n    *   可在“设置 > 模型”中为组织或企业启用付费使用。\n\n### 总结\nLLM 正在改变软件开发和交付方式，但要求用户提供付费 API 密钥是一个主要障碍。GitHub Models 通过为 GitHub 上的每位开发者提供免费的高质量 AI 推理，消除了开源 AI 采用的最大障碍。这为更多的贡献、更快的上手和更满意的用户打开了大门。\n\n### 相关资源\n*   GitHub Models 文档\n*   API 参考\n\n### 作者\n*   ![Sean Goedecke](https://avatars.githubusercontent.com/u/19204567?v=4&s=200) Sean Goedecke，GitHub 软件工程师，GitHub Models 团队成员。\n\n### 相关文章\n*   ![Docs](https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg) Docs：掌握 GitHub 所需的一切。\n*   ![GitHub](https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg) GitHub：在 GitHub 上构建未来。\n*   ![Customer stories](https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg) Customer stories：了解使用 GitHub 的公司和工程团队。\n*   ![GitHub Universe 2025](https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg) GitHub Universe 2025：参加旧金山大会。",
      "shortSummary": "GitHub Models 提供了一个免费、兼容 OpenAI 的推理 API，旨在解决开源 AI 项目中因付费 API 密钥或本地模型部署造成的障碍。它允许任何 GitHub 用户通过 PAT 或 `GITHUB_TOKEN` 访问 GitHub 托管的精选模型，无需额外配置。这降低了用户和贡献者的门槛，尤其在 GitHub Actions 中可实现零配置 AI 功能。项目可根据需求升级到付费层级以获得更高性能。GitHub Models 极大地促进了开源 AI 项目的普及和协作。",
      "translated_title": "使用 GitHub Models 解决开源 AI 项目的推理问题",
      "images": [
        {
          "url": "https://avatars.githubusercontent.com/u/19204567?v=4&s=200",
          "alt": "Sean Goedecke",
          "title": "",
          "position": 1
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon-Circle.svg",
          "alt": "Docs",
          "title": "",
          "position": 2
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_95220f.svg",
          "alt": "GitHub",
          "title": "",
          "position": 3
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/07/Icon_da43dc.svg",
          "alt": "Customer stories",
          "title": "",
          "position": 4
        },
        {
          "url": "https://github.blog/wp-content/uploads/2024/04/Universe24-North_Star.svg",
          "alt": "GitHub Universe 2025",
          "title": "",
          "position": 5
        }
      ],
      "contentSource": "完整文章",
      "content": "<p>How using GitHub’s free inference API can make your AI-powered open source software more accessible.</p>\n<p>The post <a href=\"https://github.blog/ai-and-ml/llms/solving-the-inference-problem-for-open-source-ai-projects-with-github-models/\">Solving the inference problem for open source AI projects with GitHub Models</a> appeared first on <a href=\"https://github.blog\">The GitHub Blog</a>.</p>\n"
    }
  ],
  "lastUpdated": "2025-08-11T04:52:34.251Z"
}